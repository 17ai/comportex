<!DOCTYPE html>
<html><head><meta charset="utf-8" content="text/html" http-equiv="Content-Type" /><meta content="Functionally composable cortex, an implementation of Hierarchical Temporal Memory" name="description" /><style type="text/css">/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
.syntaxhighlighter a,
.syntaxhighlighter div,
.syntaxhighlighter code,
.syntaxhighlighter table,
.syntaxhighlighter table td,
.syntaxhighlighter table tr,
.syntaxhighlighter table tbody,
.syntaxhighlighter table thead,
.syntaxhighlighter table caption,
.syntaxhighlighter textarea {
  -moz-border-radius: 0 0 0 0 !important;
  -webkit-border-radius: 0 0 0 0 !important;
  background: none !important;
  border: 0 !important;
  bottom: auto !important;
  float: none !important;
  height: auto !important;
  left: auto !important;
  line-height: 1.1em !important;
/*  margin: 0 !important; */
  outline: 0 !important;
  overflow: visible !important;
  padding: 0 !important;
  position: static !important;
  right: auto !important;
  text-align: left !important;
  top: auto !important;
  vertical-align: baseline !important;
  width: auto !important;
  box-sizing: content-box !important;
  font-family: "Consolas", "Bitstream Vera Sans Mono", "Courier New", Courier, monospace !important;
  font-weight: normal !important;
  font-style: normal !important;
  min-height: inherit !important;
  min-height: auto !important;
}

.syntaxhighlighter {
/*  width: 100% !important; */
  margin: 1em 0 1em 0 !important;
  position: relative !important;
  overflow: auto !important;
}
.syntaxhighlighter.source {
  overflow: hidden !important;
}
.syntaxhighlighter .bold {
  font-weight: bold !important;
}
.syntaxhighlighter .italic {
  font-style: italic !important;
}
.syntaxhighlighter .line {
  white-space: pre !important;
}
.syntaxhighlighter table {
/*    width: 100% !important;*/
}
.syntaxhighlighter table caption {
  text-align: left !important;
  padding: .5em 0 0.5em 1em !important;
}
.syntaxhighlighter table td.code {
  width: 100% !important;
}
.syntaxhighlighter table td.code .container {
  position: relative !important;
}
.syntaxhighlighter table td.code .container textarea {
  box-sizing: border-box !important;
  position: absolute !important;
  left: 0 !important;
  top: 0 !important;
  width: 100% !important;
  height: 100% !important;
  border: none !important;
  background: white !important;
  padding-left: 1em !important;
  overflow: hidden !important;
  white-space: pre !important;
}
.syntaxhighlighter table td.gutter .line {
  text-align: right !important;
  padding: 0 0.5em 0 1em !important;
}
.syntaxhighlighter table td.code .line {
  padding: 0 1em !important;
}
.syntaxhighlighter.nogutter td.code .container textarea, .syntaxhighlighter.nogutter td.code .line {
  padding-left: 0em !important;
}
.syntaxhighlighter.show {
  display: block !important;
}
.syntaxhighlighter.collapsed table {
  display: none !important;
}
.syntaxhighlighter.collapsed .toolbar {
    display: none;
/*  padding: 0.1em 0.8em 0em 0.8em !important;
  font-size: 1em !important;
  position: static !important;
  width: auto !important;
  height: auto !important;*/
}
.syntaxhighlighter.collapsed .toolbar span {
  display: inline !important;
  margin-right: 1em !important;
}
.syntaxhighlighter.collapsed .toolbar span a {
  padding: 0 !important;
  display: none !important;
}
.syntaxhighlighter.collapsed .toolbar span a.expandSource {
  display: inline !important;
}
.syntaxhighlighter .toolbar {
    display: none;
/*  position: absolute !important;
  right: 1px !important;
  top: 1px !important;
  width: 11px !important;
  height: 11px !important;
  font-size: 10px !important;
  z-index: 10 !important;*/
}
.syntaxhighlighter .toolbar span.title {
  display: inline !important;
}
.syntaxhighlighter .toolbar a {
  display: block !important;
  text-align: center !important;
  text-decoration: none !important;
  padding-top: 1px !important;
}
.syntaxhighlighter .toolbar a.expandSource {
  display: none !important;
}
.syntaxhighlighter.ie {
  font-size: .9em !important;
  padding: 1px 0 1px 0 !important;
}
.syntaxhighlighter.ie .toolbar {
  line-height: 8px !important;
}
.syntaxhighlighter.ie .toolbar a {
  padding-top: 0px !important;
}
.syntaxhighlighter.printing .line.alt1 .content,
.syntaxhighlighter.printing .line.alt2 .content,
.syntaxhighlighter.printing .line.highlighted .number,
.syntaxhighlighter.printing .line.highlighted.alt1 .content,
.syntaxhighlighter.printing .line.highlighted.alt2 .content {
  background: none !important;
}
.syntaxhighlighter.printing .line .number {
  color: #bbbbbb !important;
}
.syntaxhighlighter.printing .line .content {
  color: black !important;
}
.syntaxhighlighter.printing .toolbar {
  display: none !important;
}
.syntaxhighlighter.printing a {
  text-decoration: none !important;
}
.syntaxhighlighter.printing .plain, .syntaxhighlighter.printing .plain a {
  color: black !important;
}
.syntaxhighlighter.printing .comments, .syntaxhighlighter.printing .comments a {
  color: #008200 !important;
}
.syntaxhighlighter.printing .string, .syntaxhighlighter.printing .string a {
  color: blue !important;
}
.syntaxhighlighter.printing .keyword {
  color: #006699 !important;
  font-weight: bold !important;
}
.syntaxhighlighter.printing .preprocessor {
  color: gray !important;
}
.syntaxhighlighter.printing .variable {
  color: #aa7700 !important;
}
.syntaxhighlighter.printing .value {
  color: #009900 !important;
}
.syntaxhighlighter.printing .functions {
  color: #ff1493 !important;
}
.syntaxhighlighter.printing .constants {
  color: #0066cc !important;
}
.syntaxhighlighter.printing .script {
  font-weight: bold !important;
}
.syntaxhighlighter.printing .color1, .syntaxhighlighter.printing .color1 a {
  color: gray !important;
}
.syntaxhighlighter.printing .color2, .syntaxhighlighter.printing .color2 a {
  color: #ff1493 !important;
}
.syntaxhighlighter.printing .color3, .syntaxhighlighter.printing .color3 a {
  color: red !important;
}
.syntaxhighlighter.printing .break, .syntaxhighlighter.printing .break a {
  color: black !important;
}
</style><style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style><style type="text/css">/**
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
.syntaxhighlighter {
  background-color: transparent !important;
}
.syntaxhighlighter .line.alt1 {
  background-color: transparent !important;
}
.syntaxhighlighter .line.alt2 {
  background-color: transparent !important;
}
.syntaxhighlighter .line.highlighted.alt1, .syntaxhighlighter .line.highlighted.alt2 {
  background-color: #c3defe !important;
}
.syntaxhighlighter .line.highlighted.number {
  color: white !important;
}
.syntaxhighlighter table caption {
  color: black !important;
}
.syntaxhighlighter .gutter {
  color: #787878 !important;
}
.syntaxhighlighter .gutter .line {
  border-right: 3px solid #d4d0c8 !important;
}
.syntaxhighlighter .gutter .line.highlighted {
  background-color: #d4d0c8 !important;
  color: white !important;
}
.syntaxhighlighter.printing .line .content {
  border: none !important;
}
.syntaxhighlighter.collapsed {
  overflow: visible !important;
}
.syntaxhighlighter.collapsed .toolbar {
  color: #3f5fbf !important;
  background: white !important;
  border: 1px solid #d4d0c8 !important;
}
.syntaxhighlighter.collapsed .toolbar a {
  color: #3f5fbf !important;
}
.syntaxhighlighter.collapsed .toolbar a:hover {
  color: #aa7700 !important;
}
.syntaxhighlighter .toolbar {
  color: #a0a0a0 !important;
  background: #d4d0c8 !important;
  border: none !important;
}
.syntaxhighlighter .toolbar a {
  color: #a0a0a0 !important;
}
.syntaxhighlighter .toolbar a:hover {
  color: red !important;
}
.syntaxhighlighter .plain, .syntaxhighlighter .plain a {
  color: black !important;
}
.syntaxhighlighter .comments, .syntaxhighlighter .comments a {
  color: #3f5fbf !important;
}
.syntaxhighlighter .string, .syntaxhighlighter .string a {
  color: #2a00ff !important;
}
.syntaxhighlighter .keyword {
  color: #7f0055 !important;
}
.syntaxhighlighter .preprocessor {
  color: #646464 !important;
}
.syntaxhighlighter .variable {
  color: #aa7700 !important;
}
.syntaxhighlighter .value {
  color: #009900 !important;
}
.syntaxhighlighter .functions {
  color: #ff1493 !important;
}
.syntaxhighlighter .constants {
  color: #0066cc !important;
}
.syntaxhighlighter .script {
  font-weight: bold !important;
  color: #7f0055 !important;
  background-color: none !important;
}
.syntaxhighlighter .color1, .syntaxhighlighter .color1 a {
  color: gray !important;
}
.syntaxhighlighter .color2, .syntaxhighlighter .color2 a {
  color: #ff1493 !important;
}
.syntaxhighlighter .color3, .syntaxhighlighter .color3 a {
  color: red !important;
}

.syntaxhighlighter .xml .keyword {
  color: #3f7f7f !important;
  font-weight: normal !important;
}
.syntaxhighlighter .xml .color1, .syntaxhighlighter .xml .color1 a {
  color: #7f007f !important;
}
.syntaxhighlighter .xml .string {
  font-style: italic !important;
  color: #2a00ff !important;
}

.clojure.syntaxhighlighter .invalid { 
   background-color: #FAA !important;
}

.clojure.syntaxhighlighter .quoted {      
    font-style: italic !important;
}

.syntaxhighlighter .clojure.variable,
.syntaxhighlighter .clojure.symbol,
.syntaxhighlighter .clojure.value
{
    color: #006060 !important;
}

.syntaxhighlighter .clojure.string {
    color: #55B !important;
}

.syntaxhighlighter .clojure.functions {
    color: black !important;
}

.syntaxhighlighter .clojure.color1 {
    color: #666 !important;
}

.syntaxhighlighter .clojure.color3 {
    color: #900 !important;
}

.syntaxhighlighter .clojure.constants {
    color: #1A734D !important;
}

</style><style type="text/css">html{margin:0;padding:0;}h1{margin:0;padding:0;}h2{margin:0;padding:0;}h3{margin:0;padding:0;}h4{margin:0;padding:0;}a{color:#261A3B;}a:visited{color:#261A3B;}</style><style type="text/css">.header{margin-top:30px;}h1.project-name{font-size:34px;display:inline;}h2.project-version{font-size:18px;margin-top:0;display:inline;margin-left:10px;}.toc-link{font-size:12px;margin-left:10px;color:#252519;text-decoration:none;}.toc-link:hover{color:#5050A6;}.toc h1{font-size:34px;margin:0;}.docs-header{border-bottom:dotted #aaa 1px;padding-bottom:10px;margin-bottom:25px;}.toc h1{font-size:24px;}.toc{border-bottom:solid #bbb 1px;margin-bottom:40px;}.toc ul{margin-left:20px;padding-left:0px;padding-top:0;margin-top:0;}.toc li{list-style-type:none;padding-left:0;}.dependencies{}.dependencies table{font-size:16px;width:99.99%;border:none;margin-left:20px;}.dependencies td{padding-right:20px;;white-space:nowrap;}.dependencies .dotted{width:99%;}.dependencies .dotted hr{border-right:none;color:transparent;background-color:transparent;noshade:noshade;border-left:none;border-top:none;margin-bottom:-6px;height:0;border-bottom:dotted #bbb 1px;}.dependencies .dep-version{text-align:right;}.plugins ul{margin-left:20px;padding-left:0px;padding-top:0;margin-top:0;}.plugins li{list-style-type:none;padding-left:0;}.header p{margin-left:20px;}</style><style type="text/css">#floating-toc{position:fixed;top:10px;right:20px;height:20px;overflow:hidden;text-align:right;}#floating-toc li{list-style-type:none;margin:0;padding:0;}</style><style type="text/css">body{margin:0;padding:0;font-family:'Palatino Linotype', 'Book Antiqua', Palatino, FreeSerif, serif;;font-size:16px;color:#252519;background-color:#F5F5FF;}h1{font-size:20px;margin-top:0;}h2{font-size:18px;}h3{font-size:16px;}a.anchor{text-decoration:none;color:#252519;}a.anchor:hover{color:#5050A6;}table{border-spacing:0;border-bottom:solid #ddd 1px;;margin-bottom:10px;}code{display:inline;}p{margin-top:8px;}tr{margin:0px;padding:0px;}td.docs{width:410px;max-width:410px;vertical-align:top;margin:0px;padding-left:55px;padding-right:20px;border:none;background-color:#FFF;}td.docs pre{font-size:12px;overflow:hidden;}td.codes{vertical-align:top;font-size:10pt;overflow:hidden;background-color:#F5F5FF;width:55%;border-left:solid #E5E5EE 1px;padding-left:20px;border:none;margin:0px;}td.spacer{padding-bottom:40px;}pre code{display:block;padding:4px;}code{background-color:ghostWhite;border:solid #DEDEDE 1px;padding-left:3px;padding-right:3px;font-size:14px;}.syntaxhighlighter code{font-size:13px;}.footer{text-align:center;}</style><script type="text/javascript">/*! jQuery v1.7.1 jquery.com | jquery.org/license */
(function(a,b){function cy(a){return f.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:!1}function cv(a){if(!ck[a]){var b=c.body,d=f("<"+a+">").appendTo(b),e=d.css("display");d.remove();if(e==="none"||e===""){cl||(cl=c.createElement("iframe"),cl.frameBorder=cl.width=cl.height=0),b.appendChild(cl);if(!cm||!cl.createElement)cm=(cl.contentWindow||cl.contentDocument).document,cm.write((c.compatMode==="CSS1Compat"?"<!doctype html>":"")+"<html><body>"),cm.close();d=cm.createElement(a),cm.body.appendChild(d),e=f.css(d,"display"),b.removeChild(cl)}ck[a]=e}return ck[a]}function cu(a,b){var c={};f.each(cq.concat.apply([],cq.slice(0,b)),function(){c[this]=a});return c}function ct(){cr=b}function cs(){setTimeout(ct,0);return cr=f.now()}function cj(){try{return new a.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}}function ci(){try{return new a.XMLHttpRequest}catch(b){}}function cc(a,c){a.dataFilter&&(c=a.dataFilter(c,a.dataType));var d=a.dataTypes,e={},g,h,i=d.length,j,k=d[0],l,m,n,o,p;for(g=1;g<i;g++){if(g===1)for(h in a.converters)typeof h=="string"&&(e[h.toLowerCase()]=a.converters[h]);l=k,k=d[g];if(k==="*")k=l;else if(l!=="*"&&l!==k){m=l+" "+k,n=e[m]||e["* "+k];if(!n){p=b;for(o in e){j=o.split(" ");if(j[0]===l||j[0]==="*"){p=e[j[1]+" "+k];if(p){o=e[o],o===!0?n=p:p===!0&&(n=o);break}}}}!n&&!p&&f.error("No conversion from "+m.replace(" "," to ")),n!==!0&&(c=n?n(c):p(o(c)))}}return c}function cb(a,c,d){var e=a.contents,f=a.dataTypes,g=a.responseFields,h,i,j,k;for(i in g)i in d&&(c[g[i]]=d[i]);while(f[0]==="*")f.shift(),h===b&&(h=a.mimeType||c.getResponseHeader("content-type"));if(h)for(i in e)if(e[i]&&e[i].test(h)){f.unshift(i);break}if(f[0]in d)j=f[0];else{for(i in d){if(!f[0]||a.converters[i+" "+f[0]]){j=i;break}k||(k=i)}j=j||k}if(j){j!==f[0]&&f.unshift(j);return d[j]}}function ca(a,b,c,d){if(f.isArray(b))f.each(b,function(b,e){c||bE.test(a)?d(a,e):ca(a+"["+(typeof e=="object"||f.isArray(e)?b:"")+"]",e,c,d)});else if(!c&&b!=null&&typeof b=="object")for(var e in b)ca(a+"["+e+"]",b[e],c,d);else d(a,b)}function b_(a,c){var d,e,g=f.ajaxSettings.flatOptions||{};for(d in c)c[d]!==b&&((g[d]?a:e||(e={}))[d]=c[d]);e&&f.extend(!0,a,e)}function b$(a,c,d,e,f,g){f=f||c.dataTypes[0],g=g||{},g[f]=!0;var h=a[f],i=0,j=h?h.length:0,k=a===bT,l;for(;i<j&&(k||!l);i++)l=h[i](c,d,e),typeof l=="string"&&(!k||g[l]?l=b:(c.dataTypes.unshift(l),l=b$(a,c,d,e,l,g)));(k||!l)&&!g["*"]&&(l=b$(a,c,d,e,"*",g));return l}function bZ(a){return function(b,c){typeof b!="string"&&(c=b,b="*");if(f.isFunction(c)){var d=b.toLowerCase().split(bP),e=0,g=d.length,h,i,j;for(;e<g;e++)h=d[e],j=/^\+/.test(h),j&&(h=h.substr(1)||"*"),i=a[h]=a[h]||[],i[j?"unshift":"push"](c)}}}function bC(a,b,c){var d=b==="width"?a.offsetWidth:a.offsetHeight,e=b==="width"?bx:by,g=0,h=e.length;if(d>0){if(c!=="border")for(;g<h;g++)c||(d-=parseFloat(f.css(a,"padding"+e[g]))||0),c==="margin"?d+=parseFloat(f.css(a,c+e[g]))||0:d-=parseFloat(f.css(a,"border"+e[g]+"Width"))||0;return d+"px"}d=bz(a,b,b);if(d<0||d==null)d=a.style[b]||0;d=parseFloat(d)||0;if(c)for(;g<h;g++)d+=parseFloat(f.css(a,"padding"+e[g]))||0,c!=="padding"&&(d+=parseFloat(f.css(a,"border"+e[g]+"Width"))||0),c==="margin"&&(d+=parseFloat(f.css(a,c+e[g]))||0);return d+"px"}function bp(a,b){b.src?f.ajax({url:b.src,async:!1,dataType:"script"}):f.globalEval((b.text||b.textContent||b.innerHTML||"").replace(bf,"/*$0*/")),b.parentNode&&b.parentNode.removeChild(b)}function bo(a){var b=c.createElement("div");bh.appendChild(b),b.innerHTML=a.outerHTML;return b.firstChild}function bn(a){var b=(a.nodeName||"").toLowerCase();b==="input"?bm(a):b!=="script"&&typeof a.getElementsByTagName!="undefined"&&f.grep(a.getElementsByTagName("input"),bm)}function bm(a){if(a.type==="checkbox"||a.type==="radio")a.defaultChecked=a.checked}function bl(a){return typeof a.getElementsByTagName!="undefined"?a.getElementsByTagName("*"):typeof a.querySelectorAll!="undefined"?a.querySelectorAll("*"):[]}function bk(a,b){var c;if(b.nodeType===1){b.clearAttributes&&b.clearAttributes(),b.mergeAttributes&&b.mergeAttributes(a),c=b.nodeName.toLowerCase();if(c==="object")b.outerHTML=a.outerHTML;else if(c!=="input"||a.type!=="checkbox"&&a.type!=="radio"){if(c==="option")b.selected=a.defaultSelected;else if(c==="input"||c==="textarea")b.defaultValue=a.defaultValue}else a.checked&&(b.defaultChecked=b.checked=a.checked),b.value!==a.value&&(b.value=a.value);b.removeAttribute(f.expando)}}function bj(a,b){if(b.nodeType===1&&!!f.hasData(a)){var c,d,e,g=f._data(a),h=f._data(b,g),i=g.events;if(i){delete h.handle,h.events={};for(c in i)for(d=0,e=i[c].length;d<e;d++)f.event.add(b,c+(i[c][d].namespace?".":"")+i[c][d].namespace,i[c][d],i[c][d].data)}h.data&&(h.data=f.extend({},h.data))}}function bi(a,b){return f.nodeName(a,"table")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function U(a){var b=V.split("|"),c=a.createDocumentFragment();if(c.createElement)while(b.length)c.createElement(b.pop());return c}function T(a,b,c){b=b||0;if(f.isFunction(b))return f.grep(a,function(a,d){var e=!!b.call(a,d,a);return e===c});if(b.nodeType)return f.grep(a,function(a,d){return a===b===c});if(typeof b=="string"){var d=f.grep(a,function(a){return a.nodeType===1});if(O.test(b))return f.filter(b,d,!c);b=f.filter(b,d)}return f.grep(a,function(a,d){return f.inArray(a,b)>=0===c})}function S(a){return!a||!a.parentNode||a.parentNode.nodeType===11}function K(){return!0}function J(){return!1}function n(a,b,c){var d=b+"defer",e=b+"queue",g=b+"mark",h=f._data(a,d);h&&(c==="queue"||!f._data(a,e))&&(c==="mark"||!f._data(a,g))&&setTimeout(function(){!f._data(a,e)&&!f._data(a,g)&&(f.removeData(a,d,!0),h.fire())},0)}function m(a){for(var b in a){if(b==="data"&&f.isEmptyObject(a[b]))continue;if(b!=="toJSON")return!1}return!0}function l(a,c,d){if(d===b&&a.nodeType===1){var e="data-"+c.replace(k,"-$1").toLowerCase();d=a.getAttribute(e);if(typeof d=="string"){try{d=d==="true"?!0:d==="false"?!1:d==="null"?null:f.isNumeric(d)?parseFloat(d):j.test(d)?f.parseJSON(d):d}catch(g){}f.data(a,c,d)}else d=b}return d}function h(a){var b=g[a]={},c,d;a=a.split(/\s+/);for(c=0,d=a.length;c<d;c++)b[a[c]]=!0;return b}var c=a.document,d=a.navigator,e=a.location,f=function(){function J(){if(!e.isReady){try{c.documentElement.doScroll("left")}catch(a){setTimeout(J,1);return}e.ready()}}var e=function(a,b){return new e.fn.init(a,b,h)},f=a.jQuery,g=a.$,h,i=/^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,j=/\S/,k=/^\s+/,l=/\s+$/,m=/^<(\w+)\s*\/?>(?:<\/\1>)?$/,n=/^[\],:{}\s]*$/,o=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,p=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,q=/(?:^|:|,)(?:\s*\[)+/g,r=/(webkit)[ \/]([\w.]+)/,s=/(opera)(?:.*version)?[ \/]([\w.]+)/,t=/(msie) ([\w.]+)/,u=/(mozilla)(?:.*? rv:([\w.]+))?/,v=/-([a-z]|[0-9])/ig,w=/^-ms-/,x=function(a,b){return(b+"").toUpperCase()},y=d.userAgent,z,A,B,C=Object.prototype.toString,D=Object.prototype.hasOwnProperty,E=Array.prototype.push,F=Array.prototype.slice,G=String.prototype.trim,H=Array.prototype.indexOf,I={};e.fn=e.prototype={constructor:e,init:function(a,d,f){var g,h,j,k;if(!a)return this;if(a.nodeType){this.context=this[0]=a,this.length=1;return this}if(a==="body"&&!d&&c.body){this.context=c,this[0]=c.body,this.selector=a,this.length=1;return this}if(typeof a=="string"){a.charAt(0)!=="<"||a.charAt(a.length-1)!==">"||a.length<3?g=i.exec(a):g=[null,a,null];if(g&&(g[1]||!d)){if(g[1]){d=d instanceof e?d[0]:d,k=d?d.ownerDocument||d:c,j=m.exec(a),j?e.isPlainObject(d)?(a=[c.createElement(j[1])],e.fn.attr.call(a,d,!0)):a=[k.createElement(j[1])]:(j=e.buildFragment([g[1]],[k]),a=(j.cacheable?e.clone(j.fragment):j.fragment).childNodes);return e.merge(this,a)}h=c.getElementById(g[2]);if(h&&h.parentNode){if(h.id!==g[2])return f.find(a);this.length=1,this[0]=h}this.context=c,this.selector=a;return this}return!d||d.jquery?(d||f).find(a):this.constructor(d).find(a)}if(e.isFunction(a))return f.ready(a);a.selector!==b&&(this.selector=a.selector,this.context=a.context);return e.makeArray(a,this)},selector:"",jquery:"1.7.1",length:0,size:function(){return this.length},toArray:function(){return F.call(this,0)},get:function(a){return a==null?this.toArray():a<0?this[this.length+a]:this[a]},pushStack:function(a,b,c){var d=this.constructor();e.isArray(a)?E.apply(d,a):e.merge(d,a),d.prevObject=this,d.context=this.context,b==="find"?d.selector=this.selector+(this.selector?" ":"")+c:b&&(d.selector=this.selector+"."+b+"("+c+")");return d},each:function(a,b){return e.each(this,a,b)},ready:function(a){e.bindReady(),A.add(a);return this},eq:function(a){a=+a;return a===-1?this.slice(a):this.slice(a,a+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(F.apply(this,arguments),"slice",F.call(arguments).join(","))},map:function(a){return this.pushStack(e.map(this,function(b,c){return a.call(b,c,b)}))},end:function(){return this.prevObject||this.constructor(null)},push:E,sort:[].sort,splice:[].splice},e.fn.init.prototype=e.fn,e.extend=e.fn.extend=function(){var a,c,d,f,g,h,i=arguments[0]||{},j=1,k=arguments.length,l=!1;typeof i=="boolean"&&(l=i,i=arguments[1]||{},j=2),typeof i!="object"&&!e.isFunction(i)&&(i={}),k===j&&(i=this,--j);for(;j<k;j++)if((a=arguments[j])!=null)for(c in a){d=i[c],f=a[c];if(i===f)continue;l&&f&&(e.isPlainObject(f)||(g=e.isArray(f)))?(g?(g=!1,h=d&&e.isArray(d)?d:[]):h=d&&e.isPlainObject(d)?d:{},i[c]=e.extend(l,h,f)):f!==b&&(i[c]=f)}return i},e.extend({noConflict:function(b){a.$===e&&(a.$=g),b&&a.jQuery===e&&(a.jQuery=f);return e},isReady:!1,readyWait:1,holdReady:function(a){a?e.readyWait++:e.ready(!0)},ready:function(a){if(a===!0&&!--e.readyWait||a!==!0&&!e.isReady){if(!c.body)return setTimeout(e.ready,1);e.isReady=!0;if(a!==!0&&--e.readyWait>0)return;A.fireWith(c,[e]),e.fn.trigger&&e(c).trigger("ready").off("ready")}},bindReady:function(){if(!A){A=e.Callbacks("once memory");if(c.readyState==="complete")return setTimeout(e.ready,1);if(c.addEventListener)c.addEventListener("DOMContentLoaded",B,!1),a.addEventListener("load",e.ready,!1);else if(c.attachEvent){c.attachEvent("onreadystatechange",B),a.attachEvent("onload",e.ready);var b=!1;try{b=a.frameElement==null}catch(d){}c.documentElement.doScroll&&b&&J()}}},isFunction:function(a){return e.type(a)==="function"},isArray:Array.isArray||function(a){return e.type(a)==="array"},isWindow:function(a){return a&&typeof a=="object"&&"setInterval"in a},isNumeric:function(a){return!isNaN(parseFloat(a))&&isFinite(a)},type:function(a){return a==null?String(a):I[C.call(a)]||"object"},isPlainObject:function(a){if(!a||e.type(a)!=="object"||a.nodeType||e.isWindow(a))return!1;try{if(a.constructor&&!D.call(a,"constructor")&&!D.call(a.constructor.prototype,"isPrototypeOf"))return!1}catch(c){return!1}var d;for(d in a);return d===b||D.call(a,d)},isEmptyObject:function(a){for(var b in a)return!1;return!0},error:function(a){throw new Error(a)},parseJSON:function(b){if(typeof b!="string"||!b)return null;b=e.trim(b);if(a.JSON&&a.JSON.parse)return a.JSON.parse(b);if(n.test(b.replace(o,"@").replace(p,"]").replace(q,"")))return(new Function("return "+b))();e.error("Invalid JSON: "+b)},parseXML:function(c){var d,f;try{a.DOMParser?(f=new DOMParser,d=f.parseFromString(c,"text/xml")):(d=new ActiveXObject("Microsoft.XMLDOM"),d.async="false",d.loadXML(c))}catch(g){d=b}(!d||!d.documentElement||d.getElementsByTagName("parsererror").length)&&e.error("Invalid XML: "+c);return d},noop:function(){},globalEval:function(b){b&&j.test(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(w,"ms-").replace(v,x)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toUpperCase()===b.toUpperCase()},each:function(a,c,d){var f,g=0,h=a.length,i=h===b||e.isFunction(a);if(d){if(i){for(f in a)if(c.apply(a[f],d)===!1)break}else for(;g<h;)if(c.apply(a[g++],d)===!1)break}else if(i){for(f in a)if(c.call(a[f],f,a[f])===!1)break}else for(;g<h;)if(c.call(a[g],g,a[g++])===!1)break;return a},trim:G?function(a){return a==null?"":G.call(a)}:function(a){return a==null?"":(a+"").replace(k,"").replace(l,"")},makeArray:function(a,b){var c=b||[];if(a!=null){var d=e.type(a);a.length==null||d==="string"||d==="function"||d==="regexp"||e.isWindow(a)?E.call(c,a):e.merge(c,a)}return c},inArray:function(a,b,c){var d;if(b){if(H)return H.call(b,a,c);d=b.length,c=c?c<0?Math.max(0,d+c):c:0;for(;c<d;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,c){var d=a.length,e=0;if(typeof c.length=="number")for(var f=c.length;e<f;e++)a[d++]=c[e];else while(c[e]!==b)a[d++]=c[e++];a.length=d;return a},grep:function(a,b,c){var d=[],e;c=!!c;for(var f=0,g=a.length;f<g;f++)e=!!b(a[f],f),c!==e&&d.push(a[f]);return d},map:function(a,c,d){var f,g,h=[],i=0,j=a.length,k=a instanceof e||j!==b&&typeof j=="number"&&(j>0&&a[0]&&a[j-1]||j===0||e.isArray(a));if(k)for(;i<j;i++)f=c(a[i],i,d),f!=null&&(h[h.length]=f);else for(g in a)f=c(a[g],g,d),f!=null&&(h[h.length]=f);return h.concat.apply([],h)},guid:1,proxy:function(a,c){if(typeof c=="string"){var d=a[c];c=a,a=d}if(!e.isFunction(a))return b;var f=F.call(arguments,2),g=function(){return a.apply(c,f.concat(F.call(arguments)))};g.guid=a.guid=a.guid||g.guid||e.guid++;return g},access:function(a,c,d,f,g,h){var i=a.length;if(typeof c=="object"){for(var j in c)e.access(a,j,c[j],f,g,d);return a}if(d!==b){f=!h&&f&&e.isFunction(d);for(var k=0;k<i;k++)g(a[k],c,f?d.call(a[k],k,g(a[k],c)):d,h);return a}return i?g(a[0],c):b},now:function(){return(new Date).getTime()},uaMatch:function(a){a=a.toLowerCase();var b=r.exec(a)||s.exec(a)||t.exec(a)||a.indexOf("compatible")<0&&u.exec(a)||[];return{browser:b[1]||"",version:b[2]||"0"}},sub:function(){function a(b,c){return new a.fn.init(b,c)}e.extend(!0,a,this),a.superclass=this,a.fn=a.prototype=this(),a.fn.constructor=a,a.sub=this.sub,a.fn.init=function(d,f){f&&f instanceof e&&!(f instanceof a)&&(f=a(f));return e.fn.init.call(this,d,f,b)},a.fn.init.prototype=a.fn;var b=a(c);return a},browser:{}}),e.each("Boolean Number String Function Array Date RegExp Object".split(" "),function(a,b){I["[object "+b+"]"]=b.toLowerCase()}),z=e.uaMatch(y),z.browser&&(e.browser[z.browser]=!0,e.browser.version=z.version),e.browser.webkit&&(e.browser.safari=!0),j.test(" ")&&(k=/^[\s\xA0]+/,l=/[\s\xA0]+$/),h=e(c),c.addEventListener?B=function(){c.removeEventListener("DOMContentLoaded",B,!1),e.ready()}:c.attachEvent&&(B=function(){c.readyState==="complete"&&(c.detachEvent("onreadystatechange",B),e.ready())});return e}(),g={};f.Callbacks=function(a){a=a?g[a]||h(a):{};var c=[],d=[],e,i,j,k,l,m=function(b){var d,e,g,h,i;for(d=0,e=b.length;d<e;d++)g=b[d],h=f.type(g),h==="array"?m(g):h==="function"&&(!a.unique||!o.has(g))&&c.push(g)},n=function(b,f){f=f||[],e=!a.memory||[b,f],i=!0,l=j||0,j=0,k=c.length;for(;c&&l<k;l++)if(c[l].apply(b,f)===!1&&a.stopOnFalse){e=!0;break}i=!1,c&&(a.once?e===!0?o.disable():c=[]:d&&d.length&&(e=d.shift(),o.fireWith(e[0],e[1])))},o={add:function(){if(c){var a=c.length;m(arguments),i?k=c.length:e&&e!==!0&&(j=a,n(e[0],e[1]))}return this},remove:function(){if(c){var b=arguments,d=0,e=b.length;for(;d<e;d++)for(var f=0;f<c.length;f++)if(b[d]===c[f]){i&&f<=k&&(k--,f<=l&&l--),c.splice(f--,1);if(a.unique)break}}return this},has:function(a){if(c){var b=0,d=c.length;for(;b<d;b++)if(a===c[b])return!0}return!1},empty:function(){c=[];return this},disable:function(){c=d=e=b;return this},disabled:function(){return!c},lock:function(){d=b,(!e||e===!0)&&o.disable();return this},locked:function(){return!d},fireWith:function(b,c){d&&(i?a.once||d.push([b,c]):(!a.once||!e)&&n(b,c));return this},fire:function(){o.fireWith(this,arguments);return this},fired:function(){return!!e}};return o};var i=[].slice;f.extend({Deferred:function(a){var b=f.Callbacks("once memory"),c=f.Callbacks("once memory"),d=f.Callbacks("memory"),e="pending",g={resolve:b,reject:c,notify:d},h={done:b.add,fail:c.add,progress:d.add,state:function(){return e},isResolved:b.fired,isRejected:c.fired,then:function(a,b,c){i.done(a).fail(b).progress(c);return this},always:function(){i.done.apply(i,arguments).fail.apply(i,arguments);return this},pipe:function(a,b,c){return f.Deferred(function(d){f.each({done:[a,"resolve"],fail:[b,"reject"],progress:[c,"notify"]},function(a,b){var c=b[0],e=b[1],g;f.isFunction(c)?i[a](function(){g=c.apply(this,arguments),g&&f.isFunction(g.promise)?g.promise().then(d.resolve,d.reject,d.notify):d[e+"With"](this===i?d:this,[g])}):i[a](d[e])})}).promise()},promise:function(a){if(a==null)a=h;else for(var b in h)a[b]=h[b];return a}},i=h.promise({}),j;for(j in g)i[j]=g[j].fire,i[j+"With"]=g[j].fireWith;i.done(function(){e="resolved"},c.disable,d.lock).fail(function(){e="rejected"},b.disable,d.lock),a&&a.call(i,i);return i},when:function(a){function m(a){return function(b){e[a]=arguments.length>1?i.call(arguments,0):b,j.notifyWith(k,e)}}function l(a){return function(c){b[a]=arguments.length>1?i.call(arguments,0):c,--g||j.resolveWith(j,b)}}var b=i.call(arguments,0),c=0,d=b.length,e=Array(d),g=d,h=d,j=d<=1&&a&&f.isFunction(a.promise)?a:f.Deferred(),k=j.promise();if(d>1){for(;c<d;c++)b[c]&&b[c].promise&&f.isFunction(b[c].promise)?b[c].promise().then(l(c),j.reject,m(c)):--g;g||j.resolveWith(j,b)}else j!==a&&j.resolveWith(j,d?[a]:[]);return k}}),f.support=function(){var b,d,e,g,h,i,j,k,l,m,n,o,p,q=c.createElement("div"),r=c.documentElement;q.setAttribute("className","t"),q.innerHTML="   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>",d=q.getElementsByTagName("*"),e=q.getElementsByTagName("a")[0];if(!d||!d.length||!e)return{};g=c.createElement("select"),h=g.appendChild(c.createElement("option")),i=q.getElementsByTagName("input")[0],b={leadingWhitespace:q.firstChild.nodeType===3,tbody:!q.getElementsByTagName("tbody").length,htmlSerialize:!!q.getElementsByTagName("link").length,style:/top/.test(e.getAttribute("style")),hrefNormalized:e.getAttribute("href")==="/a",opacity:/^0.55/.test(e.style.opacity),cssFloat:!!e.style.cssFloat,checkOn:i.value==="on",optSelected:h.selected,getSetAttribute:q.className!=="t",enctype:!!c.createElement("form").enctype,html5Clone:c.createElement("nav").cloneNode(!0).outerHTML!=="<:nav></:nav>",submitBubbles:!0,changeBubbles:!0,focusinBubbles:!1,deleteExpando:!0,noCloneEvent:!0,inlineBlockNeedsLayout:!1,shrinkWrapBlocks:!1,reliableMarginRight:!0},i.checked=!0,b.noCloneChecked=i.cloneNode(!0).checked,g.disabled=!0,b.optDisabled=!h.disabled;try{delete q.test}catch(s){b.deleteExpando=!1}!q.addEventListener&&q.attachEvent&&q.fireEvent&&(q.attachEvent("onclick",function(){b.noCloneEvent=!1}),q.cloneNode(!0).fireEvent("onclick")),i=c.createElement("input"),i.value="t",i.setAttribute("type","radio"),b.radioValue=i.value==="t",i.setAttribute("checked","checked"),q.appendChild(i),k=c.createDocumentFragment(),k.appendChild(q.lastChild),b.checkClone=k.cloneNode(!0).cloneNode(!0).lastChild.checked,b.appendChecked=i.checked,k.removeChild(i),k.appendChild(q),q.innerHTML="",a.getComputedStyle&&(j=c.createElement("div"),j.style.width="0",j.style.marginRight="0",q.style.width="2px",q.appendChild(j),b.reliableMarginRight=(parseInt((a.getComputedStyle(j,null)||{marginRight:0}).marginRight,10)||0)===0);if(q.attachEvent)for(o in{submit:1,change:1,focusin:1})n="on"+o,p=n in q,p||(q.setAttribute(n,"return;"),p=typeof q[n]=="function"),b[o+"Bubbles"]=p;k.removeChild(q),k=g=h=j=q=i=null,f(function(){var a,d,e,g,h,i,j,k,m,n,o,r=c.getElementsByTagName("body")[0];!r||(j=1,k="position:absolute;top:0;left:0;width:1px;height:1px;margin:0;",m="visibility:hidden;border:0;",n="style='"+k+"border:5px solid #000;padding:0;'",o="<div "+n+"><div></div></div>"+"<table "+n+" cellpadding='0' cellspacing='0'>"+"<tr><td></td></tr></table>",a=c.createElement("div"),a.style.cssText=m+"width:0;height:0;position:static;top:0;margin-top:"+j+"px",r.insertBefore(a,r.firstChild),q=c.createElement("div"),a.appendChild(q),q.innerHTML="<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>",l=q.getElementsByTagName("td"),p=l[0].offsetHeight===0,l[0].style.display="",l[1].style.display="none",b.reliableHiddenOffsets=p&&l[0].offsetHeight===0,q.innerHTML="",q.style.width=q.style.paddingLeft="1px",f.boxModel=b.boxModel=q.offsetWidth===2,typeof q.style.zoom!="undefined"&&(q.style.display="inline",q.style.zoom=1,b.inlineBlockNeedsLayout=q.offsetWidth===2,q.style.display="",q.innerHTML="<div style='width:4px;'></div>",b.shrinkWrapBlocks=q.offsetWidth!==2),q.style.cssText=k+m,q.innerHTML=o,d=q.firstChild,e=d.firstChild,h=d.nextSibling.firstChild.firstChild,i={doesNotAddBorder:e.offsetTop!==5,doesAddBorderForTableAndCells:h.offsetTop===5},e.style.position="fixed",e.style.top="20px",i.fixedPosition=e.offsetTop===20||e.offsetTop===15,e.style.position=e.style.top="",d.style.overflow="hidden",d.style.position="relative",i.subtractsBorderForOverflowNotVisible=e.offsetTop===-5,i.doesNotIncludeMarginInBodyOffset=r.offsetTop!==j,r.removeChild(a),q=a=null,f.extend(b,i))});return b}();var j=/^(?:\{.*\}|\[.*\])$/,k=/([A-Z])/g;f.extend({cache:{},uuid:0,expando:"jQuery"+(f.fn.jquery+Math.random()).replace(/\D/g,""),noData:{embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:!0},hasData:function(a){a=a.nodeType?f.cache[a[f.expando]]:a[f.expando];return!!a&&!m(a)},data:function(a,c,d,e){if(!!f.acceptData(a)){var g,h,i,j=f.expando,k=typeof c=="string",l=a.nodeType,m=l?f.cache:a,n=l?a[j]:a[j]&&j,o=c==="events";if((!n||!m[n]||!o&&!e&&!m[n].data)&&k&&d===b)return;n||(l?a[j]=n=++f.uuid:n=j),m[n]||(m[n]={},l||(m[n].toJSON=f.noop));if(typeof c=="object"||typeof c=="function")e?m[n]=f.extend(m[n],c):m[n].data=f.extend(m[n].data,c);g=h=m[n],e||(h.data||(h.data={}),h=h.data),d!==b&&(h[f.camelCase(c)]=d);if(o&&!h[c])return g.events;k?(i=h[c],i==null&&(i=h[f.camelCase(c)])):i=h;return i}},removeData:function(a,b,c){if(!!f.acceptData(a)){var d,e,g,h=f.expando,i=a.nodeType,j=i?f.cache:a,k=i?a[h]:h;if(!j[k])return;if(b){d=c?j[k]:j[k].data;if(d){f.isArray(b)||(b in d?b=[b]:(b=f.camelCase(b),b in d?b=[b]:b=b.split(" ")));for(e=0,g=b.length;e<g;e++)delete d[b[e]];if(!(c?m:f.isEmptyObject)(d))return}}if(!c){delete j[k].data;if(!m(j[k]))return}f.support.deleteExpando||!j.setInterval?delete j[k]:j[k]=null,i&&(f.support.deleteExpando?delete a[h]:a.removeAttribute?a.removeAttribute(h):a[h]=null)}},_data:function(a,b,c){return f.data(a,b,c,!0)},acceptData:function(a){if(a.nodeName){var b=f.noData[a.nodeName.toLowerCase()];if(b)return b!==!0&&a.getAttribute("classid")===b}return!0}}),f.fn.extend({data:function(a,c){var d,e,g,h=null;if(typeof a=="undefined"){if(this.length){h=f.data(this[0]);if(this[0].nodeType===1&&!f._data(this[0],"parsedAttrs")){e=this[0].attributes;for(var i=0,j=e.length;i<j;i++)g=e[i].name,g.indexOf("data-")===0&&(g=f.camelCase(g.substring(5)),l(this[0],g,h[g]));f._data(this[0],"parsedAttrs",!0)}}return h}if(typeof a=="object")return this.each(function(){f.data(this,a)});d=a.split("."),d[1]=d[1]?"."+d[1]:"";if(c===b){h=this.triggerHandler("getData"+d[1]+"!",[d[0]]),h===b&&this.length&&(h=f.data(this[0],a),h=l(this[0],a,h));return h===b&&d[1]?this.data(d[0]):h}return this.each(function(){var b=f(this),e=[d[0],c];b.triggerHandler("setData"+d[1]+"!",e),f.data(this,a,c),b.triggerHandler("changeData"+d[1]+"!",e)})},removeData:function(a){return this.each(function(){f.removeData(this,a)})}}),f.extend({_mark:function(a,b){a&&(b=(b||"fx")+"mark",f._data(a,b,(f._data(a,b)||0)+1))},_unmark:function(a,b,c){a!==!0&&(c=b,b=a,a=!1);if(b){c=c||"fx";var d=c+"mark",e=a?0:(f._data(b,d)||1)-1;e?f._data(b,d,e):(f.removeData(b,d,!0),n(b,c,"mark"))}},queue:function(a,b,c){var d;if(a){b=(b||"fx")+"queue",d=f._data(a,b),c&&(!d||f.isArray(c)?d=f._data(a,b,f.makeArray(c)):d.push(c));return d||[]}},dequeue:function(a,b){b=b||"fx";var c=f.queue(a,b),d=c.shift(),e={};d==="inprogress"&&(d=c.shift()),d&&(b==="fx"&&c.unshift("inprogress"),f._data(a,b+".run",e),d.call(a,function(){f.dequeue(a,b)},e)),c.length||(f.removeData(a,b+"queue "+b+".run",!0),n(a,b,"queue"))}}),f.fn.extend({queue:function(a,c){typeof a!="string"&&(c=a,a="fx");if(c===b)return f.queue(this[0],a);return this.each(function(){var b=f.queue(this,a,c);a==="fx"&&b[0]!=="inprogress"&&f.dequeue(this,a)})},dequeue:function(a){return this.each(function(){f.dequeue(this,a)})},delay:function(a,b){a=f.fx?f.fx.speeds[a]||a:a,b=b||"fx";return this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,c){function m(){--h||d.resolveWith(e,[e])}typeof a!="string"&&(c=a,a=b),a=a||"fx";var d=f.Deferred(),e=this,g=e.length,h=1,i=a+"defer",j=a+"queue",k=a+"mark",l;while(g--)if(l=f.data(e[g],i,b,!0)||(f.data(e[g],j,b,!0)||f.data(e[g],k,b,!0))&&f.data(e[g],i,f.Callbacks("once memory"),!0))h++,l.add(m);m();return d.promise()}});var o=/[\n\t\r]/g,p=/\s+/,q=/\r/g,r=/^(?:button|input)$/i,s=/^(?:button|input|object|select|textarea)$/i,t=/^a(?:rea)?$/i,u=/^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,v=f.support.getSetAttribute,w,x,y;f.fn.extend({attr:function(a,b){return f.access(this,a,b,!0,f.attr)},removeAttr:function(a){return this.each(function(){f.removeAttr(this,a)})},prop:function(a,b){return f.access(this,a,b,!0,f.prop)},removeProp:function(a){a=f.propFix[a]||a;return this.each(function(){try{this[a]=b,delete this[a]}catch(c){}})},addClass:function(a){var b,c,d,e,g,h,i;if(f.isFunction(a))return this.each(function(b){f(this).addClass(a.call(this,b,this.className))});if(a&&typeof a=="string"){b=a.split(p);for(c=0,d=this.length;c<d;c++){e=this[c];if(e.nodeType===1)if(!e.className&&b.length===1)e.className=a;else{g=" "+e.className+" ";for(h=0,i=b.length;h<i;h++)~g.indexOf(" "+b[h]+" ")||(g+=b[h]+" ");e.className=f.trim(g)}}}return this},removeClass:function(a){var c,d,e,g,h,i,j;if(f.isFunction(a))return this.each(function(b){f(this).removeClass(a.call(this,b,this.className))});if(a&&typeof a=="string"||a===b){c=(a||"").split(p);for(d=0,e=this.length;d<e;d++){g=this[d];if(g.nodeType===1&&g.className)if(a){h=(" "+g.className+" ").replace(o," ");for(i=0,j=c.length;i<j;i++)h=h.replace(" "+c[i]+" "," ");g.className=f.trim(h)}else g.className=""}}return this},toggleClass:function(a,b){var c=typeof a,d=typeof b=="boolean";if(f.isFunction(a))return this.each(function(c){f(this).toggleClass(a.call(this,c,this.className,b),b)});return this.each(function(){if(c==="string"){var e,g=0,h=f(this),i=b,j=a.split(p);while(e=j[g++])i=d?i:!h.hasClass(e),h[i?"addClass":"removeClass"](e)}else if(c==="undefined"||c==="boolean")this.className&&f._data(this,"__className__",this.className),this.className=this.className||a===!1?"":f._data(this,"__className__")||""})},hasClass:function(a){var b=" "+a+" ",c=0,d=this.length;for(;c<d;c++)if(this[c].nodeType===1&&(" "+this[c].className+" ").replace(o," ").indexOf(b)>-1)return!0;return!1},val:function(a){var c,d,e,g=this[0];{if(!!arguments.length){e=f.isFunction(a);return this.each(function(d){var g=f(this),h;if(this.nodeType===1){e?h=a.call(this,d,g.val()):h=a,h==null?h="":typeof h=="number"?h+="":f.isArray(h)&&(h=f.map(h,function(a){return a==null?"":a+""})),c=f.valHooks[this.nodeName.toLowerCase()]||f.valHooks[this.type];if(!c||!("set"in c)||c.set(this,h,"value")===b)this.value=h}})}if(g){c=f.valHooks[g.nodeName.toLowerCase()]||f.valHooks[g.type];if(c&&"get"in c&&(d=c.get(g,"value"))!==b)return d;d=g.value;return typeof d=="string"?d.replace(q,""):d==null?"":d}}}}),f.extend({valHooks:{option:{get:function(a){var b=a.attributes.value;return!b||b.specified?a.value:a.text}},select:{get:function(a){var b,c,d,e,g=a.selectedIndex,h=[],i=a.options,j=a.type==="select-one";if(g<0)return null;c=j?g:0,d=j?g+1:i.length;for(;c<d;c++){e=i[c];if(e.selected&&(f.support.optDisabled?!e.disabled:e.getAttribute("disabled")===null)&&(!e.parentNode.disabled||!f.nodeName(e.parentNode,"optgroup"))){b=f(e).val();if(j)return b;h.push(b)}}if(j&&!h.length&&i.length)return f(i[g]).val();return h},set:function(a,b){var c=f.makeArray(b);f(a).find("option").each(function(){this.selected=f.inArray(f(this).val(),c)>=0}),c.length||(a.selectedIndex=-1);return c}}},attrFn:{val:!0,css:!0,html:!0,text:!0,data:!0,width:!0,height:!0,offset:!0},attr:function(a,c,d,e){var g,h,i,j=a.nodeType;if(!!a&&j!==3&&j!==8&&j!==2){if(e&&c in f.attrFn)return f(a)[c](d);if(typeof a.getAttribute=="undefined")return f.prop(a,c,d);i=j!==1||!f.isXMLDoc(a),i&&(c=c.toLowerCase(),h=f.attrHooks[c]||(u.test(c)?x:w));if(d!==b){if(d===null){f.removeAttr(a,c);return}if(h&&"set"in h&&i&&(g=h.set(a,d,c))!==b)return g;a.setAttribute(c,""+d);return d}if(h&&"get"in h&&i&&(g=h.get(a,c))!==null)return g;g=a.getAttribute(c);return g===null?b:g}},removeAttr:function(a,b){var c,d,e,g,h=0;if(b&&a.nodeType===1){d=b.toLowerCase().split(p),g=d.length;for(;h<g;h++)e=d[h],e&&(c=f.propFix[e]||e,f.attr(a,e,""),a.removeAttribute(v?e:c),u.test(e)&&c in a&&(a[c]=!1))}},attrHooks:{type:{set:function(a,b){if(r.test(a.nodeName)&&a.parentNode)f.error("type property can't be changed");else if(!f.support.radioValue&&b==="radio"&&f.nodeName(a,"input")){var c=a.value;a.setAttribute("type",b),c&&(a.value=c);return b}}},value:{get:function(a,b){if(w&&f.nodeName(a,"button"))return w.get(a,b);return b in a?a.value:null},set:function(a,b,c){if(w&&f.nodeName(a,"button"))return w.set(a,b,c);a.value=b}}},propFix:{tabindex:"tabIndex",readonly:"readOnly","for":"htmlFor","class":"className",maxlength:"maxLength",cellspacing:"cellSpacing",cellpadding:"cellPadding",rowspan:"rowSpan",colspan:"colSpan",usemap:"useMap",frameborder:"frameBorder",contenteditable:"contentEditable"},prop:function(a,c,d){var e,g,h,i=a.nodeType;if(!!a&&i!==3&&i!==8&&i!==2){h=i!==1||!f.isXMLDoc(a),h&&(c=f.propFix[c]||c,g=f.propHooks[c]);return d!==b?g&&"set"in g&&(e=g.set(a,d,c))!==b?e:a[c]=d:g&&"get"in g&&(e=g.get(a,c))!==null?e:a[c]}},propHooks:{tabIndex:{get:function(a){var c=a.getAttributeNode("tabindex");return c&&c.specified?parseInt(c.value,10):s.test(a.nodeName)||t.test(a.nodeName)&&a.href?0:b}}}}),f.attrHooks.tabindex=f.propHooks.tabIndex,x={get:function(a,c){var d,e=f.prop(a,c);return e===!0||typeof e!="boolean"&&(d=a.getAttributeNode(c))&&d.nodeValue!==!1?c.toLowerCase():b},set:function(a,b,c){var d;b===!1?f.removeAttr(a,c):(d=f.propFix[c]||c,d in a&&(a[d]=!0),a.setAttribute(c,c.toLowerCase()));return c}},v||(y={name:!0,id:!0},w=f.valHooks.button={get:function(a,c){var d;d=a.getAttributeNode(c);return d&&(y[c]?d.nodeValue!=="":d.specified)?d.nodeValue:b},set:function(a,b,d){var e=a.getAttributeNode(d);e||(e=c.createAttribute(d),a.setAttributeNode(e));return e.nodeValue=b+""}},f.attrHooks.tabindex.set=w.set,f.each(["width","height"],function(a,b){f.attrHooks[b]=f.extend(f.attrHooks[b],{set:function(a,c){if(c===""){a.setAttribute(b,"auto");return c}}})}),f.attrHooks.contenteditable={get:w.get,set:function(a,b,c){b===""&&(b="false"),w.set(a,b,c)}}),f.support.hrefNormalized||f.each(["href","src","width","height"],function(a,c){f.attrHooks[c]=f.extend(f.attrHooks[c],{get:function(a){var d=a.getAttribute(c,2);return d===null?b:d}})}),f.support.style||(f.attrHooks.style={get:function(a){return a.style.cssText.toLowerCase()||b},set:function(a,b){return a.style.cssText=""+b}}),f.support.optSelected||(f.propHooks.selected=f.extend(f.propHooks.selected,{get:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex);return null}})),f.support.enctype||(f.propFix.enctype="encoding"),f.support.checkOn||f.each(["radio","checkbox"],function(){f.valHooks[this]={get:function(a){return a.getAttribute("value")===null?"on":a.value}}}),f.each(["radio","checkbox"],function(){f.valHooks[this]=f.extend(f.valHooks[this],{set:function(a,b){if(f.isArray(b))return a.checked=f.inArray(f(a).val(),b)>=0}})});var z=/^(?:textarea|input|select)$/i,A=/^([^\.]*)?(?:\.(.+))?$/,B=/\bhover(\.\S+)?\b/,C=/^key/,D=/^(?:mouse|contextmenu)|click/,E=/^(?:focusinfocus|focusoutblur)$/,F=/^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,G=function(a){var b=F.exec(a);b&&(b[1]=(b[1]||"").toLowerCase(),b[3]=b[3]&&new RegExp("(?:^|\\s)"+b[3]+"(?:\\s|$)"));return b},H=function(a,b){var c=a.attributes||{};return(!b[1]||a.nodeName.toLowerCase()===b[1])&&(!b[2]||(c.id||{}).value===b[2])&&(!b[3]||b[3].test((c["class"]||{}).value))},I=function(a){return f.event.special.hover?a:a.replace(B,"mouseenter$1 mouseleave$1")};
f.event={add:function(a,c,d,e,g){var h,i,j,k,l,m,n,o,p,q,r,s;if(!(a.nodeType===3||a.nodeType===8||!c||!d||!(h=f._data(a)))){d.handler&&(p=d,d=p.handler),d.guid||(d.guid=f.guid++),j=h.events,j||(h.events=j={}),i=h.handle,i||(h.handle=i=function(a){return typeof f!="undefined"&&(!a||f.event.triggered!==a.type)?f.event.dispatch.apply(i.elem,arguments):b},i.elem=a),c=f.trim(I(c)).split(" ");for(k=0;k<c.length;k++){l=A.exec(c[k])||[],m=l[1],n=(l[2]||"").split(".").sort(),s=f.event.special[m]||{},m=(g?s.delegateType:s.bindType)||m,s=f.event.special[m]||{},o=f.extend({type:m,origType:l[1],data:e,handler:d,guid:d.guid,selector:g,quick:G(g),namespace:n.join(".")},p),r=j[m];if(!r){r=j[m]=[],r.delegateCount=0;if(!s.setup||s.setup.call(a,e,n,i)===!1)a.addEventListener?a.addEventListener(m,i,!1):a.attachEvent&&a.attachEvent("on"+m,i)}s.add&&(s.add.call(a,o),o.handler.guid||(o.handler.guid=d.guid)),g?r.splice(r.delegateCount++,0,o):r.push(o),f.event.global[m]=!0}a=null}},global:{},remove:function(a,b,c,d,e){var g=f.hasData(a)&&f._data(a),h,i,j,k,l,m,n,o,p,q,r,s;if(!!g&&!!(o=g.events)){b=f.trim(I(b||"")).split(" ");for(h=0;h<b.length;h++){i=A.exec(b[h])||[],j=k=i[1],l=i[2];if(!j){for(j in o)f.event.remove(a,j+b[h],c,d,!0);continue}p=f.event.special[j]||{},j=(d?p.delegateType:p.bindType)||j,r=o[j]||[],m=r.length,l=l?new RegExp("(^|\\.)"+l.split(".").sort().join("\\.(?:.*\\.)?")+"(\\.|$)"):null;for(n=0;n<r.length;n++)s=r[n],(e||k===s.origType)&&(!c||c.guid===s.guid)&&(!l||l.test(s.namespace))&&(!d||d===s.selector||d==="**"&&s.selector)&&(r.splice(n--,1),s.selector&&r.delegateCount--,p.remove&&p.remove.call(a,s));r.length===0&&m!==r.length&&((!p.teardown||p.teardown.call(a,l)===!1)&&f.removeEvent(a,j,g.handle),delete o[j])}f.isEmptyObject(o)&&(q=g.handle,q&&(q.elem=null),f.removeData(a,["events","handle"],!0))}},customEvent:{getData:!0,setData:!0,changeData:!0},trigger:function(c,d,e,g){if(!e||e.nodeType!==3&&e.nodeType!==8){var h=c.type||c,i=[],j,k,l,m,n,o,p,q,r,s;if(E.test(h+f.event.triggered))return;h.indexOf("!")>=0&&(h=h.slice(0,-1),k=!0),h.indexOf(".")>=0&&(i=h.split("."),h=i.shift(),i.sort());if((!e||f.event.customEvent[h])&&!f.event.global[h])return;c=typeof c=="object"?c[f.expando]?c:new f.Event(h,c):new f.Event(h),c.type=h,c.isTrigger=!0,c.exclusive=k,c.namespace=i.join("."),c.namespace_re=c.namespace?new RegExp("(^|\\.)"+i.join("\\.(?:.*\\.)?")+"(\\.|$)"):null,o=h.indexOf(":")<0?"on"+h:"";if(!e){j=f.cache;for(l in j)j[l].events&&j[l].events[h]&&f.event.trigger(c,d,j[l].handle.elem,!0);return}c.result=b,c.target||(c.target=e),d=d!=null?f.makeArray(d):[],d.unshift(c),p=f.event.special[h]||{};if(p.trigger&&p.trigger.apply(e,d)===!1)return;r=[[e,p.bindType||h]];if(!g&&!p.noBubble&&!f.isWindow(e)){s=p.delegateType||h,m=E.test(s+h)?e:e.parentNode,n=null;for(;m;m=m.parentNode)r.push([m,s]),n=m;n&&n===e.ownerDocument&&r.push([n.defaultView||n.parentWindow||a,s])}for(l=0;l<r.length&&!c.isPropagationStopped();l++)m=r[l][0],c.type=r[l][1],q=(f._data(m,"events")||{})[c.type]&&f._data(m,"handle"),q&&q.apply(m,d),q=o&&m[o],q&&f.acceptData(m)&&q.apply(m,d)===!1&&c.preventDefault();c.type=h,!g&&!c.isDefaultPrevented()&&(!p._default||p._default.apply(e.ownerDocument,d)===!1)&&(h!=="click"||!f.nodeName(e,"a"))&&f.acceptData(e)&&o&&e[h]&&(h!=="focus"&&h!=="blur"||c.target.offsetWidth!==0)&&!f.isWindow(e)&&(n=e[o],n&&(e[o]=null),f.event.triggered=h,e[h](),f.event.triggered=b,n&&(e[o]=n));return c.result}},dispatch:function(c){c=f.event.fix(c||a.event);var d=(f._data(this,"events")||{})[c.type]||[],e=d.delegateCount,g=[].slice.call(arguments,0),h=!c.exclusive&&!c.namespace,i=[],j,k,l,m,n,o,p,q,r,s,t;g[0]=c,c.delegateTarget=this;if(e&&!c.target.disabled&&(!c.button||c.type!=="click")){m=f(this),m.context=this.ownerDocument||this;for(l=c.target;l!=this;l=l.parentNode||this){o={},q=[],m[0]=l;for(j=0;j<e;j++)r=d[j],s=r.selector,o[s]===b&&(o[s]=r.quick?H(l,r.quick):m.is(s)),o[s]&&q.push(r);q.length&&i.push({elem:l,matches:q})}}d.length>e&&i.push({elem:this,matches:d.slice(e)});for(j=0;j<i.length&&!c.isPropagationStopped();j++){p=i[j],c.currentTarget=p.elem;for(k=0;k<p.matches.length&&!c.isImmediatePropagationStopped();k++){r=p.matches[k];if(h||!c.namespace&&!r.namespace||c.namespace_re&&c.namespace_re.test(r.namespace))c.data=r.data,c.handleObj=r,n=((f.event.special[r.origType]||{}).handle||r.handler).apply(p.elem,g),n!==b&&(c.result=n,n===!1&&(c.preventDefault(),c.stopPropagation()))}}return c.result},props:"attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){a.which==null&&(a.which=b.charCode!=null?b.charCode:b.keyCode);return a}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,d){var e,f,g,h=d.button,i=d.fromElement;a.pageX==null&&d.clientX!=null&&(e=a.target.ownerDocument||c,f=e.documentElement,g=e.body,a.pageX=d.clientX+(f&&f.scrollLeft||g&&g.scrollLeft||0)-(f&&f.clientLeft||g&&g.clientLeft||0),a.pageY=d.clientY+(f&&f.scrollTop||g&&g.scrollTop||0)-(f&&f.clientTop||g&&g.clientTop||0)),!a.relatedTarget&&i&&(a.relatedTarget=i===a.target?d.toElement:i),!a.which&&h!==b&&(a.which=h&1?1:h&2?3:h&4?2:0);return a}},fix:function(a){if(a[f.expando])return a;var d,e,g=a,h=f.event.fixHooks[a.type]||{},i=h.props?this.props.concat(h.props):this.props;a=f.Event(g);for(d=i.length;d;)e=i[--d],a[e]=g[e];a.target||(a.target=g.srcElement||c),a.target.nodeType===3&&(a.target=a.target.parentNode),a.metaKey===b&&(a.metaKey=a.ctrlKey);return h.filter?h.filter(a,g):a},special:{ready:{setup:f.bindReady},load:{noBubble:!0},focus:{delegateType:"focusin"},blur:{delegateType:"focusout"},beforeunload:{setup:function(a,b,c){f.isWindow(this)&&(this.onbeforeunload=c)},teardown:function(a,b){this.onbeforeunload===b&&(this.onbeforeunload=null)}}},simulate:function(a,b,c,d){var e=f.extend(new f.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?f.event.trigger(e,null,b):f.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},f.event.handle=f.event.dispatch,f.removeEvent=c.removeEventListener?function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)}:function(a,b,c){a.detachEvent&&a.detachEvent("on"+b,c)},f.Event=function(a,b){if(!(this instanceof f.Event))return new f.Event(a,b);a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||a.returnValue===!1||a.getPreventDefault&&a.getPreventDefault()?K:J):this.type=a,b&&f.extend(this,b),this.timeStamp=a&&a.timeStamp||f.now(),this[f.expando]=!0},f.Event.prototype={preventDefault:function(){this.isDefaultPrevented=K;var a=this.originalEvent;!a||(a.preventDefault?a.preventDefault():a.returnValue=!1)},stopPropagation:function(){this.isPropagationStopped=K;var a=this.originalEvent;!a||(a.stopPropagation&&a.stopPropagation(),a.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=K,this.stopPropagation()},isDefaultPrevented:J,isPropagationStopped:J,isImmediatePropagationStopped:J},f.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(a,b){f.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c=this,d=a.relatedTarget,e=a.handleObj,g=e.selector,h;if(!d||d!==c&&!f.contains(c,d))a.type=e.origType,h=e.handler.apply(this,arguments),a.type=b;return h}}}),f.support.submitBubbles||(f.event.special.submit={setup:function(){if(f.nodeName(this,"form"))return!1;f.event.add(this,"click._submit keypress._submit",function(a){var c=a.target,d=f.nodeName(c,"input")||f.nodeName(c,"button")?c.form:b;d&&!d._submit_attached&&(f.event.add(d,"submit._submit",function(a){this.parentNode&&!a.isTrigger&&f.event.simulate("submit",this.parentNode,a,!0)}),d._submit_attached=!0)})},teardown:function(){if(f.nodeName(this,"form"))return!1;f.event.remove(this,"._submit")}}),f.support.changeBubbles||(f.event.special.change={setup:function(){if(z.test(this.nodeName)){if(this.type==="checkbox"||this.type==="radio")f.event.add(this,"propertychange._change",function(a){a.originalEvent.propertyName==="checked"&&(this._just_changed=!0)}),f.event.add(this,"click._change",function(a){this._just_changed&&!a.isTrigger&&(this._just_changed=!1,f.event.simulate("change",this,a,!0))});return!1}f.event.add(this,"beforeactivate._change",function(a){var b=a.target;z.test(b.nodeName)&&!b._change_attached&&(f.event.add(b,"change._change",function(a){this.parentNode&&!a.isSimulated&&!a.isTrigger&&f.event.simulate("change",this.parentNode,a,!0)}),b._change_attached=!0)})},handle:function(a){var b=a.target;if(this!==b||a.isSimulated||a.isTrigger||b.type!=="radio"&&b.type!=="checkbox")return a.handleObj.handler.apply(this,arguments)},teardown:function(){f.event.remove(this,"._change");return z.test(this.nodeName)}}),f.support.focusinBubbles||f.each({focus:"focusin",blur:"focusout"},function(a,b){var d=0,e=function(a){f.event.simulate(b,a.target,f.event.fix(a),!0)};f.event.special[b]={setup:function(){d++===0&&c.addEventListener(a,e,!0)},teardown:function(){--d===0&&c.removeEventListener(a,e,!0)}}}),f.fn.extend({on:function(a,c,d,e,g){var h,i;if(typeof a=="object"){typeof c!="string"&&(d=c,c=b);for(i in a)this.on(i,c,d,a[i],g);return this}d==null&&e==null?(e=c,d=c=b):e==null&&(typeof c=="string"?(e=d,d=b):(e=d,d=c,c=b));if(e===!1)e=J;else if(!e)return this;g===1&&(h=e,e=function(a){f().off(a);return h.apply(this,arguments)},e.guid=h.guid||(h.guid=f.guid++));return this.each(function(){f.event.add(this,a,e,d,c)})},one:function(a,b,c,d){return this.on.call(this,a,b,c,d,1)},off:function(a,c,d){if(a&&a.preventDefault&&a.handleObj){var e=a.handleObj;f(a.delegateTarget).off(e.namespace?e.type+"."+e.namespace:e.type,e.selector,e.handler);return this}if(typeof a=="object"){for(var g in a)this.off(g,c,a[g]);return this}if(c===!1||typeof c=="function")d=c,c=b;d===!1&&(d=J);return this.each(function(){f.event.remove(this,a,d,c)})},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},live:function(a,b,c){f(this.context).on(a,this.selector,b,c);return this},die:function(a,b){f(this.context).off(a,this.selector||"**",b);return this},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return arguments.length==1?this.off(a,"**"):this.off(b,a,c)},trigger:function(a,b){return this.each(function(){f.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0])return f.event.trigger(a,b,this[0],!0)},toggle:function(a){var b=arguments,c=a.guid||f.guid++,d=0,e=function(c){var e=(f._data(this,"lastToggle"+a.guid)||0)%d;f._data(this,"lastToggle"+a.guid,e+1),c.preventDefault();return b[e].apply(this,arguments)||!1};e.guid=c;while(d<b.length)b[d++].guid=c;return this.click(e)},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}}),f.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){f.fn[b]=function(a,c){c==null&&(c=a,a=null);return arguments.length>0?this.on(b,null,a,c):this.trigger(b)},f.attrFn&&(f.attrFn[b]=!0),C.test(b)&&(f.event.fixHooks[b]=f.event.keyHooks),D.test(b)&&(f.event.fixHooks[b]=f.event.mouseHooks)}),function(){function x(a,b,c,e,f,g){for(var h=0,i=e.length;h<i;h++){var j=e[h];if(j){var k=!1;j=j[a];while(j){if(j[d]===c){k=e[j.sizset];break}if(j.nodeType===1){g||(j[d]=c,j.sizset=h);if(typeof b!="string"){if(j===b){k=!0;break}}else if(m.filter(b,[j]).length>0){k=j;break}}j=j[a]}e[h]=k}}}function w(a,b,c,e,f,g){for(var h=0,i=e.length;h<i;h++){var j=e[h];if(j){var k=!1;j=j[a];while(j){if(j[d]===c){k=e[j.sizset];break}j.nodeType===1&&!g&&(j[d]=c,j.sizset=h);if(j.nodeName.toLowerCase()===b){k=j;break}j=j[a]}e[h]=k}}}var a=/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,d="sizcache"+(Math.random()+"").replace(".",""),e=0,g=Object.prototype.toString,h=!1,i=!0,j=/\\/g,k=/\r\n/g,l=/\W/;[0,0].sort(function(){i=!1;return 0});var m=function(b,d,e,f){e=e||[],d=d||c;var h=d;if(d.nodeType!==1&&d.nodeType!==9)return[];if(!b||typeof b!="string")return e;var i,j,k,l,n,q,r,t,u=!0,v=m.isXML(d),w=[],x=b;do{a.exec(""),i=a.exec(x);if(i){x=i[3],w.push(i[1]);if(i[2]){l=i[3];break}}}while(i);if(w.length>1&&p.exec(b))if(w.length===2&&o.relative[w[0]])j=y(w[0]+w[1],d,f);else{j=o.relative[w[0]]?[d]:m(w.shift(),d);while(w.length)b=w.shift(),o.relative[b]&&(b+=w.shift()),j=y(b,j,f)}else{!f&&w.length>1&&d.nodeType===9&&!v&&o.match.ID.test(w[0])&&!o.match.ID.test(w[w.length-1])&&(n=m.find(w.shift(),d,v),d=n.expr?m.filter(n.expr,n.set)[0]:n.set[0]);if(d){n=f?{expr:w.pop(),set:s(f)}:m.find(w.pop(),w.length===1&&(w[0]==="~"||w[0]==="+")&&d.parentNode?d.parentNode:d,v),j=n.expr?m.filter(n.expr,n.set):n.set,w.length>0?k=s(j):u=!1;while(w.length)q=w.pop(),r=q,o.relative[q]?r=w.pop():q="",r==null&&(r=d),o.relative[q](k,r,v)}else k=w=[]}k||(k=j),k||m.error(q||b);if(g.call(k)==="[object Array]")if(!u)e.push.apply(e,k);else if(d&&d.nodeType===1)for(t=0;k[t]!=null;t++)k[t]&&(k[t]===!0||k[t].nodeType===1&&m.contains(d,k[t]))&&e.push(j[t]);else for(t=0;k[t]!=null;t++)k[t]&&k[t].nodeType===1&&e.push(j[t]);else s(k,e);l&&(m(l,h,e,f),m.uniqueSort(e));return e};m.uniqueSort=function(a){if(u){h=i,a.sort(u);if(h)for(var b=1;b<a.length;b++)a[b]===a[b-1]&&a.splice(b--,1)}return a},m.matches=function(a,b){return m(a,null,null,b)},m.matchesSelector=function(a,b){return m(b,null,null,[a]).length>0},m.find=function(a,b,c){var d,e,f,g,h,i;if(!a)return[];for(e=0,f=o.order.length;e<f;e++){h=o.order[e];if(g=o.leftMatch[h].exec(a)){i=g[1],g.splice(1,1);if(i.substr(i.length-1)!=="\\"){g[1]=(g[1]||"").replace(j,""),d=o.find[h](g,b,c);if(d!=null){a=a.replace(o.match[h],"");break}}}}d||(d=typeof b.getElementsByTagName!="undefined"?b.getElementsByTagName("*"):[]);return{set:d,expr:a}},m.filter=function(a,c,d,e){var f,g,h,i,j,k,l,n,p,q=a,r=[],s=c,t=c&&c[0]&&m.isXML(c[0]);while(a&&c.length){for(h in o.filter)if((f=o.leftMatch[h].exec(a))!=null&&f[2]){k=o.filter[h],l=f[1],g=!1,f.splice(1,1);if(l.substr(l.length-1)==="\\")continue;s===r&&(r=[]);if(o.preFilter[h]){f=o.preFilter[h](f,s,d,r,e,t);if(!f)g=i=!0;else if(f===!0)continue}if(f)for(n=0;(j=s[n])!=null;n++)j&&(i=k(j,f,n,s),p=e^i,d&&i!=null?p?g=!0:s[n]=!1:p&&(r.push(j),g=!0));if(i!==b){d||(s=r),a=a.replace(o.match[h],"");if(!g)return[];break}}if(a===q)if(g==null)m.error(a);else break;q=a}return s},m.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)};var n=m.getText=function(a){var b,c,d=a.nodeType,e="";if(d){if(d===1||d===9){if(typeof a.textContent=="string")return a.textContent;if(typeof a.innerText=="string")return a.innerText.replace(k,"");for(a=a.firstChild;a;a=a.nextSibling)e+=n(a)}else if(d===3||d===4)return a.nodeValue}else for(b=0;c=a[b];b++)c.nodeType!==8&&(e+=n(c));return e},o=m.selectors={order:["ID","NAME","TAG"],match:{ID:/#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,CLASS:/\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,NAME:/\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,ATTR:/\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,TAG:/^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,PSEUDO:/:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/},leftMatch:{},attrMap:{"class":"className","for":"htmlFor"},attrHandle:{href:function(a){return a.getAttribute("href")},type:function(a){return a.getAttribute("type")}},relative:{"+":function(a,b){var c=typeof b=="string",d=c&&!l.test(b),e=c&&!d;d&&(b=b.toLowerCase());for(var f=0,g=a.length,h;f<g;f++)if(h=a[f]){while((h=h.previousSibling)&&h.nodeType!==1);a[f]=e||h&&h.nodeName.toLowerCase()===b?h||!1:h===b}e&&m.filter(b,a,!0)},">":function(a,b){var c,d=typeof b=="string",e=0,f=a.length;if(d&&!l.test(b)){b=b.toLowerCase();for(;e<f;e++){c=a[e];if(c){var g=c.parentNode;a[e]=g.nodeName.toLowerCase()===b?g:!1}}}else{for(;e<f;e++)c=a[e],c&&(a[e]=d?c.parentNode:c.parentNode===b);d&&m.filter(b,a,!0)}},"":function(a,b,c){var d,f=e++,g=x;typeof b=="string"&&!l.test(b)&&(b=b.toLowerCase(),d=b,g=w),g("parentNode",b,f,a,d,c)},"~":function(a,b,c){var d,f=e++,g=x;typeof b=="string"&&!l.test(b)&&(b=b.toLowerCase(),d=b,g=w),g("previousSibling",b,f,a,d,c)}},find:{ID:function(a,b,c){if(typeof b.getElementById!="undefined"&&!c){var d=b.getElementById(a[1]);return d&&d.parentNode?[d]:[]}},NAME:function(a,b){if(typeof b.getElementsByName!="undefined"){var c=[],d=b.getElementsByName(a[1]);for(var e=0,f=d.length;e<f;e++)d[e].getAttribute("name")===a[1]&&c.push(d[e]);return c.length===0?null:c}},TAG:function(a,b){if(typeof b.getElementsByTagName!="undefined")return b.getElementsByTagName(a[1])}},preFilter:{CLASS:function(a,b,c,d,e,f){a=" "+a[1].replace(j,"")+" ";if(f)return a;for(var g=0,h;(h=b[g])!=null;g++)h&&(e^(h.className&&(" "+h.className+" ").replace(/[\t\n\r]/g," ").indexOf(a)>=0)?c||d.push(h):c&&(b[g]=!1));return!1},ID:function(a){return a[1].replace(j,"")},TAG:function(a,b){return a[1].replace(j,"").toLowerCase()},CHILD:function(a){if(a[1]==="nth"){a[2]||m.error(a[0]),a[2]=a[2].replace(/^\+|\s*/g,"");var b=/(-?)(\d*)(?:n([+\-]?\d*))?/.exec(a[2]==="even"&&"2n"||a[2]==="odd"&&"2n+1"||!/\D/.test(a[2])&&"0n+"+a[2]||a[2]);a[2]=b[1]+(b[2]||1)-0,a[3]=b[3]-0}else a[2]&&m.error(a[0]);a[0]=e++;return a},ATTR:function(a,b,c,d,e,f){var g=a[1]=a[1].replace(j,"");!f&&o.attrMap[g]&&(a[1]=o.attrMap[g]),a[4]=(a[4]||a[5]||"").replace(j,""),a[2]==="~="&&(a[4]=" "+a[4]+" ");return a},PSEUDO:function(b,c,d,e,f){if(b[1]==="not")if((a.exec(b[3])||"").length>1||/^\w/.test(b[3]))b[3]=m(b[3],null,null,c);else{var g=m.filter(b[3],c,d,!0^f);d||e.push.apply(e,g);return!1}else if(o.match.POS.test(b[0])||o.match.CHILD.test(b[0]))return!0;return b},POS:function(a){a.unshift(!0);return a}},filters:{enabled:function(a){return a.disabled===!1&&a.type!=="hidden"},disabled:function(a){return a.disabled===!0},checked:function(a){return a.checked===!0},selected:function(a){a.parentNode&&a.parentNode.selectedIndex;return a.selected===!0},parent:function(a){return!!a.firstChild},empty:function(a){return!a.firstChild},has:function(a,b,c){return!!m(c[3],a).length},header:function(a){return/h\d/i.test(a.nodeName)},text:function(a){var b=a.getAttribute("type"),c=a.type;return a.nodeName.toLowerCase()==="input"&&"text"===c&&(b===c||b===null)},radio:function(a){return a.nodeName.toLowerCase()==="input"&&"radio"===a.type},checkbox:function(a){return a.nodeName.toLowerCase()==="input"&&"checkbox"===a.type},file:function(a){return a.nodeName.toLowerCase()==="input"&&"file"===a.type},password:function(a){return a.nodeName.toLowerCase()==="input"&&"password"===a.type},submit:function(a){var b=a.nodeName.toLowerCase();return(b==="input"||b==="button")&&"submit"===a.type},image:function(a){return a.nodeName.toLowerCase()==="input"&&"image"===a.type},reset:function(a){var b=a.nodeName.toLowerCase();return(b==="input"||b==="button")&&"reset"===a.type},button:function(a){var b=a.nodeName.toLowerCase();return b==="input"&&"button"===a.type||b==="button"},input:function(a){return/input|select|textarea|button/i.test(a.nodeName)},focus:function(a){return a===a.ownerDocument.activeElement}},setFilters:{first:function(a,b){return b===0},last:function(a,b,c,d){return b===d.length-1},even:function(a,b){return b%2===0},odd:function(a,b){return b%2===1},lt:function(a,b,c){return b<c[3]-0},gt:function(a,b,c){return b>c[3]-0},nth:function(a,b,c){return c[3]-0===b},eq:function(a,b,c){return c[3]-0===b}},filter:{PSEUDO:function(a,b,c,d){var e=b[1],f=o.filters[e];if(f)return f(a,c,b,d);if(e==="contains")return(a.textContent||a.innerText||n([a])||"").indexOf(b[3])>=0;if(e==="not"){var g=b[3];for(var h=0,i=g.length;h<i;h++)if(g[h]===a)return!1;return!0}m.error(e)},CHILD:function(a,b){var c,e,f,g,h,i,j,k=b[1],l=a;switch(k){case"only":case"first":while(l=l.previousSibling)if(l.nodeType===1)return!1;if(k==="first")return!0;l=a;case"last":while(l=l.nextSibling)if(l.nodeType===1)return!1;return!0;case"nth":c=b[2],e=b[3];if(c===1&&e===0)return!0;f=b[0],g=a.parentNode;if(g&&(g[d]!==f||!a.nodeIndex)){i=0;for(l=g.firstChild;l;l=l.nextSibling)l.nodeType===1&&(l.nodeIndex=++i);g[d]=f}j=a.nodeIndex-e;return c===0?j===0:j%c===0&&j/c>=0}},ID:function(a,b){return a.nodeType===1&&a.getAttribute("id")===b},TAG:function(a,b){return b==="*"&&a.nodeType===1||!!a.nodeName&&a.nodeName.toLowerCase()===b},CLASS:function(a,b){return(" "+(a.className||a.getAttribute("class"))+" ").indexOf(b)>-1},ATTR:function(a,b){var c=b[1],d=m.attr?m.attr(a,c):o.attrHandle[c]?o.attrHandle[c](a):a[c]!=null?a[c]:a.getAttribute(c),e=d+"",f=b[2],g=b[4];return d==null?f==="!=":!f&&m.attr?d!=null:f==="="?e===g:f==="*="?e.indexOf(g)>=0:f==="~="?(" "+e+" ").indexOf(g)>=0:g?f==="!="?e!==g:f==="^="?e.indexOf(g)===0:f==="$="?e.substr(e.length-g.length)===g:f==="|="?e===g||e.substr(0,g.length+1)===g+"-":!1:e&&d!==!1},POS:function(a,b,c,d){var e=b[2],f=o.setFilters[e];if(f)return f(a,c,b,d)}}},p=o.match.POS,q=function(a,b){return"\\"+(b-0+1)};for(var r in o.match)o.match[r]=new RegExp(o.match[r].source+/(?![^\[]*\])(?![^\(]*\))/.source),o.leftMatch[r]=new RegExp(/(^(?:.|\r|\n)*?)/.source+o.match[r].source.replace(/\\(\d+)/g,q));var s=function(a,b){a=Array.prototype.slice.call(a,0);if(b){b.push.apply(b,a);return b}return a};try{Array.prototype.slice.call(c.documentElement.childNodes,0)[0].nodeType}catch(t){s=function(a,b){var c=0,d=b||[];if(g.call(a)==="[object Array]")Array.prototype.push.apply(d,a);else if(typeof a.length=="number")for(var e=a.length;c<e;c++)d.push(a[c]);else for(;a[c];c++)d.push(a[c]);return d}}var u,v;c.documentElement.compareDocumentPosition?u=function(a,b){if(a===b){h=!0;return 0}if(!a.compareDocumentPosition||!b.compareDocumentPosition)return a.compareDocumentPosition?-1:1;return a.compareDocumentPosition(b)&4?-1:1}:(u=function(a,b){if(a===b){h=!0;return 0}if(a.sourceIndex&&b.sourceIndex)return a.sourceIndex-b.sourceIndex;var c,d,e=[],f=[],g=a.parentNode,i=b.parentNode,j=g;if(g===i)return v(a,b);if(!g)return-1;if(!i)return 1;while(j)e.unshift(j),j=j.parentNode;j=i;while(j)f.unshift(j),j=j.parentNode;c=e.length,d=f.length;for(var k=0;k<c&&k<d;k++)if(e[k]!==f[k])return v(e[k],f[k]);return k===c?v(a,f[k],-1):v(e[k],b,1)},v=function(a,b,c){if(a===b)return c;var d=a.nextSibling;while(d){if(d===b)return-1;d=d.nextSibling}return 1}),function(){var a=c.createElement("div"),d="script"+(new Date).getTime(),e=c.documentElement;a.innerHTML="<a name='"+d+"'/>",e.insertBefore(a,e.firstChild),c.getElementById(d)&&(o.find.ID=function(a,c,d){if(typeof c.getElementById!="undefined"&&!d){var e=c.getElementById(a[1]);return e?e.id===a[1]||typeof e.getAttributeNode!="undefined"&&e.getAttributeNode("id").nodeValue===a[1]?[e]:b:[]}},o.filter.ID=function(a,b){var c=typeof a.getAttributeNode!="undefined"&&a.getAttributeNode("id");return a.nodeType===1&&c&&c.nodeValue===b}),e.removeChild(a),e=a=null}(),function(){var a=c.createElement("div");a.appendChild(c.createComment("")),a.getElementsByTagName("*").length>0&&(o.find.TAG=function(a,b){var c=b.getElementsByTagName(a[1]);if(a[1]==="*"){var d=[];for(var e=0;c[e];e++)c[e].nodeType===1&&d.push(c[e]);c=d}return c}),a.innerHTML="<a href='#'></a>",a.firstChild&&typeof a.firstChild.getAttribute!="undefined"&&a.firstChild.getAttribute("href")!=="#"&&(o.attrHandle.href=function(a){return a.getAttribute("href",2)}),a=null}(),c.querySelectorAll&&function(){var a=m,b=c.createElement("div"),d="__sizzle__";b.innerHTML="<p class='TEST'></p>";if(!b.querySelectorAll||b.querySelectorAll(".TEST").length!==0){m=function(b,e,f,g){e=e||c;if(!g&&!m.isXML(e)){var h=/^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec(b);if(h&&(e.nodeType===1||e.nodeType===9)){if(h[1])return s(e.getElementsByTagName(b),f);if(h[2]&&o.find.CLASS&&e.getElementsByClassName)return s(e.getElementsByClassName(h[2]),f)}if(e.nodeType===9){if(b==="body"&&e.body)return s([e.body],f);if(h&&h[3]){var i=e.getElementById(h[3]);if(!i||!i.parentNode)return s([],f);if(i.id===h[3])return s([i],f)}try{return s(e.querySelectorAll(b),f)}catch(j){}}else if(e.nodeType===1&&e.nodeName.toLowerCase()!=="object"){var k=e,l=e.getAttribute("id"),n=l||d,p=e.parentNode,q=/^\s*[+~]/.test(b);l?n=n.replace(/'/g,"\\$&"):e.setAttribute("id",n),q&&p&&(e=e.parentNode);try{if(!q||p)return s(e.querySelectorAll("[id='"+n+"'] "+b),f)}catch(r){}finally{l||k.removeAttribute("id")}}}return a(b,e,f,g)};for(var e in a)m[e]=a[e];b=null}}(),function(){var a=c.documentElement,b=a.matchesSelector||a.mozMatchesSelector||a.webkitMatchesSelector||a.msMatchesSelector;if(b){var d=!b.call(c.createElement("div"),"div"),e=!1;try{b.call(c.documentElement,"[test!='']:sizzle")}catch(f){e=!0}m.matchesSelector=function(a,c){c=c.replace(/\=\s*([^'"\]]*)\s*\]/g,"='$1']");if(!m.isXML(a))try{if(e||!o.match.PSEUDO.test(c)&&!/!=/.test(c)){var f=b.call(a,c);if(f||!d||a.document&&a.document.nodeType!==11)return f}}catch(g){}return m(c,null,null,[a]).length>0}}}(),function(){var a=c.createElement("div");a.innerHTML="<div class='test e'></div><div class='test'></div>";if(!!a.getElementsByClassName&&a.getElementsByClassName("e").length!==0){a.lastChild.className="e";if(a.getElementsByClassName("e").length===1)return;o.order.splice(1,0,"CLASS"),o.find.CLASS=function(a,b,c){if(typeof b.getElementsByClassName!="undefined"&&!c)return b.getElementsByClassName(a[1])},a=null}}(),c.documentElement.contains?m.contains=function(a,b){return a!==b&&(a.contains?a.contains(b):!0)}:c.documentElement.compareDocumentPosition?m.contains=function(a,b){return!!(a.compareDocumentPosition(b)&16)}:m.contains=function(){return!1},m.isXML=function(a){var b=(a?a.ownerDocument||a:0).documentElement;return b?b.nodeName!=="HTML":!1};var y=function(a,b,c){var d,e=[],f="",g=b.nodeType?[b]:b;while(d=o.match.PSEUDO.exec(a))f+=d[0],a=a.replace(o.match.PSEUDO,"");a=o.relative[a]?a+"*":a;for(var h=0,i=g.length;h<i;h++)m(a,g[h],e,c);return m.filter(f,e)};m.attr=f.attr,m.selectors.attrMap={},f.find=m,f.expr=m.selectors,f.expr[":"]=f.expr.filters,f.unique=m.uniqueSort,f.text=m.getText,f.isXMLDoc=m.isXML,f.contains=m.contains}();var L=/Until$/,M=/^(?:parents|prevUntil|prevAll)/,N=/,/,O=/^.[^:#\[\.,]*$/,P=Array.prototype.slice,Q=f.expr.match.POS,R={children:!0,contents:!0,next:!0,prev:!0};f.fn.extend({find:function(a){var b=this,c,d;if(typeof a!="string")return f(a).filter(function(){for(c=0,d=b.length;c<d;c++)if(f.contains(b[c],this))return!0});var e=this.pushStack("","find",a),g,h,i;for(c=0,d=this.length;c<d;c++){g=e.length,f.find(a,this[c],e);if(c>0)for(h=g;h<e.length;h++)for(i=0;i<g;i++)if(e[i]===e[h]){e.splice(h--,1);break}}return e},has:function(a){var b=f(a);return this.filter(function(){for(var a=0,c=b.length;a<c;a++)if(f.contains(this,b[a]))return!0})},not:function(a){return this.pushStack(T(this,a,!1),"not",a)},filter:function(a){return this.pushStack(T(this,a,!0),"filter",a)},is:function(a){return!!a&&(typeof a=="string"?Q.test(a)?f(a,this.context).index(this[0])>=0:f.filter(a,this).length>0:this.filter(a).length>0)},closest:function(a,b){var c=[],d,e,g=this[0];if(f.isArray(a)){var h=1;while(g&&g.ownerDocument&&g!==b){for(d=0;d<a.length;d++)f(g).is(a[d])&&c.push({selector:a[d],elem:g,level:h});g=g.parentNode,h++}return c}var i=Q.test(a)||typeof a!="string"?f(a,b||this.context):0;for(d=0,e=this.length;d<e;d++){g=this[d];while(g){if(i?i.index(g)>-1:f.find.matchesSelector(g,a)){c.push(g);break}g=g.parentNode;if(!g||!g.ownerDocument||g===b||g.nodeType===11)break}}c=c.length>1?f.unique(c):c;return this.pushStack(c,"closest",a)},index:function(a){if(!a)return this[0]&&this[0].parentNode?this.prevAll().length:-1;if(typeof a=="string")return f.inArray(this[0],f(a));return f.inArray(a.jquery?a[0]:a,this)},add:function(a,b){var c=typeof a=="string"?f(a,b):f.makeArray(a&&a.nodeType?[a]:a),d=f.merge(this.get(),c);return this.pushStack(S(c[0])||S(d[0])?d:f.unique(d))},andSelf:function(){return this.add(this.prevObject)}}),f.each({parent:function(a){var b=a.parentNode;return b&&b.nodeType!==11?b:null},parents:function(a){return f.dir(a,"parentNode")},parentsUntil:function(a,b,c){return f.dir(a,"parentNode",c)},next:function(a){return f.nth(a,2,"nextSibling")},prev:function(a){return f.nth(a,2,"previousSibling")},nextAll:function(a){return f.dir(a,"nextSibling")},prevAll:function(a){return f.dir(a,"previousSibling")},nextUntil:function(a,b,c){return f.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return f.dir(a,"previousSibling",c)},siblings:function(a){return f.sibling(a.parentNode.firstChild,a)},children:function(a){return f.sibling(a.firstChild)},contents:function(a){return f.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:f.makeArray(a.childNodes)}},function(a,b){f.fn[a]=function(c,d){var e=f.map(this,b,c);L.test(a)||(d=c),d&&typeof d=="string"&&(e=f.filter(d,e)),e=this.length>1&&!R[a]?f.unique(e):e,(this.length>1||N.test(d))&&M.test(a)&&(e=e.reverse());return this.pushStack(e,a,P.call(arguments).join(","))}}),f.extend({filter:function(a,b,c){c&&(a=":not("+a+")");return b.length===1?f.find.matchesSelector(b[0],a)?[b[0]]:[]:f.find.matches(a,b)},dir:function(a,c,d){var e=[],g=a[c];while(g&&g.nodeType!==9&&(d===b||g.nodeType!==1||!f(g).is(d)))g.nodeType===1&&e.push(g),g=g[c];return e},nth:function(a,b,c,d){b=b||1;var e=0;for(;a;a=a[c])if(a.nodeType===1&&++e===b)break;return a},sibling:function(a,b){var c=[];for(;a;a=a.nextSibling)a.nodeType===1&&a!==b&&c.push(a);return c}});var V="abbr|article|aside|audio|canvas|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",W=/ jQuery\d+="(?:\d+|null)"/g,X=/^\s+/,Y=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,Z=/<([\w:]+)/,$=/<tbody/i,_=/<|&#?\w+;/,ba=/<(?:script|style)/i,bb=/<(?:script|object|embed|option|style)/i,bc=new RegExp("<(?:"+V+")","i"),bd=/checked\s*(?:[^=]|=\s*.checked.)/i,be=/\/(java|ecma)script/i,bf=/^\s*<!(?:\[CDATA\[|\-\-)/,bg={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]},bh=U(c);bg.optgroup=bg.option,bg.tbody=bg.tfoot=bg.colgroup=bg.caption=bg.thead,bg.th=bg.td,f.support.htmlSerialize||(bg._default=[1,"div<div>","</div>"]),f.fn.extend({text:function(a){if(f.isFunction(a))return this.each(function(b){var c=f(this);c.text(a.call(this,b,c.text()))});if(typeof a!="object"&&a!==b)return this.empty().append((this[0]&&this[0].ownerDocument||c).createTextNode(a));return f.text(this)},wrapAll:function(a){if(f.isFunction(a))return this.each(function(b){f(this).wrapAll(a.call(this,b))});if(this[0]){var b=f(a,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstChild&&a.firstChild.nodeType===1)a=a.firstChild;return a}).append(this)}return this},wrapInner:function(a){if(f.isFunction(a))return this.each(function(b){f(this).wrapInner(a.call(this,b))});return this.each(function(){var b=f(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=f.isFunction(a);return this.each(function(c){f(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){f.nodeName(this,"body")||f(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,!0,function(a){this.nodeType===1&&this.appendChild(a)})},prepend:function(){return this.domManip(arguments,!0,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this)});if(arguments.length){var a=f.clean(arguments);a.push.apply(a,this.toArray());return this.pushStack(a,"before",arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this.nextSibling)});if(arguments.length){var a=this.pushStack(this,"after",arguments);a.push.apply(a,f.clean(arguments));return a}},remove:function(a,b){for(var c=0,d;(d=this[c])!=null;c++)if(!a||f.filter(a,[d]).length)!b&&d.nodeType===1&&(f.cleanData(d.getElementsByTagName("*")),f.cleanData([d])),d.parentNode&&d.parentNode.removeChild(d);return this},empty:function()
{for(var a=0,b;(b=this[a])!=null;a++){b.nodeType===1&&f.cleanData(b.getElementsByTagName("*"));while(b.firstChild)b.removeChild(b.firstChild)}return this},clone:function(a,b){a=a==null?!1:a,b=b==null?a:b;return this.map(function(){return f.clone(this,a,b)})},html:function(a){if(a===b)return this[0]&&this[0].nodeType===1?this[0].innerHTML.replace(W,""):null;if(typeof a=="string"&&!ba.test(a)&&(f.support.leadingWhitespace||!X.test(a))&&!bg[(Z.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(Y,"<$1></$2>");try{for(var c=0,d=this.length;c<d;c++)this[c].nodeType===1&&(f.cleanData(this[c].getElementsByTagName("*")),this[c].innerHTML=a)}catch(e){this.empty().append(a)}}else f.isFunction(a)?this.each(function(b){var c=f(this);c.html(a.call(this,b,c.html()))}):this.empty().append(a);return this},replaceWith:function(a){if(this[0]&&this[0].parentNode){if(f.isFunction(a))return this.each(function(b){var c=f(this),d=c.html();c.replaceWith(a.call(this,b,d))});typeof a!="string"&&(a=f(a).detach());return this.each(function(){var b=this.nextSibling,c=this.parentNode;f(this).remove(),b?f(b).before(a):f(c).append(a)})}return this.length?this.pushStack(f(f.isFunction(a)?a():a),"replaceWith",a):this},detach:function(a){return this.remove(a,!0)},domManip:function(a,c,d){var e,g,h,i,j=a[0],k=[];if(!f.support.checkClone&&arguments.length===3&&typeof j=="string"&&bd.test(j))return this.each(function(){f(this).domManip(a,c,d,!0)});if(f.isFunction(j))return this.each(function(e){var g=f(this);a[0]=j.call(this,e,c?g.html():b),g.domManip(a,c,d)});if(this[0]){i=j&&j.parentNode,f.support.parentNode&&i&&i.nodeType===11&&i.childNodes.length===this.length?e={fragment:i}:e=f.buildFragment(a,this,k),h=e.fragment,h.childNodes.length===1?g=h=h.firstChild:g=h.firstChild;if(g){c=c&&f.nodeName(g,"tr");for(var l=0,m=this.length,n=m-1;l<m;l++)d.call(c?bi(this[l],g):this[l],e.cacheable||m>1&&l<n?f.clone(h,!0,!0):h)}k.length&&f.each(k,bp)}return this}}),f.buildFragment=function(a,b,d){var e,g,h,i,j=a[0];b&&b[0]&&(i=b[0].ownerDocument||b[0]),i.createDocumentFragment||(i=c),a.length===1&&typeof j=="string"&&j.length<512&&i===c&&j.charAt(0)==="<"&&!bb.test(j)&&(f.support.checkClone||!bd.test(j))&&(f.support.html5Clone||!bc.test(j))&&(g=!0,h=f.fragments[j],h&&h!==1&&(e=h)),e||(e=i.createDocumentFragment(),f.clean(a,i,e,d)),g&&(f.fragments[j]=h?e:1);return{fragment:e,cacheable:g}},f.fragments={},f.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){f.fn[a]=function(c){var d=[],e=f(c),g=this.length===1&&this[0].parentNode;if(g&&g.nodeType===11&&g.childNodes.length===1&&e.length===1){e[b](this[0]);return this}for(var h=0,i=e.length;h<i;h++){var j=(h>0?this.clone(!0):this).get();f(e[h])[b](j),d=d.concat(j)}return this.pushStack(d,a,e.selector)}}),f.extend({clone:function(a,b,c){var d,e,g,h=f.support.html5Clone||!bc.test("<"+a.nodeName)?a.cloneNode(!0):bo(a);if((!f.support.noCloneEvent||!f.support.noCloneChecked)&&(a.nodeType===1||a.nodeType===11)&&!f.isXMLDoc(a)){bk(a,h),d=bl(a),e=bl(h);for(g=0;d[g];++g)e[g]&&bk(d[g],e[g])}if(b){bj(a,h);if(c){d=bl(a),e=bl(h);for(g=0;d[g];++g)bj(d[g],e[g])}}d=e=null;return h},clean:function(a,b,d,e){var g;b=b||c,typeof b.createElement=="undefined"&&(b=b.ownerDocument||b[0]&&b[0].ownerDocument||c);var h=[],i;for(var j=0,k;(k=a[j])!=null;j++){typeof k=="number"&&(k+="");if(!k)continue;if(typeof k=="string")if(!_.test(k))k=b.createTextNode(k);else{k=k.replace(Y,"<$1></$2>");var l=(Z.exec(k)||["",""])[1].toLowerCase(),m=bg[l]||bg._default,n=m[0],o=b.createElement("div");b===c?bh.appendChild(o):U(b).appendChild(o),o.innerHTML=m[1]+k+m[2];while(n--)o=o.lastChild;if(!f.support.tbody){var p=$.test(k),q=l==="table"&&!p?o.firstChild&&o.firstChild.childNodes:m[1]==="<table>"&&!p?o.childNodes:[];for(i=q.length-1;i>=0;--i)f.nodeName(q[i],"tbody")&&!q[i].childNodes.length&&q[i].parentNode.removeChild(q[i])}!f.support.leadingWhitespace&&X.test(k)&&o.insertBefore(b.createTextNode(X.exec(k)[0]),o.firstChild),k=o.childNodes}var r;if(!f.support.appendChecked)if(k[0]&&typeof (r=k.length)=="number")for(i=0;i<r;i++)bn(k[i]);else bn(k);k.nodeType?h.push(k):h=f.merge(h,k)}if(d){g=function(a){return!a.type||be.test(a.type)};for(j=0;h[j];j++)if(e&&f.nodeName(h[j],"script")&&(!h[j].type||h[j].type.toLowerCase()==="text/javascript"))e.push(h[j].parentNode?h[j].parentNode.removeChild(h[j]):h[j]);else{if(h[j].nodeType===1){var s=f.grep(h[j].getElementsByTagName("script"),g);h.splice.apply(h,[j+1,0].concat(s))}d.appendChild(h[j])}}return h},cleanData:function(a){var b,c,d=f.cache,e=f.event.special,g=f.support.deleteExpando;for(var h=0,i;(i=a[h])!=null;h++){if(i.nodeName&&f.noData[i.nodeName.toLowerCase()])continue;c=i[f.expando];if(c){b=d[c];if(b&&b.events){for(var j in b.events)e[j]?f.event.remove(i,j):f.removeEvent(i,j,b.handle);b.handle&&(b.handle.elem=null)}g?delete i[f.expando]:i.removeAttribute&&i.removeAttribute(f.expando),delete d[c]}}}});var bq=/alpha\([^)]*\)/i,br=/opacity=([^)]*)/,bs=/([A-Z]|^ms)/g,bt=/^-?\d+(?:px)?$/i,bu=/^-?\d/,bv=/^([\-+])=([\-+.\de]+)/,bw={position:"absolute",visibility:"hidden",display:"block"},bx=["Left","Right"],by=["Top","Bottom"],bz,bA,bB;f.fn.css=function(a,c){if(arguments.length===2&&c===b)return this;return f.access(this,a,c,!0,function(a,c,d){return d!==b?f.style(a,c,d):f.css(a,c)})},f.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=bz(a,"opacity","opacity");return c===""?"1":c}return a.style.opacity}}},cssNumber:{fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":f.support.cssFloat?"cssFloat":"styleFloat"},style:function(a,c,d,e){if(!!a&&a.nodeType!==3&&a.nodeType!==8&&!!a.style){var g,h,i=f.camelCase(c),j=a.style,k=f.cssHooks[i];c=f.cssProps[i]||i;if(d===b){if(k&&"get"in k&&(g=k.get(a,!1,e))!==b)return g;return j[c]}h=typeof d,h==="string"&&(g=bv.exec(d))&&(d=+(g[1]+1)*+g[2]+parseFloat(f.css(a,c)),h="number");if(d==null||h==="number"&&isNaN(d))return;h==="number"&&!f.cssNumber[i]&&(d+="px");if(!k||!("set"in k)||(d=k.set(a,d))!==b)try{j[c]=d}catch(l){}}},css:function(a,c,d){var e,g;c=f.camelCase(c),g=f.cssHooks[c],c=f.cssProps[c]||c,c==="cssFloat"&&(c="float");if(g&&"get"in g&&(e=g.get(a,!0,d))!==b)return e;if(bz)return bz(a,c)},swap:function(a,b,c){var d={};for(var e in b)d[e]=a.style[e],a.style[e]=b[e];c.call(a);for(e in b)a.style[e]=d[e]}}),f.curCSS=f.css,f.each(["height","width"],function(a,b){f.cssHooks[b]={get:function(a,c,d){var e;if(c){if(a.offsetWidth!==0)return bC(a,b,d);f.swap(a,bw,function(){e=bC(a,b,d)});return e}},set:function(a,b){if(!bt.test(b))return b;b=parseFloat(b);if(b>=0)return b+"px"}}}),f.support.opacity||(f.cssHooks.opacity={get:function(a,b){return br.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?parseFloat(RegExp.$1)/100+"":b?"1":""},set:function(a,b){var c=a.style,d=a.currentStyle,e=f.isNumeric(b)?"alpha(opacity="+b*100+")":"",g=d&&d.filter||c.filter||"";c.zoom=1;if(b>=1&&f.trim(g.replace(bq,""))===""){c.removeAttribute("filter");if(d&&!d.filter)return}c.filter=bq.test(g)?g.replace(bq,e):g+" "+e}}),f(function(){f.support.reliableMarginRight||(f.cssHooks.marginRight={get:function(a,b){var c;f.swap(a,{display:"inline-block"},function(){b?c=bz(a,"margin-right","marginRight"):c=a.style.marginRight});return c}})}),c.defaultView&&c.defaultView.getComputedStyle&&(bA=function(a,b){var c,d,e;b=b.replace(bs,"-$1").toLowerCase(),(d=a.ownerDocument.defaultView)&&(e=d.getComputedStyle(a,null))&&(c=e.getPropertyValue(b),c===""&&!f.contains(a.ownerDocument.documentElement,a)&&(c=f.style(a,b)));return c}),c.documentElement.currentStyle&&(bB=function(a,b){var c,d,e,f=a.currentStyle&&a.currentStyle[b],g=a.style;f===null&&g&&(e=g[b])&&(f=e),!bt.test(f)&&bu.test(f)&&(c=g.left,d=a.runtimeStyle&&a.runtimeStyle.left,d&&(a.runtimeStyle.left=a.currentStyle.left),g.left=b==="fontSize"?"1em":f||0,f=g.pixelLeft+"px",g.left=c,d&&(a.runtimeStyle.left=d));return f===""?"auto":f}),bz=bA||bB,f.expr&&f.expr.filters&&(f.expr.filters.hidden=function(a){var b=a.offsetWidth,c=a.offsetHeight;return b===0&&c===0||!f.support.reliableHiddenOffsets&&(a.style&&a.style.display||f.css(a,"display"))==="none"},f.expr.filters.visible=function(a){return!f.expr.filters.hidden(a)});var bD=/%20/g,bE=/\[\]$/,bF=/\r?\n/g,bG=/#.*$/,bH=/^(.*?):[ \t]*([^\r\n]*)\r?$/mg,bI=/^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,bJ=/^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,bK=/^(?:GET|HEAD)$/,bL=/^\/\//,bM=/\?/,bN=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,bO=/^(?:select|textarea)/i,bP=/\s+/,bQ=/([?&])_=[^&]*/,bR=/^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,bS=f.fn.load,bT={},bU={},bV,bW,bX=["*/"]+["*"];try{bV=e.href}catch(bY){bV=c.createElement("a"),bV.href="",bV=bV.href}bW=bR.exec(bV.toLowerCase())||[],f.fn.extend({load:function(a,c,d){if(typeof a!="string"&&bS)return bS.apply(this,arguments);if(!this.length)return this;var e=a.indexOf(" ");if(e>=0){var g=a.slice(e,a.length);a=a.slice(0,e)}var h="GET";c&&(f.isFunction(c)?(d=c,c=b):typeof c=="object"&&(c=f.param(c,f.ajaxSettings.traditional),h="POST"));var i=this;f.ajax({url:a,type:h,dataType:"html",data:c,complete:function(a,b,c){c=a.responseText,a.isResolved()&&(a.done(function(a){c=a}),i.html(g?f("<div>").append(c.replace(bN,"")).find(g):c)),d&&i.each(d,[c,b,a])}});return this},serialize:function(){return f.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?f.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||bO.test(this.nodeName)||bI.test(this.type))}).map(function(a,b){var c=f(this).val();return c==null?null:f.isArray(c)?f.map(c,function(a,c){return{name:b.name,value:a.replace(bF,"\r\n")}}):{name:b.name,value:c.replace(bF,"\r\n")}}).get()}}),f.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),function(a,b){f.fn[b]=function(a){return this.on(b,a)}}),f.each(["get","post"],function(a,c){f[c]=function(a,d,e,g){f.isFunction(d)&&(g=g||e,e=d,d=b);return f.ajax({type:c,url:a,data:d,success:e,dataType:g})}}),f.extend({getScript:function(a,c){return f.get(a,b,c,"script")},getJSON:function(a,b,c){return f.get(a,b,c,"json")},ajaxSetup:function(a,b){b?b_(a,f.ajaxSettings):(b=a,a=f.ajaxSettings),b_(a,b);return a},ajaxSettings:{url:bV,isLocal:bJ.test(bW[1]),global:!0,type:"GET",contentType:"application/x-www-form-urlencoded",processData:!0,async:!0,accepts:{xml:"application/xml, text/xml",html:"text/html",text:"text/plain",json:"application/json, text/javascript","*":bX},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText"},converters:{"* text":a.String,"text html":!0,"text json":f.parseJSON,"text xml":f.parseXML},flatOptions:{context:!0,url:!0}},ajaxPrefilter:bZ(bT),ajaxTransport:bZ(bU),ajax:function(a,c){function w(a,c,l,m){if(s!==2){s=2,q&&clearTimeout(q),p=b,n=m||"",v.readyState=a>0?4:0;var o,r,u,w=c,x=l?cb(d,v,l):b,y,z;if(a>=200&&a<300||a===304){if(d.ifModified){if(y=v.getResponseHeader("Last-Modified"))f.lastModified[k]=y;if(z=v.getResponseHeader("Etag"))f.etag[k]=z}if(a===304)w="notmodified",o=!0;else try{r=cc(d,x),w="success",o=!0}catch(A){w="parsererror",u=A}}else{u=w;if(!w||a)w="error",a<0&&(a=0)}v.status=a,v.statusText=""+(c||w),o?h.resolveWith(e,[r,w,v]):h.rejectWith(e,[v,w,u]),v.statusCode(j),j=b,t&&g.trigger("ajax"+(o?"Success":"Error"),[v,d,o?r:u]),i.fireWith(e,[v,w]),t&&(g.trigger("ajaxComplete",[v,d]),--f.active||f.event.trigger("ajaxStop"))}}typeof a=="object"&&(c=a,a=b),c=c||{};var d=f.ajaxSetup({},c),e=d.context||d,g=e!==d&&(e.nodeType||e instanceof f)?f(e):f.event,h=f.Deferred(),i=f.Callbacks("once memory"),j=d.statusCode||{},k,l={},m={},n,o,p,q,r,s=0,t,u,v={readyState:0,setRequestHeader:function(a,b){if(!s){var c=a.toLowerCase();a=m[c]=m[c]||a,l[a]=b}return this},getAllResponseHeaders:function(){return s===2?n:null},getResponseHeader:function(a){var c;if(s===2){if(!o){o={};while(c=bH.exec(n))o[c[1].toLowerCase()]=c[2]}c=o[a.toLowerCase()]}return c===b?null:c},overrideMimeType:function(a){s||(d.mimeType=a);return this},abort:function(a){a=a||"abort",p&&p.abort(a),w(0,a);return this}};h.promise(v),v.success=v.done,v.error=v.fail,v.complete=i.add,v.statusCode=function(a){if(a){var b;if(s<2)for(b in a)j[b]=[j[b],a[b]];else b=a[v.status],v.then(b,b)}return this},d.url=((a||d.url)+"").replace(bG,"").replace(bL,bW[1]+"//"),d.dataTypes=f.trim(d.dataType||"*").toLowerCase().split(bP),d.crossDomain==null&&(r=bR.exec(d.url.toLowerCase()),d.crossDomain=!(!r||r[1]==bW[1]&&r[2]==bW[2]&&(r[3]||(r[1]==="http:"?80:443))==(bW[3]||(bW[1]==="http:"?80:443)))),d.data&&d.processData&&typeof d.data!="string"&&(d.data=f.param(d.data,d.traditional)),b$(bT,d,c,v);if(s===2)return!1;t=d.global,d.type=d.type.toUpperCase(),d.hasContent=!bK.test(d.type),t&&f.active++===0&&f.event.trigger("ajaxStart");if(!d.hasContent){d.data&&(d.url+=(bM.test(d.url)?"&":"?")+d.data,delete d.data),k=d.url;if(d.cache===!1){var x=f.now(),y=d.url.replace(bQ,"$1_="+x);d.url=y+(y===d.url?(bM.test(d.url)?"&":"?")+"_="+x:"")}}(d.data&&d.hasContent&&d.contentType!==!1||c.contentType)&&v.setRequestHeader("Content-Type",d.contentType),d.ifModified&&(k=k||d.url,f.lastModified[k]&&v.setRequestHeader("If-Modified-Since",f.lastModified[k]),f.etag[k]&&v.setRequestHeader("If-None-Match",f.etag[k])),v.setRequestHeader("Accept",d.dataTypes[0]&&d.accepts[d.dataTypes[0]]?d.accepts[d.dataTypes[0]]+(d.dataTypes[0]!=="*"?", "+bX+"; q=0.01":""):d.accepts["*"]);for(u in d.headers)v.setRequestHeader(u,d.headers[u]);if(d.beforeSend&&(d.beforeSend.call(e,v,d)===!1||s===2)){v.abort();return!1}for(u in{success:1,error:1,complete:1})v[u](d[u]);p=b$(bU,d,c,v);if(!p)w(-1,"No Transport");else{v.readyState=1,t&&g.trigger("ajaxSend",[v,d]),d.async&&d.timeout>0&&(q=setTimeout(function(){v.abort("timeout")},d.timeout));try{s=1,p.send(l,w)}catch(z){if(s<2)w(-1,z);else throw z}}return v},param:function(a,c){var d=[],e=function(a,b){b=f.isFunction(b)?b():b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};c===b&&(c=f.ajaxSettings.traditional);if(f.isArray(a)||a.jquery&&!f.isPlainObject(a))f.each(a,function(){e(this.name,this.value)});else for(var g in a)ca(g,a[g],c,e);return d.join("&").replace(bD,"+")}}),f.extend({active:0,lastModified:{},etag:{}});var cd=f.now(),ce=/(\=)\?(&|$)|\?\?/i;f.ajaxSetup({jsonp:"callback",jsonpCallback:function(){return f.expando+"_"+cd++}}),f.ajaxPrefilter("json jsonp",function(b,c,d){var e=b.contentType==="application/x-www-form-urlencoded"&&typeof b.data=="string";if(b.dataTypes[0]==="jsonp"||b.jsonp!==!1&&(ce.test(b.url)||e&&ce.test(b.data))){var g,h=b.jsonpCallback=f.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,i=a[h],j=b.url,k=b.data,l="$1"+h+"$2";b.jsonp!==!1&&(j=j.replace(ce,l),b.url===j&&(e&&(k=k.replace(ce,l)),b.data===k&&(j+=(/\?/.test(j)?"&":"?")+b.jsonp+"="+h))),b.url=j,b.data=k,a[h]=function(a){g=[a]},d.always(function(){a[h]=i,g&&f.isFunction(i)&&a[h](g[0])}),b.converters["script json"]=function(){g||f.error(h+" was not called");return g[0]},b.dataTypes[0]="json";return"script"}}),f.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/javascript|ecmascript/},converters:{"text script":function(a){f.globalEval(a);return a}}}),f.ajaxPrefilter("script",function(a){a.cache===b&&(a.cache=!1),a.crossDomain&&(a.type="GET",a.global=!1)}),f.ajaxTransport("script",function(a){if(a.crossDomain){var d,e=c.head||c.getElementsByTagName("head")[0]||c.documentElement;return{send:function(f,g){d=c.createElement("script"),d.async="async",a.scriptCharset&&(d.charset=a.scriptCharset),d.src=a.url,d.onload=d.onreadystatechange=function(a,c){if(c||!d.readyState||/loaded|complete/.test(d.readyState))d.onload=d.onreadystatechange=null,e&&d.parentNode&&e.removeChild(d),d=b,c||g(200,"success")},e.insertBefore(d,e.firstChild)},abort:function(){d&&d.onload(0,1)}}}});var cf=a.ActiveXObject?function(){for(var a in ch)ch[a](0,1)}:!1,cg=0,ch;f.ajaxSettings.xhr=a.ActiveXObject?function(){return!this.isLocal&&ci()||cj()}:ci,function(a){f.extend(f.support,{ajax:!!a,cors:!!a&&"withCredentials"in a})}(f.ajaxSettings.xhr()),f.support.ajax&&f.ajaxTransport(function(c){if(!c.crossDomain||f.support.cors){var d;return{send:function(e,g){var h=c.xhr(),i,j;c.username?h.open(c.type,c.url,c.async,c.username,c.password):h.open(c.type,c.url,c.async);if(c.xhrFields)for(j in c.xhrFields)h[j]=c.xhrFields[j];c.mimeType&&h.overrideMimeType&&h.overrideMimeType(c.mimeType),!c.crossDomain&&!e["X-Requested-With"]&&(e["X-Requested-With"]="XMLHttpRequest");try{for(j in e)h.setRequestHeader(j,e[j])}catch(k){}h.send(c.hasContent&&c.data||null),d=function(a,e){var j,k,l,m,n;try{if(d&&(e||h.readyState===4)){d=b,i&&(h.onreadystatechange=f.noop,cf&&delete ch[i]);if(e)h.readyState!==4&&h.abort();else{j=h.status,l=h.getAllResponseHeaders(),m={},n=h.responseXML,n&&n.documentElement&&(m.xml=n),m.text=h.responseText;try{k=h.statusText}catch(o){k=""}!j&&c.isLocal&&!c.crossDomain?j=m.text?200:404:j===1223&&(j=204)}}}catch(p){e||g(-1,p)}m&&g(j,k,m,l)},!c.async||h.readyState===4?d():(i=++cg,cf&&(ch||(ch={},f(a).unload(cf)),ch[i]=d),h.onreadystatechange=d)},abort:function(){d&&d(0,1)}}}});var ck={},cl,cm,cn=/^(?:toggle|show|hide)$/,co=/^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,cp,cq=[["height","marginTop","marginBottom","paddingTop","paddingBottom"],["width","marginLeft","marginRight","paddingLeft","paddingRight"],["opacity"]],cr;f.fn.extend({show:function(a,b,c){var d,e;if(a||a===0)return this.animate(cu("show",3),a,b,c);for(var g=0,h=this.length;g<h;g++)d=this[g],d.style&&(e=d.style.display,!f._data(d,"olddisplay")&&e==="none"&&(e=d.style.display=""),e===""&&f.css(d,"display")==="none"&&f._data(d,"olddisplay",cv(d.nodeName)));for(g=0;g<h;g++){d=this[g];if(d.style){e=d.style.display;if(e===""||e==="none")d.style.display=f._data(d,"olddisplay")||""}}return this},hide:function(a,b,c){if(a||a===0)return this.animate(cu("hide",3),a,b,c);var d,e,g=0,h=this.length;for(;g<h;g++)d=this[g],d.style&&(e=f.css(d,"display"),e!=="none"&&!f._data(d,"olddisplay")&&f._data(d,"olddisplay",e));for(g=0;g<h;g++)this[g].style&&(this[g].style.display="none");return this},_toggle:f.fn.toggle,toggle:function(a,b,c){var d=typeof a=="boolean";f.isFunction(a)&&f.isFunction(b)?this._toggle.apply(this,arguments):a==null||d?this.each(function(){var b=d?a:f(this).is(":hidden");f(this)[b?"show":"hide"]()}):this.animate(cu("toggle",3),a,b,c);return this},fadeTo:function(a,b,c,d){return this.filter(":hidden").css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){function g(){e.queue===!1&&f._mark(this);var b=f.extend({},e),c=this.nodeType===1,d=c&&f(this).is(":hidden"),g,h,i,j,k,l,m,n,o;b.animatedProperties={};for(i in a){g=f.camelCase(i),i!==g&&(a[g]=a[i],delete a[i]),h=a[g],f.isArray(h)?(b.animatedProperties[g]=h[1],h=a[g]=h[0]):b.animatedProperties[g]=b.specialEasing&&b.specialEasing[g]||b.easing||"swing";if(h==="hide"&&d||h==="show"&&!d)return b.complete.call(this);c&&(g==="height"||g==="width")&&(b.overflow=[this.style.overflow,this.style.overflowX,this.style.overflowY],f.css(this,"display")==="inline"&&f.css(this,"float")==="none"&&(!f.support.inlineBlockNeedsLayout||cv(this.nodeName)==="inline"?this.style.display="inline-block":this.style.zoom=1))}b.overflow!=null&&(this.style.overflow="hidden");for(i in a)j=new f.fx(this,b,i),h=a[i],cn.test(h)?(o=f._data(this,"toggle"+i)||(h==="toggle"?d?"show":"hide":0),o?(f._data(this,"toggle"+i,o==="show"?"hide":"show"),j[o]()):j[h]()):(k=co.exec(h),l=j.cur(),k?(m=parseFloat(k[2]),n=k[3]||(f.cssNumber[i]?"":"px"),n!=="px"&&(f.style(this,i,(m||1)+n),l=(m||1)/j.cur()*l,f.style(this,i,l+n)),k[1]&&(m=(k[1]==="-="?-1:1)*m+l),j.custom(l,m,n)):j.custom(l,h,""));return!0}var e=f.speed(b,c,d);if(f.isEmptyObject(a))return this.each(e.complete,[!1]);a=f.extend({},a);return e.queue===!1?this.each(g):this.queue(e.queue,g)},stop:function(a,c,d){typeof a!="string"&&(d=c,c=a,a=b),c&&a!==!1&&this.queue(a||"fx",[]);return this.each(function(){function h(a,b,c){var e=b[c];f.removeData(a,c,!0),e.stop(d)}var b,c=!1,e=f.timers,g=f._data(this);d||f._unmark(!0,this);if(a==null)for(b in g)g[b]&&g[b].stop&&b.indexOf(".run")===b.length-4&&h(this,g,b);else g[b=a+".run"]&&g[b].stop&&h(this,g,b);for(b=e.length;b--;)e[b].elem===this&&(a==null||e[b].queue===a)&&(d?e[b](!0):e[b].saveState(),c=!0,e.splice(b,1));(!d||!c)&&f.dequeue(this,a)})}}),f.each({slideDown:cu("show",1),slideUp:cu("hide",1),slideToggle:cu("toggle",1),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){f.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),f.extend({speed:function(a,b,c){var d=a&&typeof a=="object"?f.extend({},a):{complete:c||!c&&b||f.isFunction(a)&&a,duration:a,easing:c&&b||b&&!f.isFunction(b)&&b};d.duration=f.fx.off?0:typeof d.duration=="number"?d.duration:d.duration in f.fx.speeds?f.fx.speeds[d.duration]:f.fx.speeds._default;if(d.queue==null||d.queue===!0)d.queue="fx";d.old=d.complete,d.complete=function(a){f.isFunction(d.old)&&d.old.call(this),d.queue?f.dequeue(this,d.queue):a!==!1&&f._unmark(this)};return d},easing:{linear:function(a,b,c,d){return c+d*a},swing:function(a,b,c,d){return(-Math.cos(a*Math.PI)/2+.5)*d+c}},timers:[],fx:function(a,b,c){this.options=b,this.elem=a,this.prop=c,b.orig=b.orig||{}}}),f.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this),(f.fx.step[this.prop]||f.fx.step._default)(this)},cur:function(){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];var a,b=f.css(this.elem,this.prop);return isNaN(a=parseFloat(b))?!b||b==="auto"?0:b:a},custom:function(a,c,d){function h(a){return e.step(a)}var e=this,g=f.fx;this.startTime=cr||cs(),this.end=c,this.now=this.start=a,this.pos=this.state=0,this.unit=d||this.unit||(f.cssNumber[this.prop]?"":"px"),h.queue=this.options.queue,h.elem=this.elem,h.saveState=function(){e.options.hide&&f._data(e.elem,"fxshow"+e.prop)===b&&f._data(e.elem,"fxshow"+e.prop,e.start)},h()&&f.timers.push(h)&&!cp&&(cp=setInterval(g.tick,g.interval))},show:function(){var a=f._data(this.elem,"fxshow"+this.prop);this.options.orig[this.prop]=a||f.style(this.elem,this.prop),this.options.show=!0,a!==b?this.custom(this.cur(),a):this.custom(this.prop==="width"||this.prop==="height"?1:0,this.cur()),f(this.elem).show()},hide:function(){this.options.orig[this.prop]=f._data(this.elem,"fxshow"+this.prop)||f.style(this.elem,this.prop),this.options.hide=!0,this.custom(this.cur(),0)},step:function(a){var b,c,d,e=cr||cs(),g=!0,h=this.elem,i=this.options;if(a||e>=i.duration+this.startTime){this.now=this.end,this.pos=this.state=1,this.update(),i.animatedProperties[this.prop]=!0;for(b in i.animatedProperties)i.animatedProperties[b]!==!0&&(g=!1);if(g){i.overflow!=null&&!f.support.shrinkWrapBlocks&&f.each(["","X","Y"],function(a,b){h.style["overflow"+b]=i.overflow[a]}),i.hide&&f(h).hide();if(i.hide||i.show)for(b in i.animatedProperties)f.style(h,b,i.orig[b]),f.removeData(h,"fxshow"+b,!0),f.removeData(h,"toggle"+b,!0);d=i.complete,d&&(i.complete=!1,d.call(h))}return!1}i.duration==Infinity?this.now=e:(c=e-this.startTime,this.state=c/i.duration,this.pos=f.easing[i.animatedProperties[this.prop]](this.state,c,0,1,i.duration),this.now=this.start+(this.end-this.start)*this.pos),this.update();return!0}},f.extend(f.fx,{tick:function(){var a,b=f.timers,c=0;for(;c<b.length;c++)a=b[c],!a()&&b[c]===a&&b.splice(c--,1);b.length||f.fx.stop()},interval:13,stop:function(){clearInterval(cp),cp=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){f.style(a.elem,"opacity",a.now)},_default:function(a){a.elem.style&&a.elem.style[a.prop]!=null?a.elem.style[a.prop]=a.now+a.unit:a.elem[a.prop]=a.now}}}),f.each(["width","height"],function(a,b){f.fx.step[b]=function(a){f.style(a.elem,b,Math.max(0,a.now)+a.unit)}}),f.expr&&f.expr.filters&&(f.expr.filters.animated=function(a){return f.grep(f.timers,function(b){return a===b.elem}).length});var cw=/^t(?:able|d|h)$/i,cx=/^(?:body|html)$/i;"getBoundingClientRect"in c.documentElement?f.fn.offset=function(a){var b=this[0],c;if(a)return this.each(function(b){f.offset.setOffset(this,a,b)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return f.offset.bodyOffset(b);try{c=b.getBoundingClientRect()}catch(d){}var e=b.ownerDocument,g=e.documentElement;if(!c||!f.contains(g,b))return c?{top:c.top,left:c.left}:{top:0,left:0};var h=e.body,i=cy(e),j=g.clientTop||h.clientTop||0,k=g.clientLeft||h.clientLeft||0,l=i.pageYOffset||f.support.boxModel&&g.scrollTop||h.scrollTop,m=i.pageXOffset||f.support.boxModel&&g.scrollLeft||h.scrollLeft,n=c.top+l-j,o=c.left+m-k;return{top:n,left:o}}:f.fn.offset=function(a){var b=this[0];if(a)return this.each(function(b){f.offset.setOffset(this,a,b)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return f.offset.bodyOffset(b);var c,d=b.offsetParent,e=b,g=b.ownerDocument,h=g.documentElement,i=g.body,j=g.defaultView,k=j?j.getComputedStyle(b,null):b.currentStyle,l=b.offsetTop,m=b.offsetLeft;while((b=b.parentNode)&&b!==i&&b!==h){if(f.support.fixedPosition&&k.position==="fixed")break;c=j?j.getComputedStyle(b,null):b.currentStyle,l-=b.scrollTop,m-=b.scrollLeft,b===d&&(l+=b.offsetTop,m+=b.offsetLeft,f.support.doesNotAddBorder&&(!f.support.doesAddBorderForTableAndCells||!cw.test(b.nodeName))&&(l+=parseFloat(c.borderTopWidth)||0,m+=parseFloat(c.borderLeftWidth)||0),e=d,d=b.offsetParent),f.support.subtractsBorderForOverflowNotVisible&&c.overflow!=="visible"&&(l+=parseFloat(c.borderTopWidth)||0,m+=parseFloat(c.borderLeftWidth)||0),k=c}if(k.position==="relative"||k.position==="static")l+=i.offsetTop,m+=i.offsetLeft;f.support.fixedPosition&&k.position==="fixed"&&(l+=Math.max(h.scrollTop,i.scrollTop),m+=Math.max(h.scrollLeft,i.scrollLeft));return{top:l,left:m}},f.offset={bodyOffset:function(a){var b=a.offsetTop,c=a.offsetLeft;f.support.doesNotIncludeMarginInBodyOffset&&(b+=parseFloat(f.css(a,"marginTop"))||0,c+=parseFloat(f.css(a,"marginLeft"))||0);return{top:b,left:c}},setOffset:function(a,b,c){var d=f.css(a,"position");d==="static"&&(a.style.position="relative");var e=f(a),g=e.offset(),h=f.css(a,"top"),i=f.css(a,"left"),j=(d==="absolute"||d==="fixed")&&f.inArray("auto",[h,i])>-1,k={},l={},m,n;j?(l=e.position(),m=l.top,n=l.left):(m=parseFloat(h)||0,n=parseFloat(i)||0),f.isFunction(b)&&(b=b.call(a,c,g)),b.top!=null&&(k.top=b.top-g.top+m),b.left!=null&&(k.left=b.left-g.left+n),"using"in b?b.using.call(a,k):e.css(k)}},f.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),c=this.offset(),d=cx.test(b[0].nodeName)?{top:0,left:0}:b.offset();c.top-=parseFloat(f.css(a,"marginTop"))||0,c.left-=parseFloat(f.css(a,"marginLeft"))||0,d.top+=parseFloat(f.css(b[0],"borderTopWidth"))||0,d.left+=parseFloat(f.css(b[0],"borderLeftWidth"))||0;return{top:c.top-d.top,left:c.left-d.left}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||c.body;while(a&&!cx.test(a.nodeName)&&f.css(a,"position")==="static")a=a.offsetParent;return a})}}),f.each(["Left","Top"],function(a,c){var d="scroll"+c;f.fn[d]=function(c){var e,g;if(c===b){e=this[0];if(!e)return null;g=cy(e);return g?"pageXOffset"in g?g[a?"pageYOffset":"pageXOffset"]:f.support.boxModel&&g.document.documentElement[d]||g.document.body[d]:e[d]}return this.each(function(){g=cy(this),g?g.scrollTo(a?f(g).scrollLeft():c,a?c:f(g).scrollTop()):this[d]=c})}}),f.each(["Height","Width"],function(a,c){var d=c.toLowerCase();f.fn["inner"+c]=function(){var a=this[0];return a?a.style?parseFloat(f.css(a,d,"padding")):this[d]():null},f.fn["outer"+c]=function(a){var b=this[0];return b?b.style?parseFloat(f.css(b,d,a?"margin":"border")):this[d]():null},f.fn[d]=function(a){var e=this[0];if(!e)return a==null?null:this;if(f.isFunction(a))return this.each(function(b){var c=f(this);c[d](a.call(this,b,c[d]()))});if(f.isWindow(e)){var g=e.document.documentElement["client"+c],h=e.document.body;return e.document.compatMode==="CSS1Compat"&&g||h&&h["client"+c]||g}if(e.nodeType===9)return Math.max(e.documentElement["client"+c],e.body["scroll"+c],e.documentElement["scroll"+c],e.body["offset"+c],e.documentElement["offset"+c]);if(a===b){var i=f.css(e,d),j=parseFloat(i);return f.isNumeric(j)?j:i}return this.css(d,typeof a=="string"?a:a+"px")}}),a.jQuery=a.$=f,typeof define=="function"&&define.amd&&define.amd.jQuery&&define("jquery",[],function(){return f})})(window);
</script><script type="text/javascript">//XRegExp 1.5.0 <xregexp.com> MIT License
var XRegExp;if(XRegExp){throw Error("can't load XRegExp twice in the same frame")}(function(){XRegExp=function(w,r){var q=[],u=XRegExp.OUTSIDE_CLASS,x=0,p,s,v,t,y;if(XRegExp.isRegExp(w)){if(r!==undefined){throw TypeError("can't supply flags when constructing one RegExp from another")}return j(w)}if(g){throw Error("can't call the XRegExp constructor within token definition functions")}r=r||"";p={hasNamedCapture:false,captureNames:[],hasFlag:function(z){return r.indexOf(z)>-1},setFlag:function(z){r+=z}};while(x<w.length){s=o(w,x,u,p);if(s){q.push(s.output);x+=(s.match[0].length||1)}else{if(v=m.exec.call(i[u],w.slice(x))){q.push(v[0]);x+=v[0].length}else{t=w.charAt(x);if(t==="["){u=XRegExp.INSIDE_CLASS}else{if(t==="]"){u=XRegExp.OUTSIDE_CLASS}}q.push(t);x++}}}y=RegExp(q.join(""),m.replace.call(r,h,""));y._xregexp={source:w,captureNames:p.hasNamedCapture?p.captureNames:null};return y};XRegExp.version="1.5.0";XRegExp.INSIDE_CLASS=1;XRegExp.OUTSIDE_CLASS=2;var c=/\$(?:(\d\d?|[$&`'])|{([$\w]+)})/g,h=/[^gimy]+|([\s\S])(?=[\s\S]*\1)/g,n=/^(?:[?*+]|{\d+(?:,\d*)?})\??/,g=false,k=[],m={exec:RegExp.prototype.exec,test:RegExp.prototype.test,match:String.prototype.match,replace:String.prototype.replace,split:String.prototype.split},a=m.exec.call(/()??/,"")[1]===undefined,e=function(){var p=/^/g;m.test.call(p,"");return !p.lastIndex}(),f=function(){var p=/x/g;m.replace.call("x",p,"");return !p.lastIndex}(),b=RegExp.prototype.sticky!==undefined,i={};i[XRegExp.INSIDE_CLASS]=/^(?:\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S]))/;i[XRegExp.OUTSIDE_CLASS]=/^(?:\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S])|\(\?[:=!]|[?*+]\?|{\d+(?:,\d*)?}\??)/;XRegExp.addToken=function(s,r,q,p){k.push({pattern:j(s,"g"+(b?"y":"")),handler:r,scope:q||XRegExp.OUTSIDE_CLASS,trigger:p||null})};XRegExp.cache=function(r,p){var q=r+"/"+(p||"");return XRegExp.cache[q]||(XRegExp.cache[q]=XRegExp(r,p))};XRegExp.copyAsGlobal=function(p){return j(p,"g")};XRegExp.escape=function(p){return p.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&")};XRegExp.execAt=function(s,r,t,q){r=j(r,"g"+((q&&b)?"y":""));r.lastIndex=t=t||0;var p=r.exec(s);if(q){return(p&&p.index===t)?p:null}else{return p}};XRegExp.freezeTokens=function(){XRegExp.addToken=function(){throw Error("can't run addToken after freezeTokens")}};XRegExp.isRegExp=function(p){return Object.prototype.toString.call(p)==="[object RegExp]"};XRegExp.iterate=function(u,p,v,s){var t=j(p,"g"),r=-1,q;while(q=t.exec(u)){v.call(s,q,++r,u,t);if(t.lastIndex===q.index){t.lastIndex++}}if(p.global){p.lastIndex=0}};XRegExp.matchChain=function(q,p){return function r(s,x){var v=p[x].regex?p[x]:{regex:p[x]},u=j(v.regex,"g"),w=[],t;for(t=0;t<s.length;t++){XRegExp.iterate(s[t],u,function(y){w.push(v.backref?(y[v.backref]||""):y[0])})}return((x===p.length-1)||!w.length)?w:r(w,x+1)}([q],0)};RegExp.prototype.apply=function(q,p){return this.exec(p[0])};RegExp.prototype.call=function(p,q){return this.exec(q)};RegExp.prototype.exec=function(t){var r=m.exec.apply(this,arguments),q,p;if(r){if(!a&&r.length>1&&l(r,"")>-1){p=RegExp(this.source,m.replace.call(d(this),"g",""));m.replace.call(t.slice(r.index),p,function(){for(var u=1;u<arguments.length-2;u++){if(arguments[u]===undefined){r[u]=undefined}}})}if(this._xregexp&&this._xregexp.captureNames){for(var s=1;s<r.length;s++){q=this._xregexp.captureNames[s-1];if(q){r[q]=r[s]}}}if(!e&&this.global&&!r[0].length&&(this.lastIndex>r.index)){this.lastIndex--}}return r};if(!e){RegExp.prototype.test=function(q){var p=m.exec.call(this,q);if(p&&this.global&&!p[0].length&&(this.lastIndex>p.index)){this.lastIndex--}return !!p}}String.prototype.match=function(q){if(!XRegExp.isRegExp(q)){q=RegExp(q)}if(q.global){var p=m.match.apply(this,arguments);q.lastIndex=0;return p}return q.exec(this)};String.prototype.replace=function(r,s){var t=XRegExp.isRegExp(r),q,p,u;if(t&&typeof s.valueOf()==="string"&&s.indexOf("${")===-1&&f){return m.replace.apply(this,arguments)}if(!t){r=r+""}else{if(r._xregexp){q=r._xregexp.captureNames}}if(typeof s==="function"){p=m.replace.call(this,r,function(){if(q){arguments[0]=new String(arguments[0]);for(var v=0;v<q.length;v++){if(q[v]){arguments[0][q[v]]=arguments[v+1]}}}if(t&&r.global){r.lastIndex=arguments[arguments.length-2]+arguments[0].length}return s.apply(null,arguments)})}else{u=this+"";p=m.replace.call(u,r,function(){var v=arguments;return m.replace.call(s,c,function(x,w,A){if(w){switch(w){case"$":return"$";case"&":return v[0];case"`":return v[v.length-1].slice(0,v[v.length-2]);case"'":return v[v.length-1].slice(v[v.length-2]+v[0].length);default:var y="";w=+w;if(!w){return x}while(w>v.length-3){y=String.prototype.slice.call(w,-1)+y;w=Math.floor(w/10)}return(w?v[w]||"":"$")+y}}else{var z=+A;if(z<=v.length-3){return v[z]}z=q?l(q,A):-1;return z>-1?v[z+1]:x}})})}if(t&&r.global){r.lastIndex=0}return p};String.prototype.split=function(u,p){if(!XRegExp.isRegExp(u)){return m.split.apply(this,arguments)}var w=this+"",r=[],v=0,t,q;if(p===undefined||+p<0){p=Infinity}else{p=Math.floor(+p);if(!p){return[]}}u=XRegExp.copyAsGlobal(u);while(t=u.exec(w)){if(u.lastIndex>v){r.push(w.slice(v,t.index));if(t.length>1&&t.index<w.length){Array.prototype.push.apply(r,t.slice(1))}q=t[0].length;v=u.lastIndex;if(r.length>=p){break}}if(u.lastIndex===t.index){u.lastIndex++}}if(v===w.length){if(!m.test.call(u,"")||q){r.push("")}}else{r.push(w.slice(v))}return r.length>p?r.slice(0,p):r};function j(r,q){if(!XRegExp.isRegExp(r)){throw TypeError("type RegExp expected")}var p=r._xregexp;r=XRegExp(r.source,d(r)+(q||""));if(p){r._xregexp={source:p.source,captureNames:p.captureNames?p.captureNames.slice(0):null}}return r}function d(p){return(p.global?"g":"")+(p.ignoreCase?"i":"")+(p.multiline?"m":"")+(p.extended?"x":"")+(p.sticky?"y":"")}function o(v,u,w,p){var r=k.length,y,s,x;g=true;try{while(r--){x=k[r];if((w&x.scope)&&(!x.trigger||x.trigger.call(p))){x.pattern.lastIndex=u;s=x.pattern.exec(v);if(s&&s.index===u){y={output:x.handler.call(p,s,w),match:s};break}}}}catch(q){throw q}finally{g=false}return y}function l(s,q,r){if(Array.prototype.indexOf){return s.indexOf(q,r)}for(var p=r||0;p<s.length;p++){if(s[p]===q){return p}}return -1}XRegExp.addToken(/\(\?#[^)]*\)/,function(p){return m.test.call(n,p.input.slice(p.index+p[0].length))?"":"(?:)"});XRegExp.addToken(/\((?!\?)/,function(){this.captureNames.push(null);return"("});XRegExp.addToken(/\(\?<([$\w]+)>/,function(p){this.captureNames.push(p[1]);this.hasNamedCapture=true;return"("});XRegExp.addToken(/\\k<([\w$]+)>/,function(q){var p=l(this.captureNames,q[1]);return p>-1?"\\"+(p+1)+(isNaN(q.input.charAt(q.index+q[0].length))?"":"(?:)"):q[0]});XRegExp.addToken(/\[\^?]/,function(p){return p[0]==="[]"?"\\b\\B":"[\\s\\S]"});XRegExp.addToken(/^\(\?([imsx]+)\)/,function(p){this.setFlag(p[1]);return""});XRegExp.addToken(/(?:\s+|#.*)+/,function(p){return m.test.call(n,p.input.slice(p.index+p[0].length))?"":"(?:)"},XRegExp.OUTSIDE_CLASS,function(){return this.hasFlag("x")});XRegExp.addToken(/\./,function(){return"[\\s\\S]"},XRegExp.OUTSIDE_CLASS,function(){return this.hasFlag("s")})})();
</script><script type="text/javascript">/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
//
// Begin anonymous function. This is used to contain local scope variables without polutting global scope.
//
var SyntaxHighlighter = function() { 

// CommonJS
if (typeof(require) != 'undefined' && typeof(XRegExp) == 'undefined')
{
	XRegExp = require('XRegExp').XRegExp;
}

// Shortcut object which will be assigned to the SyntaxHighlighter variable.
// This is a shorthand for local reference in order to avoid long namespace 
// references to SyntaxHighlighter.whatever...
var sh = {
	defaults : {
		/** Additional CSS class names to be added to highlighter elements. */
		'class-name' : '',
		
		/** First line number. */
		'first-line' : 1,
		
		/**
		 * Pads line numbers. Possible values are:
		 *
		 *   false - don't pad line numbers.
		 *   true  - automaticaly pad numbers with minimum required number of leading zeroes.
		 *   [int] - length up to which pad line numbers.
		 */
		'pad-line-numbers' : false,
		
		/** Lines to highlight. */
		'highlight' : null,
		
		/** Title to be displayed above the code block. */
		'title' : null,
		
		/** Enables or disables smart tabs. */
		'smart-tabs' : true,
		
		/** Gets or sets tab size. */
		'tab-size' : 4,
		
		/** Enables or disables gutter. */
		'gutter' : true,
		
		/** Enables or disables toolbar. */
		'toolbar' : true,
		
		/** Enables quick code copy and paste from double click. */
		'quick-code' : true,
		
		/** Forces code view to be collapsed. */
		'collapse' : false,
		
		/** Enables or disables automatic links. */
		'auto-links' : true,
		
		/** Gets or sets light mode. Equavalent to turning off gutter and toolbar. */
		'light' : false,
		
		'html-script' : false
	},
	
	config : {
		space : '&nbsp;',
		
		/** Enables use of <SCRIPT type="syntaxhighlighter" /> tags. */
		useScriptTags : true,
		
		/** Blogger mode flag. */
		bloggerMode : false,
		
		stripBrs : false,
		
		/** Name of the tag that SyntaxHighlighter will automatically look for. */
		tagName : 'pre',
		
		strings : {
			expandSource : 'expand source',
			help : '?',
			alert: 'SyntaxHighlighter\n\n',
			noBrush : 'Can\'t find brush for: ',
			brushNotHtmlScript : 'Brush wasn\'t configured for html-script option: ',
			
			// this is populated by the build script
			aboutDialog : '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>About SyntaxHighlighter</title></head><body style="font-family:Geneva,Arial,Helvetica,sans-serif;background-color:#fff;color:#000;font-size:1em;text-align:center;"><div style="text-align:center;margin-top:1.5em;"><div style="font-size:xx-large;">SyntaxHighlighter</div><div style="font-size:.75em;margin-bottom:3em;"><div>version 3.0.83 (July 02 2010)</div><div><a href="http://alexgorbatchev.com/SyntaxHighlighter" target="_blank" style="color:#005896">http://alexgorbatchev.com/SyntaxHighlighter</a></div><div>JavaScript code syntax highlighter.</div><div>Copyright 2004-2010 Alex Gorbatchev.</div></div><div>If you like this script, please <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=2930402" style="color:#005896">donate</a> to <br/>keep development active!</div></div></body></html>'
		}
	},
	
	/** Internal 'global' variables. */
	vars : {
		discoveredBrushes : null,
		highlighters : {}
	},
	
	/** This object is populated by user included external brush files. */
	brushes : {},

	/** Common regular expressions. */
	regexLib : {
		multiLineCComments			: /\/\*[\s\S]*?\*\//gm,
		singleLineCComments			: /\/\/.*$/gm,
		singleLinePerlComments		: /#.*$/gm,
		doubleQuotedString			: /"([^\\"\n]|\\.)*"/g,
		singleQuotedString			: /'([^\\'\n]|\\.)*'/g,
		multiLineDoubleQuotedString	: new XRegExp('"([^\\\\"]|\\\\.)*"', 'gs'),
		multiLineSingleQuotedString	: new XRegExp("'([^\\\\']|\\\\.)*'", 'gs'),
		xmlComments					: /(&lt;|<)!--[\s\S]*?--(&gt;|>)/gm,
		url							: /\w+:\/\/[\w-.\/?%&=:@;]*/g,
		
		/** <?= ?> tags. */
		phpScriptTags 				: { left: /(&lt;|<)\?=?/g, right: /\?(&gt;|>)/g },
		
		/** <%= %> tags. */
		aspScriptTags				: { left: /(&lt;|<)%=?/g, right: /%(&gt;|>)/g },
		
		scriptScriptTags			: { left: /(&lt;|<)\s*script.*?(&gt;|>)/gi, right: /(&lt;|<)\/\s*script\s*(&gt;|>)/gi }
	},

	toolbar: {
		/**
		 * Generates HTML markup for the toolbar.
		 * @param {Highlighter} highlighter Highlighter instance.
		 * @return {String} Returns HTML markup.
		 */
		getHtml: function(highlighter)
		{
			var html = '<div class="toolbar">',
				items = sh.toolbar.items,
				list = items.list
				;
			
			function defaultGetHtml(highlighter, name)
			{
				return sh.toolbar.getButtonHtml(highlighter, name, sh.config.strings[name]);
			};
			
			for (var i = 0; i < list.length; i++)
				html += (items[list[i]].getHtml || defaultGetHtml)(highlighter, list[i]);
			
			html += '</div>';
			
			return html;
		},
		
		/**
		 * Generates HTML markup for a regular button in the toolbar.
		 * @param {Highlighter} highlighter Highlighter instance.
		 * @param {String} commandName		Command name that would be executed.
		 * @param {String} label			Label text to display.
		 * @return {String}					Returns HTML markup.
		 */
		getButtonHtml: function(highlighter, commandName, label)
		{
			return '<span><a href="#" class="toolbar_item'
				+ ' command_' + commandName
				+ ' ' + commandName
				+ '">' + label + '</a></span>'
				;
		},
		
		/**
		 * Event handler for a toolbar anchor.
		 */
		handler: function(e)
		{
			var target = e.target,
				className = target.className || ''
				;

			function getValue(name)
			{
				var r = new RegExp(name + '_(\\w+)'),
					match = r.exec(className)
					;

				return match ? match[1] : null;
			};
			
			var highlighter = getHighlighterById(findParentElement(target, '.syntaxhighlighter').id),
				commandName = getValue('command')
				;
			
			// execute the toolbar command
			if (highlighter && commandName)
				sh.toolbar.items[commandName].execute(highlighter);

			// disable default A click behaviour
			e.preventDefault();
		},
		
		/** Collection of toolbar items. */
		items : {
			// Ordered lis of items in the toolbar. Can't expect `for (var n in items)` to be consistent.
			list: ['expandSource', 'help'],

			expandSource: {
				getHtml: function(highlighter)
				{
					if (highlighter.getParam('collapse') != true)
						return '';
						
					var title = highlighter.getParam('title');
					return sh.toolbar.getButtonHtml(highlighter, 'expandSource', title ? title : sh.config.strings.expandSource);
				},
			
				execute: function(highlighter)
				{
					var div = getHighlighterDivById(highlighter.id);
					removeClass(div, 'collapsed');
				}
			},

			/** Command to display the about dialog window. */
			help: {
				execute: function(highlighter)
				{	
					var wnd = popup('', '_blank', 500, 250, 'scrollbars=0'),
						doc = wnd.document
						;
					
					doc.write(sh.config.strings.aboutDialog);
					doc.close();
					wnd.focus();
				}
			}
		}
	},

	/**
	 * Finds all elements on the page which should be processes by SyntaxHighlighter.
	 *
	 * @param {Object} globalParams		Optional parameters which override element's 
	 * 									parameters. Only used if element is specified.
	 * 
	 * @param {Object} element	Optional element to highlight. If none is
	 * 							provided, all elements in the current document 
	 * 							are returned which qualify.
	 *
	 * @return {Array}	Returns list of <code>{ target: DOMElement, params: Object }</code> objects.
	 */
	findElements: function(globalParams, element)
	{
		var elements = element ? [element] : toArray(document.getElementsByTagName(sh.config.tagName)), 
			conf = sh.config,
			result = []
			;

		// support for <SCRIPT TYPE="syntaxhighlighter" /> feature
		if (conf.useScriptTags)
			elements = elements.concat(getSyntaxHighlighterScriptTags());

		if (elements.length === 0) 
			return result;
	
		for (var i = 0; i < elements.length; i++) 
		{
			var item = {
				target: elements[i], 
				// local params take precedence over globals
				params: merge(globalParams, parseParams(elements[i].className))
			};

			if (item.params['brush'] == null)
				continue;
				
			result.push(item);
		}
		
		return result;
	},

	/**
	 * Shorthand to highlight all elements on the page that are marked as 
	 * SyntaxHighlighter source code.
	 * 
	 * @param {Object} globalParams		Optional parameters which override element's 
	 * 									parameters. Only used if element is specified.
	 * 
	 * @param {Object} element	Optional element to highlight. If none is
	 * 							provided, all elements in the current document 
	 * 							are highlighted.
	 */ 
	highlight: function(globalParams, element)
	{
		var elements = this.findElements(globalParams, element),
			propertyName = 'innerHTML', 
			highlighter = null,
			conf = sh.config
			;

		if (elements.length === 0) 
			return;
	
		for (var i = 0; i < elements.length; i++) 
		{
			var element = elements[i],
				target = element.target,
				params = element.params,
				brushName = params.brush,
				code
				;

			if (brushName == null)
				continue;

			// Instantiate a brush
			if (params['html-script'] == 'true' || sh.defaults['html-script'] == true) 
			{
				highlighter = new sh.HtmlScript(brushName);
				brushName = 'htmlscript';
			}
			else
			{
				var brush = findBrush(brushName);
				
				if (brush)
					highlighter = new brush();
				else
					continue;
			}
			
			code = target[propertyName];
			
			// remove CDATA from <SCRIPT/> tags if it's present
			if (conf.useScriptTags)
				code = stripCData(code);
				
			// Inject title if the attribute is present
			if ((target.title || '') != '')
				params.title = target.title;
				
			params['brush'] = brushName;
			highlighter.init(params);
			element = highlighter.getDiv(code);
			
			// carry over ID
			if ((target.id || '') != '')
				element.id = target.id;
			
			target.parentNode.replaceChild(element, target);
		}
	},

	/**
	 * Main entry point for the SyntaxHighlighter.
	 * @param {Object} params Optional params to apply to all highlighted elements.
	 */
	all: function(params)
	{
		attachEvent(
			window,
			'load',
			function() { sh.highlight(params); }
		);
	}
}; // end of sh

sh['all']			= sh.all;
sh['highlight']		= sh.highlight;

/**
 * Checks if target DOM elements has specified CSS class.
 * @param {DOMElement} target Target DOM element to check.
 * @param {String} className Name of the CSS class to check for.
 * @return {Boolean} Returns true if class name is present, false otherwise.
 */
function hasClass(target, className)
{
	return target.className.indexOf(className) != -1;
};

/**
 * Adds CSS class name to the target DOM element.
 * @param {DOMElement} target Target DOM element.
 * @param {String} className New CSS class to add.
 */
function addClass(target, className)
{
	if (!hasClass(target, className))
		target.className += ' ' + className;
};

/**
 * Removes CSS class name from the target DOM element.
 * @param {DOMElement} target Target DOM element.
 * @param {String} className CSS class to remove.
 */
function removeClass(target, className)
{
	target.className = target.className.replace(className, '');
};

/**
 * Converts the source to array object. Mostly used for function arguments and 
 * lists returned by getElementsByTagName() which aren't Array objects.
 * @param {List} source Source list.
 * @return {Array} Returns array.
 */
function toArray(source)
{
	var result = [];
	
	for (var i = 0; i < source.length; i++) 
		result.push(source[i]);
		
	return result;
};

/**
 * Splits block of text into lines.
 * @param {String} block Block of text.
 * @return {Array} Returns array of lines.
 */
function splitLines(block)
{
	return block.split('\n');
}

/**
 * Generates HTML ID for the highlighter.
 * @param {String} highlighterId Highlighter ID.
 * @return {String} Returns HTML ID.
 */
function getHighlighterId(id)
{
	var prefix = 'highlighter_';
	return id.indexOf(prefix) == 0 ? id : prefix + id;
};

/**
 * Finds Highlighter instance by ID.
 * @param {String} highlighterId Highlighter ID.
 * @return {Highlighter} Returns instance of the highlighter.
 */
function getHighlighterById(id)
{
	return sh.vars.highlighters[getHighlighterId(id)];
};

/**
 * Finds highlighter's DIV container.
 * @param {String} highlighterId Highlighter ID.
 * @return {Element} Returns highlighter's DIV element.
 */
function getHighlighterDivById(id)
{
	return document.getElementById(getHighlighterId(id));
};

/**
 * Stores highlighter so that getHighlighterById() can do its thing. Each
 * highlighter must call this method to preserve itself.
 * @param {Highilghter} highlighter Highlighter instance.
 */
function storeHighlighter(highlighter)
{
	sh.vars.highlighters[getHighlighterId(highlighter.id)] = highlighter;
};

/**
 * Looks for a child or parent node which has specified classname.
 * Equivalent to jQuery's $(container).find(".className")
 * @param {Element} target Target element.
 * @param {String} search Class name or node name to look for.
 * @param {Boolean} reverse If set to true, will go up the node tree instead of down.
 * @return {Element} Returns found child or parent element on null.
 */
function findElement(target, search, reverse /* optional */)
{
	if (target == null)
		return null;
		
	var nodes			= reverse != true ? target.childNodes : [ target.parentNode ],
		propertyToFind	= { '#' : 'id', '.' : 'className' }[search.substr(0, 1)] || 'nodeName',
		expectedValue,
		found
		;

	expectedValue = propertyToFind != 'nodeName'
		? search.substr(1)
		: search.toUpperCase()
		;
		
	// main return of the found node
	if ((target[propertyToFind] || '').indexOf(expectedValue) != -1)
		return target;
	
	for (var i = 0; nodes && i < nodes.length && found == null; i++)
		found = findElement(nodes[i], search, reverse);
	
	return found;
};

/**
 * Looks for a parent node which has specified classname.
 * This is an alias to <code>findElement(container, className, true)</code>.
 * @param {Element} target Target element.
 * @param {String} className Class name to look for.
 * @return {Element} Returns found parent element on null.
 */
function findParentElement(target, className)
{
	return findElement(target, className, true);
};

/**
 * Finds an index of element in the array.
 * @ignore
 * @param {Object} searchElement
 * @param {Number} fromIndex
 * @return {Number} Returns index of element if found; -1 otherwise.
 */
function indexOf(array, searchElement, fromIndex)
{
	fromIndex = Math.max(fromIndex || 0, 0);

	for (var i = fromIndex; i < array.length; i++)
		if(array[i] == searchElement)
			return i;
	
	return -1;
};

/**
 * Generates a unique element ID.
 */
function guid(prefix)
{
	return (prefix || '') + Math.round(Math.random() * 1000000).toString();
};

/**
 * Merges two objects. Values from obj2 override values in obj1.
 * Function is NOT recursive and works only for one dimensional objects.
 * @param {Object} obj1 First object.
 * @param {Object} obj2 Second object.
 * @return {Object} Returns combination of both objects.
 */
function merge(obj1, obj2)
{
	var result = {}, name;

	for (name in obj1) 
		result[name] = obj1[name];
	
	for (name in obj2) 
		result[name] = obj2[name];
		
	return result;
};

/**
 * Attempts to convert string to boolean.
 * @param {String} value Input string.
 * @return {Boolean} Returns true if input was "true", false if input was "false" and value otherwise.
 */
function toBoolean(value)
{
	var result = { "true" : true, "false" : false }[value];
	return result == null ? value : result;
};

/**
 * Opens up a centered popup window.
 * @param {String} url		URL to open in the window.
 * @param {String} name		Popup name.
 * @param {int} width		Popup width.
 * @param {int} height		Popup height.
 * @param {String} options	window.open() options.
 * @return {Window}			Returns window instance.
 */
function popup(url, name, width, height, options)
{
	var x = (screen.width - width) / 2,
		y = (screen.height - height) / 2
		;
		
	options +=	', left=' + x + 
				', top=' + y +
				', width=' + width +
				', height=' + height
		;
	options = options.replace(/^,/, '');

	var win = window.open(url, name, options);
	win.focus();
	return win;
};

/**
 * Adds event handler to the target object.
 * @param {Object} obj		Target object.
 * @param {String} type		Name of the event.
 * @param {Function} func	Handling function.
 */
function attachEvent(obj, type, func, scope)
{
	function handler(e)
	{
		e = e || window.event;
		
		if (!e.target)
		{
			e.target = e.srcElement;
			e.preventDefault = function()
			{
				this.returnValue = false;
			};
		}
			
		func.call(scope || window, e);
	};
	
	if (obj.attachEvent) 
	{
		obj.attachEvent('on' + type, handler);
	}
	else 
	{
		obj.addEventListener(type, handler, false);
	}
};

/**
 * Displays an alert.
 * @param {String} str String to display.
 */
function alert(str)
{
	window.alert(sh.config.strings.alert + str);
};

/**
 * Finds a brush by its alias.
 *
 * @param {String} alias		Brush alias.
 * @param {Boolean} showAlert	Suppresses the alert if false.
 * @return {Brush}				Returns bursh constructor if found, null otherwise.
 */
function findBrush(alias, showAlert)
{
	var brushes = sh.vars.discoveredBrushes,
		result = null
		;
	
	if (brushes == null) 
	{
		brushes = {};
		
		// Find all brushes
		for (var brush in sh.brushes) 
		{
			var info = sh.brushes[brush],
				aliases = info.aliases
				;
			
			if (aliases == null) 
				continue;
			
			// keep the brush name
			info.brushName = brush.toLowerCase();
			
			for (var i = 0; i < aliases.length; i++) 
				brushes[aliases[i]] = brush;
		}
		
		sh.vars.discoveredBrushes = brushes;
	}
	
	result = sh.brushes[brushes[alias]];

	if (result == null && showAlert != false)
		alert(sh.config.strings.noBrush + alias);
	
	return result;
};

/**
 * Executes a callback on each line and replaces each line with result from the callback.
 * @param {Object} str			Input string.
 * @param {Object} callback		Callback function taking one string argument and returning a string.
 */
function eachLine(str, callback)
{
	var lines = splitLines(str);
	
	for (var i = 0; i < lines.length; i++)
		lines[i] = callback(lines[i], i);
		
	return lines.join('\n');
};

/**
 * This is a special trim which only removes first and last empty lines
 * and doesn't affect valid leading space on the first line.
 * 
 * @param {String} str   Input string
 * @return {String}      Returns string without empty first and last lines.
 */
function trimFirstAndLastLines(str)
{
	return str.replace(/^[ ]*[\n]+|[\n]*[ ]*$/g, '');
};

/**
 * Parses key/value pairs into hash object.
 * 
 * Understands the following formats:
 * - name: word;
 * - name: [word, word];
 * - name: "string";
 * - name: 'string';
 * 
 * For example:
 *   name1: value; name2: [value, value]; name3: 'value'
 *   
 * @param {String} str    Input string.
 * @return {Object}       Returns deserialized object.
 */
function parseParams(str)
{
	var match, 
		result = {},
		arrayRegex = new XRegExp("^\\[(?<values>(.*?))\\]$"),
		regex = new XRegExp(
			"(?<name>[\\w-]+)" +
			"\\s*:\\s*" +
			"(?<value>" +
				"[\\w-%#]+|" +		// word
				"\\[.*?\\]|" +		// [] array
				'".*?"|' +			// "" string
				"'.*?'" +			// '' string
			")\\s*;?",
			"g"
		)
		;

	while ((match = regex.exec(str)) != null) 
	{
		var value = match.value
			.replace(/^['"]|['"]$/g, '') // strip quotes from end of strings
			;
		
		// try to parse array value
		if (value != null && arrayRegex.test(value))
		{
			var m = arrayRegex.exec(value);
			value = m.values.length > 0 ? m.values.split(/\s*,\s*/) : [];
		}
		
		result[match.name] = value;
	}
	
	return result;
};

/**
 * Wraps each line of the string into <code/> tag with given style applied to it.
 * 
 * @param {String} str   Input string.
 * @param {String} css   Style name to apply to the string.
 * @return {String}      Returns input string with each line surrounded by <span/> tag.
 */
function wrapLinesWithCode(str, css)
{
	if (str == null || str.length == 0 || str == '\n') 
		return str;

	str = str.replace(/</g, '&lt;');

	// Replace two or more sequential spaces with &nbsp; leaving last space untouched.
	str = str.replace(/ {2,}/g, function(m)
	{
		var spaces = '';
		
		for (var i = 0; i < m.length - 1; i++)
			spaces += sh.config.space;
		
		return spaces + ' ';
	});

	// Split each line and apply <span class="...">...</span> to them so that
	// leading spaces aren't included.
	if (css != null) 
		str = eachLine(str, function(line)
		{
			if (line.length == 0) 
				return '';
			
			var spaces = '';
			
			line = line.replace(/^(&nbsp;| )+/, function(s)
			{
				spaces = s;
				return '';
			});
			
			if (line.length == 0) 
				return spaces;
			
			return spaces + '<code class="' + css + '">' + line + '</code>';
		});

	return str;
};

/**
 * Pads number with zeros until it's length is the same as given length.
 * 
 * @param {Number} number	Number to pad.
 * @param {Number} length	Max string length with.
 * @return {String}			Returns a string padded with proper amount of '0'.
 */
function padNumber(number, length)
{
	var result = number.toString();
	
	while (result.length < length)
		result = '0' + result;
	
	return result;
};

/**
 * Replaces tabs with spaces.
 * 
 * @param {String} code		Source code.
 * @param {Number} tabSize	Size of the tab.
 * @return {String}			Returns code with all tabs replaces by spaces.
 */
function processTabs(code, tabSize)
{
	var tab = '';
	
	for (var i = 0; i < tabSize; i++)
		tab += ' ';

	return code.replace(/\t/g, tab);
};

/**
 * Replaces tabs with smart spaces.
 * 
 * @param {String} code    Code to fix the tabs in.
 * @param {Number} tabSize Number of spaces in a column.
 * @return {String}        Returns code with all tabs replaces with roper amount of spaces.
 */
function processSmartTabs(code, tabSize)
{
	var lines = splitLines(code),
		tab = '\t',
		spaces = ''
		;
	
	// Create a string with 1000 spaces to copy spaces from... 
	// It's assumed that there would be no indentation longer than that.
	for (var i = 0; i < 50; i++) 
		spaces += '                    '; // 20 spaces * 50
			
	// This function inserts specified amount of spaces in the string
	// where a tab is while removing that given tab.
	function insertSpaces(line, pos, count)
	{
		return line.substr(0, pos)
			+ spaces.substr(0, count)
			+ line.substr(pos + 1, line.length) // pos + 1 will get rid of the tab
			;
	};

	// Go through all the lines and do the 'smart tabs' magic.
	code = eachLine(code, function(line)
	{
		if (line.indexOf(tab) == -1) 
			return line;
		
		var pos = 0;
		
		while ((pos = line.indexOf(tab)) != -1) 
		{
			// This is pretty much all there is to the 'smart tabs' logic.
			// Based on the position within the line and size of a tab,
			// calculate the amount of spaces we need to insert.
			var spaces = tabSize - pos % tabSize;
			line = insertSpaces(line, pos, spaces);
		}
		
		return line;
	});
	
	return code;
};

/**
 * Performs various string fixes based on configuration.
 */
function fixInputString(str)
{
	var br = /<br\s*\/?>|&lt;br\s*\/?&gt;/gi;
	
	if (sh.config.bloggerMode == true)
		str = str.replace(br, '\n');

	if (sh.config.stripBrs == true)
		str = str.replace(br, '');
		
	return str;
};

/**
 * Removes all white space at the begining and end of a string.
 * 
 * @param {String} str   String to trim.
 * @return {String}      Returns string without leading and following white space characters.
 */
function trim(str)
{
	return str.replace(/^\s+|\s+$/g, '');
};

/**
 * Unindents a block of text by the lowest common indent amount.
 * @param {String} str   Text to unindent.
 * @return {String}      Returns unindented text block.
 */
function unindent(str)
{
	var lines = splitLines(fixInputString(str)),
		indents = new Array(),
		regex = /^\s*/,
		min = 1000
		;
	
	// go through every line and check for common number of indents
	for (var i = 0; i < lines.length && min > 0; i++) 
	{
		var line = lines[i];
		
		if (trim(line).length == 0) 
			continue;
		
		var matches = regex.exec(line);
		
		// In the event that just one line doesn't have leading white space
		// we can't unindent anything, so bail completely.
		if (matches == null) 
			return str;
			
		min = Math.min(matches[0].length, min);
	}
	
	// trim minimum common number of white space from the begining of every line
	if (min > 0) 
		for (var i = 0; i < lines.length; i++) 
			lines[i] = lines[i].substr(min);
	
	return lines.join('\n');
};

/**
 * Callback method for Array.sort() which sorts matches by
 * index position and then by length.
 * 
 * @param {Match} m1	Left object.
 * @param {Match} m2    Right object.
 * @return {Number}     Returns -1, 0 or -1 as a comparison result.
 */
function matchesSortCallback(m1, m2)
{
	// sort matches by index first
	if(m1.index < m2.index)
		return -1;
	else if(m1.index > m2.index)
		return 1;
	else
	{
		// if index is the same, sort by length
		if(m1.length < m2.length)
			return -1;
		else if(m1.length > m2.length)
			return 1;
	}
	
	return 0;
};

/**
 * Executes given regular expression on provided code and returns all
 * matches that are found.
 * 
 * @param {String} code    Code to execute regular expression on.
 * @param {Object} regex   Regular expression item info from <code>regexList</code> collection.
 * @return {Array}         Returns a list of Match objects.
 */ 
function getMatches(code, regexInfo)
{
	function defaultAdd(match, regexInfo)
	{
		return match[0];
	};
	
	var index = 0,
		match = null,
		matches = [],
		func = regexInfo.func ? regexInfo.func : defaultAdd
		;
	
	while((match = regexInfo.regex.exec(code)) != null)
	{
		var resultMatch = func(match, regexInfo);
		
		if (typeof(resultMatch) == 'string')
			resultMatch = [new sh.Match(resultMatch, match.index, regexInfo.css)];

		matches = matches.concat(resultMatch);
	}
	
	return matches;
};

/**
 * Turns all URLs in the code into <a/> tags.
 * @param {String} code Input code.
 * @return {String} Returns code with </a> tags.
 */
function processUrls(code)
{
	var gt = /(.*)((&gt;|&lt;).*)/;
	
	return code.replace(sh.regexLib.url, function(m)
	{
		var suffix = '',
			match = null
			;
		
		// We include &lt; and &gt; in the URL for the common cases like <http://google.com>
		// The problem is that they get transformed into &lt;http://google.com&gt;
		// Where as &gt; easily looks like part of the URL string.
	
		if (match = gt.exec(m))
		{
			m = match[1];
			suffix = match[2];
		}
		
		return '<a href="' + m + '">' + m + '</a>' + suffix;
	});
};

/**
 * Finds all <SCRIPT TYPE="syntaxhighlighter" /> elementss.
 * @return {Array} Returns array of all found SyntaxHighlighter tags.
 */
function getSyntaxHighlighterScriptTags()
{
	var tags = document.getElementsByTagName('script'),
		result = []
		;
	
	for (var i = 0; i < tags.length; i++)
		if (tags[i].type == 'syntaxhighlighter')
			result.push(tags[i]);
			
	return result;
};

/**
 * Strips <![CDATA[]]> from <SCRIPT /> content because it should be used
 * there in most cases for XHTML compliance.
 * @param {String} original	Input code.
 * @return {String} Returns code without leading <![CDATA[]]> tags.
 */
function stripCData(original)
{
	var left = '<![CDATA[',
		right = ']]>',
		// for some reason IE inserts some leading blanks here
		copy = trim(original),
		changed = false,
		leftLength = left.length,
		rightLength = right.length
		;
	
	if (copy.indexOf(left) == 0)
	{
		copy = copy.substring(leftLength);
		changed = true;
	}
	
	var copyLength = copy.length;
	
	if (copy.indexOf(right) == copyLength - rightLength)
	{
		copy = copy.substring(0, copyLength - rightLength);
		changed = true;
	}
	
	return changed ? copy : original;
};


/**
 * Quick code mouse double click handler.
 */
function quickCodeHandler(e)
{
	var target = e.target,
		highlighterDiv = findParentElement(target, '.syntaxhighlighter'),
		container = findParentElement(target, '.container'),
		textarea = document.createElement('textarea'),
		highlighter
		;

	if (!container || !highlighterDiv || findElement(container, 'textarea'))
		return;

	highlighter = getHighlighterById(highlighterDiv.id);
	
	// add source class name
	addClass(highlighterDiv, 'source');

	// Have to go over each line and grab it's text, can't just do it on the
	// container because Firefox loses all \n where as Webkit doesn't.
	var lines = container.childNodes,
		code = []
		;
	
	for (var i = 0; i < lines.length; i++)
		code.push(lines[i].innerText || lines[i].textContent);
	
	// using \r instead of \r or \r\n makes this work equally well on IE, FF and Webkit
	code = code.join('\r');
	
	// inject <textarea/> tag
	textarea.appendChild(document.createTextNode(code));
	container.appendChild(textarea);
	
	// preselect all text
	textarea.focus();
	textarea.select();
	
	// set up handler for lost focus
	attachEvent(textarea, 'blur', function(e)
	{
		textarea.parentNode.removeChild(textarea);
		removeClass(highlighterDiv, 'source');
	});
};

/**
 * Match object.
 */
sh.Match = function(value, index, css)
{
	this.value = value;
	this.index = index;
	this.length = value.length;
	this.css = css;
	this.brushName = null;
};

sh.Match.prototype.toString = function()
{
	return this.value;
};

/**
 * Simulates HTML code with a scripting language embedded.
 * 
 * @param {String} scriptBrushName Brush name of the scripting language.
 */
sh.HtmlScript = function(scriptBrushName)
{
	var brushClass = findBrush(scriptBrushName),
		scriptBrush,
		xmlBrush = new sh.brushes.Xml(),
		bracketsRegex = null,
		ref = this,
		methodsToExpose = 'getDiv getHtml init'.split(' ')
		;

	if (brushClass == null)
		return;
	
	scriptBrush = new brushClass();
	
	for(var i = 0; i < methodsToExpose.length; i++)
		// make a closure so we don't lose the name after i changes
		(function() {
			var name = methodsToExpose[i];
			
			ref[name] = function()
			{
				return xmlBrush[name].apply(xmlBrush, arguments);
			};
		})();
	
	if (scriptBrush.htmlScript == null)
	{
		alert(sh.config.strings.brushNotHtmlScript + scriptBrushName);
		return;
	}
	
	xmlBrush.regexList.push(
		{ regex: scriptBrush.htmlScript.code, func: process }
	);
	
	function offsetMatches(matches, offset)
	{
		for (var j = 0; j < matches.length; j++) 
			matches[j].index += offset;
	}
	
	function process(match, info)
	{
		var code = match.code,
			matches = [],
			regexList = scriptBrush.regexList,
			offset = match.index + match.left.length,
			htmlScript = scriptBrush.htmlScript,
			result
			;

		// add all matches from the code
		for (var i = 0; i < regexList.length; i++)
		{
			result = getMatches(code, regexList[i]);
			offsetMatches(result, offset);
			matches = matches.concat(result);
		}
		
		// add left script bracket
		if (htmlScript.left != null && match.left != null)
		{
			result = getMatches(match.left, htmlScript.left);
			offsetMatches(result, match.index);
			matches = matches.concat(result);
		}
		
		// add right script bracket
		if (htmlScript.right != null && match.right != null)
		{
			result = getMatches(match.right, htmlScript.right);
			offsetMatches(result, match.index + match[0].lastIndexOf(match.right));
			matches = matches.concat(result);
		}
		
		for (var j = 0; j < matches.length; j++)
			matches[j].brushName = brushClass.brushName;
			
		return matches;
	}
};

/**
 * Main Highlither class.
 * @constructor
 */
sh.Highlighter = function()
{
	// not putting any code in here because of the prototype inheritance
};

sh.Highlighter.prototype = {
	/**
	 * Returns value of the parameter passed to the highlighter.
	 * @param {String} name				Name of the parameter.
	 * @param {Object} defaultValue		Default value.
	 * @return {Object}					Returns found value or default value otherwise.
	 */
	getParam: function(name, defaultValue)
	{
		var result = this.params[name];
		return toBoolean(result == null ? defaultValue : result);
	},
	
	/**
	 * Shortcut to document.createElement().
	 * @param {String} name		Name of the element to create (DIV, A, etc).
	 * @return {HTMLElement}	Returns new HTML element.
	 */
	create: function(name)
	{
		return document.createElement(name);
	},
	
	/**
	 * Applies all regular expression to the code and stores all found
	 * matches in the `this.matches` array.
	 * @param {Array} regexList		List of regular expressions.
	 * @param {String} code			Source code.
	 * @return {Array}				Returns list of matches.
	 */
	findMatches: function(regexList, code)
	{
		var result = [];
		
		if (regexList != null)
			for (var i = 0; i < regexList.length; i++) 
				// BUG: length returns len+1 for array if methods added to prototype chain (oising@gmail.com)
				if (typeof (regexList[i]) == "object")
					result = result.concat(getMatches(code, regexList[i]));
		
		// sort and remove nested the matches
		return this.removeNestedMatches(result.sort(matchesSortCallback));
	},
	
	/**
	 * Checks to see if any of the matches are inside of other matches. 
	 * This process would get rid of highligted strings inside comments, 
	 * keywords inside strings and so on.
	 */
	removeNestedMatches: function(matches)
	{
		// Optimized by Jose Prado (http://joseprado.com)
		for (var i = 0; i < matches.length; i++) 
		{ 
			if (matches[i] === null)
				continue;
			
			var itemI = matches[i],
				itemIEndPos = itemI.index + itemI.length
				;
			
			for (var j = i + 1; j < matches.length && matches[i] !== null; j++) 
			{
				var itemJ = matches[j];
				
				if (itemJ === null) 
					continue;
				else if (itemJ.index > itemIEndPos) 
					break;
				else if (itemJ.index == itemI.index && itemJ.length > itemI.length)
					matches[i] = null;
				else if (itemJ.index >= itemI.index && itemJ.index < itemIEndPos) 
					matches[j] = null;
			}
		}
		
		return matches;
	},
	
	/**
	 * Creates an array containing integer line numbers starting from the 'first-line' param.
	 * @return {Array} Returns array of integers.
	 */
	figureOutLineNumbers: function(code)
	{
		var lines = [],
			firstLine = parseInt(this.getParam('first-line'))
			;
		
		eachLine(code, function(line, index)
		{
			lines.push(index + firstLine);
		});
		
		return lines;
	},
	
	/**
	 * Determines if specified line number is in the highlighted list.
	 */
	isLineHighlighted: function(lineNumber)
	{
		var list = this.getParam('highlight', []);
		
		if (typeof(list) != 'object' && list.push == null) 
			list = [ list ];
		
		return indexOf(list, lineNumber.toString()) != -1;
	},
	
	/**
	 * Generates HTML markup for a single line of code while determining alternating line style.
	 * @param {Integer} lineNumber	Line number.
	 * @param {String} code Line	HTML markup.
	 * @return {String}				Returns HTML markup.
	 */
	getLineHtml: function(lineIndex, lineNumber, code)
	{
		var classes = [
			'line',
			'number' + lineNumber,
			'index' + lineIndex,
			'alt' + (lineNumber % 2 == 0 ? 1 : 2).toString()
		];
		
		if (this.isLineHighlighted(lineNumber))
		 	classes.push('highlighted');
		
		if (lineNumber == 0)
			classes.push('break');
			
		return '<div class="' + classes.join(' ') + '">' + code + '</div>';
	},
	
	/**
	 * Generates HTML markup for line number column.
	 * @param {String} code			Complete code HTML markup.
	 * @param {Array} lineNumbers	Calculated line numbers.
	 * @return {String}				Returns HTML markup.
	 */
	getLineNumbersHtml: function(code, lineNumbers)
	{
		var html = '',
			count = splitLines(code).length,
			firstLine = parseInt(this.getParam('first-line')),
			pad = this.getParam('pad-line-numbers')
			;
		
		if (pad == true)
			pad = (firstLine + count - 1).toString().length;
		else if (isNaN(pad) == true)
			pad = 0;
			
		for (var i = 0; i < count; i++)
		{
			var lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i,
				code = lineNumber == 0 ? sh.config.space : padNumber(lineNumber, pad)
				;
				
			html += this.getLineHtml(i, lineNumber, code);
		}
		
		return html;
	},
	
	/**
	 * Splits block of text into individual DIV lines.
	 * @param {String} code			Code to highlight.
	 * @param {Array} lineNumbers	Calculated line numbers.
	 * @return {String}				Returns highlighted code in HTML form.
	 */
	getCodeLinesHtml: function(html, lineNumbers)
	{
		html = trim(html);
		
		var lines = splitLines(html),
			padLength = this.getParam('pad-line-numbers'),
			firstLine = parseInt(this.getParam('first-line')),
			html = '',
			brushName = this.getParam('brush')
			;

		for (var i = 0; i < lines.length; i++)
		{
			var line = lines[i],
				indent = /^(&nbsp;|\s)+/.exec(line),
				spaces = null,
				lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i;
				;

			if (indent != null)
			{
				spaces = indent[0].toString();
				line = line.substr(spaces.length);
				spaces = spaces.replace(' ', sh.config.space);
			}

			line = trim(line);
			
			if (line.length == 0)
				line = sh.config.space;
			
			html += this.getLineHtml(
				i,
				lineNumber, 
				(spaces != null ? '<code class="' + brushName + ' spaces">' + spaces + '</code>' : '') + line
			);
		}
		
		return html;
	},
	
	/**
	 * Returns HTML for the table title or empty string if title is null.
	 */
	getTitleHtml: function(title)
	{
		return title ? '<caption>' + title + '</caption>' : '';
	},
	
	/**
	 * Finds all matches in the source code.
	 * @param {String} code		Source code to process matches in.
	 * @param {Array} matches	Discovered regex matches.
	 * @return {String} Returns formatted HTML with processed mathes.
	 */
	getMatchesHtml: function(code, matches)
	{
		var pos = 0, 
			result = '',
			brushName = this.getParam('brush', '')
			;
		
		function getBrushNameCss(match)
		{
			var result = match ? (match.brushName || brushName) : brushName;
			return result ? result + ' ' : '';
		};
		
		// Finally, go through the final list of matches and pull the all
		// together adding everything in between that isn't a match.
		for (var i = 0; i < matches.length; i++) 
		{
			var match = matches[i],
				matchBrushName
				;
			
			if (match === null || match.length === 0) 
				continue;
			
			matchBrushName = getBrushNameCss(match);
			
			result += wrapLinesWithCode(code.substr(pos, match.index - pos), matchBrushName + 'plain')
					+ wrapLinesWithCode(match.value, matchBrushName + match.css)
					;

			pos = match.index + match.length + (match.offset || 0);
		}

		// don't forget to add whatever's remaining in the string
		result += wrapLinesWithCode(code.substr(pos), getBrushNameCss() + 'plain');

		return result;
	},
	
	/**
	 * Generates HTML markup for the whole syntax highlighter.
	 * @param {String} code Source code.
	 * @return {String} Returns HTML markup.
	 */
	getHtml: function(code)
	{
		var html = '',
			classes = [ 'syntaxhighlighter' ],
			tabSize,
			matches,
			lineNumbers
			;
		
		// process light mode
		if (this.getParam('light') == true)
			this.params.toolbar = this.params.gutter = false;

		className = 'syntaxhighlighter';

		if (this.getParam('collapse') == true)
			classes.push('collapsed');
		
		if ((gutter = this.getParam('gutter')) == false)
			classes.push('nogutter');

		// add custom user style name
		classes.push(this.getParam('class-name'));

		// add brush alias to the class name for custom CSS
		classes.push(this.getParam('brush'));

		code = trimFirstAndLastLines(code)
			.replace(/\r/g, ' ') // IE lets these buggers through
			;

		tabSize = this.getParam('tab-size');

		// replace tabs with spaces
		code = this.getParam('smart-tabs') == true
			? processSmartTabs(code, tabSize)
			: processTabs(code, tabSize)
			;

		// unindent code by the common indentation
		code = unindent(code);

		if (gutter)
			lineNumbers = this.figureOutLineNumbers(code);
		
		// find matches in the code using brushes regex list
		matches = this.findMatches(this.regexList, code);
		// processes found matches into the html
		html = this.getMatchesHtml(code, matches);
		// finally, split all lines so that they wrap well
		html = this.getCodeLinesHtml(html, lineNumbers);

		// finally, process the links
		if (this.getParam('auto-links'))
			html = processUrls(html);
		
		if (typeof(navigator) != 'undefined' && navigator.userAgent && navigator.userAgent.match(/MSIE/))
			classes.push('ie');
		
		html = 
			'<div id="' + getHighlighterId(this.id) + '" class="' + classes.join(' ') + '">'
				+ (this.getParam('toolbar') ? sh.toolbar.getHtml(this) : '')
				+ '<table border="0" cellpadding="0" cellspacing="0">'
					+ this.getTitleHtml(this.getParam('title'))
					+ '<tbody>'
						+ '<tr>'
							+ (gutter ? '<td class="gutter">' + this.getLineNumbersHtml(code) + '</td>' : '')
							+ '<td class="code">'
								+ '<div class="container">'
									+ html
								+ '</div>'
							+ '</td>'
						+ '</tr>'
					+ '</tbody>'
				+ '</table>'
			+ '</div>'
			;
			
		return html;
	},
	
	/**
	 * Highlights the code and returns complete HTML.
	 * @param {String} code     Code to highlight.
	 * @return {Element}        Returns container DIV element with all markup.
	 */
	getDiv: function(code)
	{
		if (code === null) 
			code = '';
		
		this.code = code;

		var div = this.create('div');

		// create main HTML
		div.innerHTML = this.getHtml(code);
		
		// set up click handlers
		if (this.getParam('toolbar'))
			attachEvent(findElement(div, '.toolbar'), 'click', sh.toolbar.handler);
		
		if (this.getParam('quick-code'))
			attachEvent(findElement(div, '.code'), 'dblclick', quickCodeHandler);
		
		return div;
	},
	
	/**
	 * Initializes the highlighter/brush.
	 *
	 * Constructor isn't used for initialization so that nothing executes during necessary
	 * `new SyntaxHighlighter.Highlighter()` call when setting up brush inheritence.
	 *
	 * @param {Hash} params Highlighter parameters.
	 */
	init: function(params)
	{
		this.id = guid();
		
		// register this instance in the highlighters list
		storeHighlighter(this);
		
		// local params take precedence over defaults
		this.params = merge(sh.defaults, params || {})
		
		// process light mode
		if (this.getParam('light') == true)
			this.params.toolbar = this.params.gutter = false;
	},
	
	/**
	 * Converts space separated list of keywords into a regular expression string.
	 * @param {String} str    Space separated keywords.
	 * @return {String}       Returns regular expression string.
	 */
	getKeywords: function(str)
	{
		str = str
			.replace(/^\s+|\s+$/g, '')
			.replace(/\s+/g, '|')
			;
		
		return '\\b(?:' + str + ')\\b';
	},
	
	/**
	 * Makes a brush compatible with the `html-script` functionality.
	 * @param {Object} regexGroup Object containing `left` and `right` regular expressions.
	 */
	forHtmlScript: function(regexGroup)
	{
		this.htmlScript = {
			left : { regex: regexGroup.left, css: 'script' },
			right : { regex: regexGroup.right, css: 'script' },
			code : new XRegExp(
				"(?<left>" + regexGroup.left.source + ")" +
				"(?<code>.*?)" +
				"(?<right>" + regexGroup.right.source + ")",
				"sgi"
				)
		};
	}
}; // end of Highlighter

return sh;
}(); // end of anonymous function

// CommonJS
typeof(exports) != 'undefined' ? exports['SyntaxHighlighter'] = SyntaxHighlighter : null;
</script><script type="text/javascript">// (inc clojure-brush) ;; an improved SyntaxHighlighter brush for clojure
//
// Copyright (C) 2011 Andrew Brehaut
//
// Distributed under the Eclipse Public License, the same as Clojure.
//
// https://github.com/brehaut/inc-clojure-brush
//
// Written by Andrew Brehaut
// V0.9.1, November 2011

if (typeof net == "undefined") net = {};
if (!(net.brehaut)) net.brehaut = {};

net.brehaut.ClojureTools = (function (SH) {
  "use strict";
  // utiliies
  if (!Object.create) Object.create = function object(o) {
    function F() {};
    F.prototype = o;  
    return new F();
  };
        
  // data
  
  function Token(value, index, tag, length) {
    this.value = value;
    this.index = index;
    this.length = length || value.length;
    this.tag = tag;
    this.secondary_tags = {};
  }
  
  // null_token exists so that LispNodes that have not had a closing tag attached
  // can have a dummy token to simplify annotation
  var null_token = new Token("", -1, "null", -1);
  
  /* LispNodes are aggregate nodes for sexpressions. 
   *
   */
  function LispNode(tag, children, opening) {
    this.tag = tag;            // current metadata for syntax inference
    this.parent = null;        // the parent expression
    this.list = children;      // all the child forms in order
    this.opening = opening;    // the token that opens this form.
    this.closing = null_token; // the token that closes this form.
    this.meta = null;          // metadata nodes will be attached here if they are found
  }

  var null_lispnode = new LispNode("null", [], null_token);

  
  function PrefixNode(tag, token, attached_node) {
    this.tag = tag;
    this.token = token;
    this.attached_node = attached_node;
    this.parent = null;
  }

  
  
  // tokenize

  function tokenize(code) {
    var tokens = [];
    var tn = 0;
    
    var zero = "0".charCodeAt(0);
    var nine = "9".charCodeAt(0); 
    var lower_a = "a".charCodeAt(0);
    var lower_f = "f".charCodeAt(0);    
    var upper_a = "A".charCodeAt(0);
    var upper_f = "F".charCodeAt(0);
    
    var dispatch = false; // have we just seen a # character?
    
    // i tracks the start of the current window
    // extent is the window for slicing
    
    for (var i = 0, 
             extent = i, 
             j = code.length; 
             i < j && extent <= j;) {          
                
      var c = code[i];
      
      // we care about capturing the whole token when dispatch is used, so back up the
      // starting index by 1
      if (dispatch) i--; 
      
      switch (c) {
        // dispatch alters the value of the next thing read
        case "#":
          dispatch = true;
          i++;
          extent++;
          continue;
          
        case " ":    // ignore whitespace
        case "\t":
        case "\n":
        case "\r":
        case ",":   
          extent++
          break; 
          
        // simple terms
        case "^":
        case "`":
        case ")":
        case "[":
        case "]":
        case "}":
        case "@":
          tokens[tn++] = new Token(c, i, c, ++extent - i);
          break;
        
        case "'":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "#'" : "'", extent - i);
          break
        
        case "(":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, "(", extent - i);
          break;          
          
        case "{":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "#{" : "{", extent - i);
          break;  
        
        case "\\":
          if (code.slice(i + 1, i + 8) === "newline") {
            tokens[tn++] = new Token("\\newline", i, "value", 8);
            extent = i + 9; 
          }
          else if (code.slice(i + 1, i + 6) === "space") {
            tokens[tn++] = new Token("\\space", i, "value", 6);
            extent = i + 6;
          }
          else if (code.slice(i + 1, i + 4) === "tab") {
            tokens[tn++] = new Token("\\tab", i, "value", 4);
            extent = i + 5;
          } // work around fun bug with &,>,< in character literals
          else if (code.slice(i + 1, i + 6) === "&amp;") {
            tokens[tn++] = new Token("\\&amp;", i, "value", 6);
            extent = i + 6; 
          }
          else if (code.slice(i + 1, i + 5) === "&lt;") {
            tokens[tn++] = new Token("\\&lt;", i, "value", 5);
            extent = i + 5;
          }
          else if (code.slice(i + 1, i + 5) === "&gt;") {
            tokens[tn++] = new Token("\\&gt;", i, "value", 5);
            extent = i + 5;
          }
          
          else {
            extent += 2;
            tokens[tn++] = new Token(code.slice(i, extent), i, "value", 2);
          }
          break;
        
        case "~": // slice
          if (code[i + 1] === "@") {
            extent += 2;
            tokens[tn++] = new Token(code.slice(i, extent), i, "splice", 2);
          }
          else {
            tokens[tn++] = new Token(code.slice(i, ++extent), i, "unquote", 2);
          }
          break;
        
        // complicated terms
        case "\"": // strings and regexps
          for (extent++; extent <= j; extent++) {
            if (code[extent] === "\\") extent++;
            else if (code[extent] === "\"") break;
          }
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "regexp" : "string", extent - i);       
          break;
          
        case ";":
          for (; extent <= j && code[extent] !== "\n" && code[extent] !== "\r"; extent++);
          tokens[tn++] = new Token(code.slice(i, ++extent), i, "comments", extent - i);   
          break;
        
        case "+": // numbers; fall through to symbol for + and - not prefixing a number
        case "-":
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
        // todo: exponents, hex
        // http://my.safaribooksonline.com/9781449310387/14?reader=pf&readerfullscreen=&readerleftmenu=1
          var c2 = code.charCodeAt(i + 1);
          if (((c === "+" || c === "-") && (c2 >= zero && c2 <= nine)) // prefixes
              || (c !== "+" && c !== "-")) {
            if (c === "+" || c === "-") extent++; 
            for (; extent <= j; extent++) {
              var charCode = code.charCodeAt(extent);
              if (charCode < zero || charCode > nine) break;
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "r" || c === "R" || c === "/" || c === ".") // interstitial characters
                && (c2 >= zero && c2 <= nine)) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (charCode < zero || charCode > nine) break;
              }
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "x" || c === "X") && 
                ((c2 >= zero && c2 <= nine) 
                 || (c2 >= lower_a && c2 <= lower_f)
                 || (c2 >= upper_a && c2 <= upper_f))) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (((charCode >= zero && charCode <= nine) 
                    || (charCode >= lower_a && charCode <= lower_f)
                    || (charCode >= upper_a && charCode <= upper_f))) continue;
                break;
              }
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "e" || c === "E") 
                && (c2 >= zero && c2 <= nine)) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (charCode < zero || charCode > nine) break;
              }
            }
            
            c = code[extent];
            if (c === "N" || c === "M") extent++;

            tokens[tn++] = new Token(code.slice(i, extent), i, "value", extent - i);
            break;
          }

        case "_":
          if (dispatch && c === "_") {
            tokens[tn++] = new Token(code.slice(i, ++extent), i, "skip", extent - i);
            break;
          } // if not a skip, fall through to symbols
        
        // Allow just about any other symbol as a symbol. This is far more permissive than 
        // clojure actually allows, but should catch any weirdo crap that accidentally gets
        // into the code.
        default: 
          for (extent++; extent <= j; extent++) {
            switch (code[extent]) {
              case " ":
              case "\t":
              case "\n":
              case "\r":
              case "\\":
              case ",":
              case "{":
              case "}":
              case "(":
              case ")":
              case "[":
              case "]":
              case "^":
              case "`":
              case "@":   
                break;
              case ";":   
                // theres a weird bug via syntax highligher that gives us escaped entities.
                // need to watch out for these
                if (code.slice(extent-3, extent+1) === "&lt;"
                    ||code.slice(extent-3, extent+1) === "&gt;"
                    ||code.slice(extent-4, extent+1) === "&amp;") {
                  continue;
                }
                break;
              default:
                continue;
            }
            break;
          }
          
          var value = code.slice(i, extent);
          var tag = "symbol";
          if (value[0] == ":") {
            tag = "keyword";
          }
          else if (value === "true" || value === "false" || value === "nil") {
            tag = "value";
          }
          tokens[tn++] = new Token(value, i, tag, extent - i);
      }
      
      dispatch = false;
      i = extent;
    } 

    return tokens;
  }


  function build_tree(tokens) {
    var toplevel = {
      list: [], 
      tag: "toplevel", 
      parent: null, 
      opening: null,
      closing: null,
      depth: -1
    };
    
    // loop variables hoisted out as semi globals to track position in token stream
    var i = -1;
    var j = tokens.length;
    
    function parse_one(t) {
      // ignore special tokens and forms that dont belong in the tree
      for (; t && (t.tag === "comments" || t.tag === "invalid" || t.tag == "skip") && i < j; ) {
        if (t.tag === "skip") {
          t.tag = "preprocessor";
          annotate_comment(parse_one(tokens[++i]));
        }
        t = tokens[++i];
      }
      
      if (!t) return {}; // hackity hack
      
      switch (t.tag) {
        case "{":
          return build_aggregate(new LispNode("map", [], t), "}");
        case "(":
          return build_aggregate(new LispNode("list", [], t), ")");
        case "#{":
          return build_aggregate(new LispNode("set", [], t), "}");
        case "[":
          return build_aggregate(new LispNode("vector", [], t), "]");
        case "'":
          return new PrefixNode("quote", t, parse_one(tokens[++i]));
        case "#'":
          return new PrefixNode("varquote", t, parse_one(tokens[++i]));  
        case "@":
          return new PrefixNode("deref", t, parse_one(tokens[++i]));  
        case "`":
          return new PrefixNode("quasiquote", t, parse_one(tokens[++i]));  
        case "unquote":
          return new PrefixNode("unquote", t, parse_one(tokens[++i]));
        case "splice":
          return new PrefixNode("splice", t, parse_one(tokens[++i]));  
        case "^":
          t.tag = "meta";
          var meta = parse_one(tokens[++i]);
          var next = parse_one(tokens[++i]);
          next.meta = meta;
          return next;
      }
      
      return t;
    }
    
    // build_aggregate collects to ether sub forms for one aggregate for. 
    function build_aggregate(current, expected_closing) {
      for (i++; i < j; i++) {
        var t = tokens[i];

        if (t.tag === "}" || t.tag === ")" || t.tag === "]") {
          if (t.tag !== expected_closing) t.tag = "invalid";
          current.closing = t;
          if (expected_closing) return current;
        }
        var node = parse_one(t);

        node.parent = current;
        current.list[current.list.length] = node;
      }
      
      return current;
    }
    
    build_aggregate(toplevel, null);
    
    return toplevel;
  }

  // annotation rules to apply to a form based on its head

  var show_locals = true;  // HACK. would rather not use a (semi)-global.

  /* annotate_comment is a special case annotation. 
   * in addition to its role in styling specific forms, it is called by parse_one to
   * ignore any forms skipped with #_
   */ 
  function annotate_comment(exp) {
    exp.tag = "comments";

    if (exp.list) {
      exp.opening.tag = "comments";
      exp.closing.tag = "comments";
    
      for (var i = 0; i < exp.list.length; i++) {
        var child = exp.list[i];
        if (child.list) {
          annotate_comment(child);
        }
        if (child.attached_node) {
          annotate_comment(child.attached_node);
        }
        else {
          child.tag = "comments";
        }
      }
    }
  }

  /* custom annotation rules are stored here */
  var annotation_rules = {};
  
  // this function is exposed to allow ad hoc extension of the customisation rules
  function register_annotation_rule(names, rule) {
    for (var i = 0; i < names.length; i++) {
      annotation_rules[names[i]] = rule;
    }
  }


  function annotate_destructuring (exp, scope) {
    if (exp.list) {
      if (exp.tag === "vector") {
        for (var i = 0; i < exp.list.length; i++) {
          annotate_destructuring(exp.list[i], scope);
        }
      } 
      else if (exp.tag === "map") {
        for (var i = 0; i < exp.list.length; i += 2) {
          var key = exp.list[i];
          var val = exp.list[i + 1];
          
          if (key.tag === "keyword" && val.tag === "vector") {
            for (var ii = 0, jj = val.list.length; ii < jj; ii++) {
              if (val.list[ii].tag !== "symbol") continue;
              val.list[ii].tag = "variable";
              scope[val.list[ii].value] = true;
            }
          }
          else {
            annotate_destructuring(key, scope);
            annotate_expressions(val, scope);
          }
        } 
      }
    } 
    else if (exp.tag === "symbol" && (exp.value !== "&" && exp.value !== "&amp;")){
      exp.tag = "variable";
      scope[exp.value] = true;
    }
  }

  function _annotate_binding_vector (exp, scope) {
    if (exp.tag !== "vector") return;
  
    var bindings = exp.list;

    if (bindings.length % 2 === 1) return;
    
    for (var i = 0; i < bindings.length; i += 2) {
      annotate_destructuring(bindings[i], scope);
      annotate_expressions(bindings[i + 1], scope);
    }    
  }

  function annotate_binding (exp, scope) {
    var bindings = exp.list[1];
    if (!show_locals) return; // HACK

    if (bindings) {
      scope = Object.create(scope);
      _annotate_binding_vector(bindings, scope);
    }
    for (var i = 2; i < exp.list.length; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }
  
  function _annotate_function_body (exp, scope, start_idx) {
    var argvec = exp.list[start_idx];
    if (argvec.tag !== "vector") return;

    scope = Object.create(scope);

    for (var i = 0, j = argvec.list.length; i < j; i++) {
      annotate_destructuring(argvec.list[i], scope);
    }
    
    for (var i = start_idx, j = exp.list.length; i < j; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }
  
  function annotate_function (exp, scope) {
    for (var i = 1, j = exp.list.length; i < j; i++) {
      var child = exp.list[i];
      
      if (child.tag === "vector") {
        _annotate_function_body (exp, scope, i);
        return;
      }
      else if (child.tag === "list") {
        _annotate_function_body(child, scope, 0)
      }
    }
  }
  
  function annotate_letfn (exp, scope) {
    scope = Object.create(scope);
    var bindings = exp.list[1];
    
    var fn;
    for (var i = 0, j = bindings.list.length; i < j; i++) {
      fn = bindings.list[i];
      if (!fn.list[0]) continue;
      fn.list[0].tag = "variable";
      scope[fn.list[0].value] = true;
    }
    
    for (i = 0, j = bindings.list.length; i < j; i++) {
      var fn = bindings.list[i];
      annotate_function(fn, scope);
    }
    
    for (i = 2, j = exp.list.length; i < j; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }

  register_annotation_rule(
    ["comment"],
    annotate_comment
  );
  
  register_annotation_rule(
    ["let", "when-let", "if-let", "binding", "doseq", "for", "dotimes", "let*"],
    annotate_binding
  );
  
  register_annotation_rule(
    ["defn", "defn-", "fn", "bound-fn", "defmacro", "fn*", "defmethod"],
    annotate_function
  );
  
  register_annotation_rule(
    ["letfn"],
    annotate_letfn
  );

  // standard annotations

  function _annotate_metadata_recursive(meta, scope) {
    if (!meta) return;

    if (meta.list !== undefined && meta.list !== null) {
      for (var i = 0, j = meta.list.length; i < j; i++) {
        meta.opening.secondary_tags.meta = true
        meta.closing.secondary_tags.meta = true
        _annotate_metadata_recursive(meta.list[i], scope);
      }
    }
    else if (meta.attached_node) {
      meta.token.secondary_tags.meta = true;
      _annotate_metadata_recursive(meta.attached_node, scope);
    }
    else {
      meta.secondary_tags.meta = true;
    }
  }
  
  function annotate_metadata(exp) {
    if (!(exp && exp.meta)) return;
    var meta = exp.meta;
    
     annotate_expressions(meta, {});    
    _annotate_metadata_recursive(meta, {});
  }


  function annotate_quoted(exp, scope) {
    if (!exp) return;

    if (exp.list !== undefined && exp.list !== null) {
      for (var i = 0, j = exp.list.length; i < j; i++) {
        exp.opening.secondary_tags.quoted = true
        exp.closing.secondary_tags.quoted = true
        annotate_quoted(exp.list[i], scope);
      }
    }
    else if (exp.attached_node) {
      if (exp.tag === "unquote" || exp.tag === "splice") return;
      exp.token.secondary_tags.quoted = true;
      annotate_quoted(exp.attached_node, scope);
    }
    else {
      exp.secondary_tags.quoted = true;
    }
  }


  function annotate_expressions(exp, scope) {
    annotate_metadata(exp);
    
    switch (exp.tag) {
      case "toplevel": 
        for (var i = 0; i < exp.list.length; i++) {
          annotate_expressions(exp.list[i], scope);
        }
        break;
      
      case "list": // functions, macros, special forms, comments
        var head = exp.list[0];
      
        if (head) {
          if (head.tag === "list" || head.tag === "vector" 
           || head.tag === "map" || head.tag === "set") {
            annotate_expressions(head, scope);
          }
          else if (head.attached_node) {
            annotate_expressions(head.attached_node, scope);
          }
          else {
            head.tag = (head.value.match(/(^\.)|(\.$)|[A-Z].*\//)
                        ? "method"
                        : "function");
          }

          // apply specific rules
          if (annotation_rules.hasOwnProperty(head.value)) {
            annotation_rules[head.value](exp, scope);
          } 
          else {
            for (var i = 1; i < exp.list.length; i++) {
              annotate_expressions(exp.list[i], scope);
            }
          } 
        }
        else { // empty list
          exp.opening.tag = "value";
          exp.closing.tag = "value";
        }
      
        break;
      
      case "vector": // data
      case "map":
      case "set":
        for (var i = 0; i < exp.list.length; i++) {
          annotate_expressions(exp.list[i], scope);
        }
        break;
      
      case "symbol":
        if (exp.value.match(/[A-Z].*\/[A-Z_]+/)) {
          exp.tag = "constant";
        }
        else if (show_locals && scope[exp.value]) {
          exp.tag = "variable";
        }
        else if (exp.tag === "symbol" && exp.value.match(/([A-Z].*\/)?[A-Z_]+/)) {
          exp.tag = "type";
        }
        break;
      
      case "quote":
      case "quasiquote":
        annotate_quoted(exp.attached_node, scope);
        
      default:
        if (exp.attached_node) annotate_expressions(exp.attached_node, scope);
    }
  }

  // translation of tag to css:
  var css_translation = {
    "constant":     "constants",
    "keyword":      "constants",
    "method":       "color1",
    "type":         "color3", 
    "function":     "functions",
    "string":       "string",
    "regexp":       "string",
    "value":        "value",
    "comments":     "comments",
    "symbol":       "symbol",
    "variable":     "variable",
    "splice":       "preprocessor", 
    "unquote":      "preprocessor",     
    "preprocessor": "preprocessor",
    "meta":         "preprocessor", 
    "'":            "preprocessor", 
    "#'":           "preprocessor",    
    "(":            "plain",
    ")":            "plain",
    "{":            "keyword",
    "}":            "keyword",
    "#{":           "keyword",   
    "[":            "keyword",
    "]":            "keyword",
    "invalid":      "invalid",
    "@":            "plain" 
  };
  
  function translate_tags_to_css(tokens) {
    for (var i = 0, j = tokens.length; i < j; i++) {
      var token = tokens[i];
      token.css = css_translation[token.tag];
      for (var k in token.secondary_tags) if (token.secondary_tags.hasOwnProperty(k))
        token.css += " " + k ;
    };
  }
  
  
  // create the new brush

  SH.brushes.Clojure = function () {};
  SH.brushes.Clojure.prototype = new SyntaxHighlighter.Highlighter();
  
  SH.brushes.Clojure.prototype.findMatches = function find_matches (regexpList, code) {
    // this is a nasty global hack. need to resolve this
    if (this.params && this.params.locals) {
      show_locals = this.params.locals === true || this.params.locals === "true"; 
    }
    else {
      show_locals = true;
    }
    
    var tokens = tokenize(code);
    annotate_expressions(build_tree(tokens), {});
    translate_tags_to_css(tokens);

    return tokens;
  };
  
  SH.brushes.Clojure.aliases = ['clojure', 'Clojure', 'clj'];
  SH.brushes.Clojure.register_annotation_rule = register_annotation_rule;

  return {
    tokenize: tokenize,
    build_tree: build_tree
  };
})(SyntaxHighlighter);
</script><title>org.nfrac/comportex -- Marginalia</title></head><body><table><tr><td class="docs"><div class="header"><h1 class="project-name"><a href="http://github.com/nupic-community/comportex/">org.nfrac/comportex</a></h1><h2 class="project-version">0.0.12-SNAPSHOT</h2><br /><p>Functionally composable cortex, an implementation of Hierarchical Temporal Memory</p>
</div><div class="dependencies"><h3>dependencies</h3><table><tr><td class="dep-name">org.clojure/clojure</td><td class="dotted"><hr /></td><td class="dep-version">1.7.0</td></tr><tr><td class="dep-name">org.clojure/core.async</td><td class="dotted"><hr /></td><td class="dep-version">0.1.346.0-17112a-alpha</td></tr><tr><td class="dep-name">org.clojure/data.int-map</td><td class="dotted"><hr /></td><td class="dep-version">0.1.0</td></tr><tr><td class="dep-name">org.clojure/test.check</td><td class="dotted"><hr /></td><td class="dep-version">0.8.2</td></tr><tr><td class="dep-name">clj-http</td><td class="dotted"><hr /></td><td class="dep-version">1.1.1</td></tr><tr><td class="dep-name">cljs-http</td><td class="dotted"><hr /></td><td class="dep-version">0.1.30</td></tr></table></div></td><td class="codes" style="text-align: center; vertical-align: middle;color: #666;padding-right:20px"><br /><br /><br />(this space intentionally left almost blank)</td></tr><tr><td class="docs"><div class="toc"><a name="toc"><h3>namespaces</h3></a><ul><li><a href="#org.nfrac.comportex.cells">org.nfrac.comportex.cells</a></li><li><a href="#org.nfrac.comportex.columns">org.nfrac.comportex.columns</a></li><li><a href="#org.nfrac.comportex.core">org.nfrac.comportex.core</a></li><li><a href="#org.nfrac.comportex.cortical-io">org.nfrac.comportex.cortical-io</a></li><li><a href="#org.nfrac.comportex.encoders">org.nfrac.comportex.encoders</a></li><li><a href="#org.nfrac.comportex.inhibition">org.nfrac.comportex.inhibition</a></li><li><a href="#org.nfrac.comportex.protocols">org.nfrac.comportex.protocols</a></li><li><a href="#org.nfrac.comportex.repl">org.nfrac.comportex.repl</a></li><li><a href="#org.nfrac.comportex.synapses">org.nfrac.comportex.synapses</a></li><li><a href="#org.nfrac.comportex.topology">org.nfrac.comportex.topology</a></li><li><a href="#org.nfrac.comportex.util">org.nfrac.comportex.util</a></li><li><a href="#org.nfrac.comportex.demos.coordinates-2d">org.nfrac.comportex.demos.coordinates-2d</a></li><li><a href="#org.nfrac.comportex.demos.directional-steps-1d">org.nfrac.comportex.demos.directional-steps-1d</a></li><li><a href="#org.nfrac.comportex.demos.identity">org.nfrac.comportex.demos.identity</a></li><li><a href="#org.nfrac.comportex.demos.isolated-1d">org.nfrac.comportex.demos.isolated-1d</a></li><li><a href="#org.nfrac.comportex.demos.letters">org.nfrac.comportex.demos.letters</a></li><li><a href="#org.nfrac.comportex.demos.mixed-gaps-1d">org.nfrac.comportex.demos.mixed-gaps-1d</a></li><li><a href="#org.nfrac.comportex.demos.q-learning-1d">org.nfrac.comportex.demos.q-learning-1d</a></li><li><a href="#org.nfrac.comportex.demos.q-learning-2d">org.nfrac.comportex.demos.q-learning-2d</a></li><li><a href="#org.nfrac.comportex.demos.repeat">org.nfrac.comportex.demos.repeat</a></li><li><a href="#org.nfrac.comportex.demos.second-level-motor">org.nfrac.comportex.demos.second-level-motor</a></li><li><a href="#org.nfrac.comportex.demos.sensorimotor-1d">org.nfrac.comportex.demos.sensorimotor-1d</a></li><li><a href="#org.nfrac.comportex.demos.simple-sentences">org.nfrac.comportex.demos.simple-sentences</a></li><li><a href="#org.nfrac.comportex.util.algo-graph">org.nfrac.comportex.util.algo-graph</a></li></ul></div></td><td class="codes">&nbsp;</td></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#org.nfrac.comportex.cells" name="org.nfrac.comportex.cells"><h1 class="project-name">org.nfrac.comportex.cells</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Cell activation and sequence memory.</p>

<p>   <strong>Argument name conventions:</strong></p>

<ul>
<li><code>col</code> -- a column id, an integer index in the region.</li>
<li><code>ci</code> -- a cell id, an integer index in the column.</li>
<li><code>si</code> -- a segment id, an integer index in the cell.</li>
<li><code>cell-id</code> -- a vector <code>[col ci]</code>.</li>
<li><p><code>seg-path</code> -- a vector <code>[col ci si]</code>.</p></li>
<li><p><code>ff-bits</code> -- the set of indices of active bits/cells on proximal dendrites.</p></li>
<li><code>aci</code> -- the set of indices of active bits/cells on distal dendrites.</li>
<li><code>lci</code> -- the set of indices of learnable bits/cells on distal dendrites.</li>
<li><code>ac</code> -- the set of ids of active cells.</li>
<li><code>pc</code> -- the set of ids of predictive cells.</li>
<li><code>tpc</code> -- the set of ids of temporal pooling cells.</li>
<li><code>lc</code> -- the set of ids of learning cells.</li>
<li><code>a-cols</code> -- the set of ids of active columns.</li>
<li><code>seg</code> or <code>syns</code> -- incoming synapses as a map from source id to permanence.</li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(ns org.nfrac.comportex.cells
  (:require [org.nfrac.comportex.protocols :as p]
            [org.nfrac.comportex.columns :as columns]
            [org.nfrac.comportex.synapses :as syn]
            [org.nfrac.comportex.inhibition :as inh]
            [org.nfrac.comportex.topology :as topology]
            [org.nfrac.comportex.util :as util
             :refer [count-filter remap round]]
            [clojure.test.check.random :as random]
            [clojure.set :as set]))</pre></td></tr><tr><td class="docs"><p>Default parameters for distal dendrite segments. The
  same parameters are also used for proximal segments, but with
  different default values.</p>

<ul>
<li><p><code>max-segments</code> - maximum number of dendrites segments per cell (or
column for proximal dendrites).</p></li>
<li><p><code>max-synapse-count</code> - maximum number of synapses per segment.</p></li>
<li><p><code>new-synapse-count</code> - number of synapses on a new dendrite
segment.</p></li>
<li><p><code>stimulus-threshold</code> - minimum number of active synapses on a
segment for it to become active.</p></li>
<li><p><code>learn-threshold</code> - minimum number of active synapses on a segment
for it to be reinforced and extended if it is the best matching.</p></li>
<li><p><code>perm-inc</code> - amount by which to increase synapse permanence to
active sources when reinforcing a segment.</p></li>
<li><p><code>perm-stable-inc</code> - amount by which to increase a synapse
permanence to stable (predicted) sources.</p></li>
<li><p><code>perm-dec</code> - amount by which to decrease synapse permanence to
inactive sources when reinforcing a segment.</p></li>
<li><p><code>perm-punish</code> - amount by which to decrease synapse permanence
when punishing segments in case of failed prediction.</p></li>
<li><p><code>perm-connected</code> - permanence value at which a synapse is
functionally connected. Permanence values are defined to be between
0 and 1.</p></li>
<li><p><code>perm-init</code> - permanence value for new synapses on segments.</p></li>
<li><p><code>punish?</code> - whether to reduce synapse permanence on segments
incorrectly predicting activation.</p></li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(def dendrite-parameter-defaults
  {:max-segments 5
   :max-synapse-count 22
   :new-synapse-count 12
   :stimulus-threshold 9
   :learn-threshold 7
   :perm-inc 0.05
   :perm-stable-inc 0.05
   :perm-dec 0.01
   :perm-punish 0.002
   :perm-connected 0.20
   :perm-init 0.16
   :punish? true
   })</pre></td></tr><tr><td class="docs"><p>Default parameter specification map.</p>

<ul>
<li><p><code>input-dimensions</code> - size of input bit grid as a vector, one
dimensional <code>[size]</code>, two dimensional <code>[width height]</code>, etc.</p></li>
<li><p><code>column-dimensions</code> - size of column field as a vector, one
dimensional <code>[size]</code> or two dimensional <code>[width height]</code>.</p></li>
<li><p><code>ff-potential-radius</code> - range of potential feed-forward synapse
connections, as a fraction of the longest single dimension in the
input space.</p></li>
<li><p><code>ff-init-frac</code> - fraction of inputs within radius that will be
part of the initially connected set.</p></li>
<li><p><code>ff-perm-init-hi</code> - highest initial permanence value on new synapses.</p></li>
<li><p><code>ff-perm-init-lo</code> - lowest initial permanence value on new synapses.</p></li>
<li><p><code>proximal</code> - map of parameters for proximal dendrite segments,
see <code>dendrite-parameter-defaults</code>.</p></li>
<li><p><code>distal</code> - map of parameters for distal dendrite segments,
see <code>dendrite-parameter-defaults</code>.</p></li>
<li><p><code>apical</code> - map of parameters for apical dendrite segments,
see <code>dendrite-parameter-defaults</code>. Ignored unless :use-feedback?</p></li>
<li><p><code>max-boost</code> - ceiling on the column boosting factor used to
increase activation frequency.</p></li>
<li><p><code>duty-cycle-period</code> - number of time steps to average over when
updating duty cycles and (thereby) column boosting measures.</p></li>
<li><p><code>boost-active-duty-ratio</code> - when a column's activation frequency
is below this proportion of the <em>highest</em> of its neighbours, its
boost factor is increased.</p></li>
<li><p><code>boost-active-every</code> - number of time steps between recalculating
column boosting factors.</p></li>
<li><p><code>inh-radius-every</code> - number of time steps between recalculating
the effective inhibition radius.</p></li>
<li><p><code>lateral-synapses?</code> - whether distal synapses can connect
laterally to other cells in this layer.</p></li>
<li><p><code>use-feedback?</code> - whether distal synapses can connect to top-down
feedback cells.</p></li>
<li><p><code>distal-motor-dimensions</code> - defines bit field available for
feed-forward motor input to distal synapses.</p></li>
<li><p><code>distal-topdown-dimensions</code> - defines bit field available for
top-down feedback to distal synapses.</p></li>
<li><p><code>depth</code> - number of cells per column.</p></li>
<li><p><code>activation-level</code> - fraction of columns that can be
active (either locally or globally); inhibition kicks in to reduce
it to this level. Does not apply to temporal pooling.</p></li>
<li><p><code>activation-level-max</code> - maximum fraction of columns that can be
active as temporal pooling progresses. Each step of continued
pooling allocates an extra 50% of <code>activation-level</code> until this
maximum is reached.</p></li>
<li><p><code>global-inhibition?</code> - whether to use the faster global algorithm
for column inhibition (just keep those with highest overlap scores),
or to apply local inhibition (only within a column's neighbours).</p></li>
<li><p><code>inhibition-base-distance</code> - the distance in columns within which
a cell <em>will always</em> inhibit neighbouring cells with lower
excitation. Ignored if <code>global-inhibition?</code> is true.</p></li>
<li><p><code>distal-vs-proximal-weight</code> - scaling to apply to the number of
active distal synapses (on the winning segment) before adding to the
number of active proximal synapses, when selecting active
columns. Set to zero to disable ``prediction-assisted'' activation.</p></li>
<li><p><code>spontaneous-activation?</code> - if true, cells may become active with
sufficient distal synapse excitation, even in the absence of any
proximal synapse excitation.</p></li>
<li><p><code>dominance-margin</code> - an amount of excitation (generally measured
in number of active synapses) by which one cell must exceed all
others in the column to be considered dominant. And therefore to
inhibit all other cells in the column.</p></li>
<li><p><code>stable-inbit-frac-threshold</code> - fraction of proximal input bits
to a layer which must be from stable cells in order to start
temporal pooling.</p></li>
<li><p><code>temporal-pooling-max-exc</code> - maximum continuing temporal pooling
excitation level.</p></li>
<li><p><code>temporal-pooling-fall</code> - amount by which a cell's continuing
temporal pooling excitation falls each time step.</p></li>
<li><p><code>random-seed</code> - the random seed (for reproducible results).</p></li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(def parameter-defaults
  {:input-dimensions [:define-me!]
   :column-dimensions [1000]
   :depth 5
   :ff-potential-radius 1.0
   :ff-init-frac 0.25
   :ff-perm-init-hi 0.25
   :ff-perm-init-lo 0.10
   :proximal {:max-segments 1
              :max-synapse-count 300
              :new-synapse-count 12
              :stimulus-threshold 2
              :learn-threshold 7
              :perm-inc 0.04
              :perm-stable-inc 0.15
              :perm-dec 0.01
              :perm-connected 0.20
              :perm-init 0.16
              }
   :distal dendrite-parameter-defaults
   :apical dendrite-parameter-defaults
   :max-boost 1.5
   :duty-cycle-period 1000
   :boost-active-duty-ratio 0.001
   :boost-active-every 1000
   :inh-radius-every 1000
   :lateral-synapses? true
   :distal-motor-dimensions [0]
   :distal-topdown-dimensions [0]
   :use-feedback? false
   :activation-level 0.02
   :activation-level-max 0.10
   :global-inhibition? true
   :inhibition-base-distance 1
   :distal-vs-proximal-weight 0.0
   :spontaneous-activation? false
   :dominance-margin 4
   :stable-inbit-frac-threshold 0.5
   :temporal-pooling-max-exc 50.0
   :temporal-pooling-fall 5.0
   :random-seed 42
   })</pre></td></tr><tr><td class="docs"><p>TODO decide on defaults (reliability vs speed), provide alternatives?</p>
</td><td class="codes"><pre class="brush: clojure">(def better-parameter-defaults
  (assoc parameter-defaults
         :column-dimensions [2048]
         :depth 16
         :distal (assoc dendrite-parameter-defaults
                        :max-segments 8
                        :max-synapse-count 32
                        :new-synapse-count 20
                        :stimulus-threshold 13
                        :learn-threshold 10)))</pre></td></tr><tr><td class="docs"><h2>Synapse tracing</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn distal-sources-widths
  [spec]
  [(if (:lateral-synapses? spec)
     (reduce * (:depth spec) (:column-dimensions spec))
     0)
   (reduce * (:distal-motor-dimensions spec))])</pre></td></tr><tr><td class="docs"><p>applies to cells in the current layer only</p>
</td><td class="codes"><pre class="brush: clojure">(defn cell-&gt;id
  [depth [col ci]]
  (+ (* col depth) ci))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- cells-&gt;bits
  [depth cells]
  (map (partial cell-&gt;id depth) cells))</pre></td></tr><tr><td class="docs"><p>applies to cells in the current layer only</p>
</td><td class="codes"><pre class="brush: clojure">(defn id-&gt;cell
  [depth id]
  [(quot id depth)
   (rem id depth)])</pre></td></tr><tr><td class="docs"><p>Returns a vector [k v] where k is one of :this or :ff. In the
   case of :this, v is [col ci], otherwise v gives the index in the
   feed-forward distal input field.</p>
</td><td class="codes"><pre class="brush: clojure">(defn id-&gt;source
  [spec id]
  (let [[this-w ff-w] (distal-sources-widths spec)]
    (cond
     (&lt; id this-w) [:this (id-&gt;cell (:depth spec) id)]
     (&lt; id (+ this-w ff-w)) [:ff (- id this-w)])))</pre></td></tr><tr><td class="docs"><h2>Activation</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Returns the number of active cells to which the synapses are
  connected, i.e. where synapse permanence is equal to or greater than
  <code>pcon</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn segment-activation
  [syns aci pcon]
  (count-filter (fn [[id p]]
                  (and (&gt;= p pcon)
                       (aci id)))
                syns))</pre></td></tr><tr><td class="docs"><p>Returns a seq of the segment indexes in the cell with activation at
  or above the activation threshold <code>th</code>, only considering synapses
  with permanence values at or above <code>pcon</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn cell-active-segments
  [cell-segs aci th pcon]
  (keep-indexed (fn [si syns]
                  (let [act (segment-activation syns aci pcon)]
                    (when (&gt;= act th) si)))
                cell-segs))</pre></td></tr><tr><td class="docs"><p>Finds the segment in the cell having the most active synapses, as
  long as is above the activation threshold <code>min-act</code>, only considering
  synapses with permanence values at or above <code>pcon</code>. <code>aci</code> are active bits.
  Returns
  <code>[seg-index activation synapses]</code>. If no such segments exist,
  returns <code>[nil 0 {}]</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn best-matching-segment
  [cell-segs aci min-act pcon]
  (loop [segs (seq cell-segs)
         si 0
         best-si 0
         best-act 0
         best-syns nil]
    (if-let [syns (first segs)]
      (let [act (long (segment-activation syns aci pcon))
            best? (&gt; act best-act)]
        (recur (next segs)
               (inc si)
               (if best? si best-si)
               (if best? act best-act)
               (if best? syns best-syns)))
      ;; finished
      (if (&gt;= best-act min-act)
        [best-si best-act best-syns]
        [nil 0 {}]))))</pre></td></tr><tr><td class="docs"><p>Finds the most excited dendrite segment for each cell. Returns a
  tuple of 3 maps keyed by cell id, the first contains the segment
  excitation values, the second contains the segment paths, and the
  third the segment paths only for cells with excitation meeting
  min-threshold. In other words the latter paths identify the dominant
  segments on well-matching cells.</p>
</td><td class="codes"><pre class="brush: clojure">(defn best-segment-excitations-and-paths
  [seg-exc min-threshold]
  (loop [seg-exc (seq seg-exc)
         excs (transient {})
         paths (transient {})
         good-paths (transient {})]
    (if-let [[k exc] (first seg-exc)]
      (let [id (pop k) ;; seg-id to cell-id: [col ci _]
            prev-exc (get excs id 0.0)]
        (if (&gt; exc prev-exc)
          (recur (next seg-exc)
                 (assoc! excs id exc)
                 (assoc! paths id k)
                 (if (&gt;= exc min-threshold)
                   (assoc! good-paths id k)
                   good-paths))
          (recur (next seg-exc)
                 excs
                 paths
                 good-paths)))
      ;; finished
      [(persistent! excs)
       (persistent! paths)
       (persistent! good-paths)])))</pre></td></tr><tr><td class="docs"><p>Computes excitatation as a map from cell id to the greatest
  number of active synapses on any one dendrite segment.</p>
</td><td class="codes"><pre class="brush: clojure">(defn best-segment-excitations
  [seg-exc]
  (persistent!
   (reduce-kv (fn [m k exc]
                (let [id (pop k)] ;; seg-id to cell-id: [col ci _]
                  (assoc! m id (max exc (get m id 0.0)))))
              (transient {})
              seg-exc)))</pre></td></tr><tr><td class="docs"><p>Returns a map of column ids to representative excitation values,
  being the greatest excitation of its constituent cells or segments.</p>
</td><td class="codes"><pre class="brush: clojure">(defn best-by-column
  [cell-exc]
  (persistent!
   (reduce-kv (fn [m id exc]
                (let [[col _] id] ;; cell-id / seg-id to col
                  (assoc! m col (max exc (get m col 0.0)))))
              (transient {})
              cell-exc)))</pre></td></tr><tr><td class="docs"><p>Combine the proximal and distal excitations in a map of cell id to
  excitation, as a weighted sum. Temporal Pooling <code>tp-exc</code> is added to
  the proximal excitation but is given keyed by cell rather than by
  column. Normally only cells with some proximal input are included,
  but if <code>spontaneous-activation?</code> is true, this is relaxed
  (i.e. prediction alone could cause activation).</p>

<ul>
<li>col-exc is keyed by column as [col 0].</li>
<li>tp-exc is keyed by cell as [col ci].</li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(defn total-excitations
  [col-exc tp-exc distal-exc distal-weight spontaneous-activation? depth]
  (let [has-tp? (seq tp-exc)
        ;; add TP columns to list of columns to consider (may have no proximal)
        basic-col-exc (if has-tp?
                        (merge-with + col-exc
                                    (into {} (map (fn [[col _]] [[col 0] 0]))
                                          (keys tp-exc)))
                        col-exc)
        ;; expand to all cells within columns, add TP values
        basic-exc (for [[[col _] exc] basic-col-exc
                        ci (range depth)
                        :let [cell-id [col ci]
                              tp (if has-tp? (get tp-exc cell-id 0.0) 0.0)]]
                    [cell-id (+ exc tp)])]
    (if (zero? distal-weight)
      (into {} basic-exc)
      (let [basic-exc (if spontaneous-activation?
                        (into (zipmap (keys distal-exc) (repeat 0.0))
                              basic-exc)
                        basic-exc)]
        ;; add distal values
        (persistent!
         (reduce (fn [m [id p-exc]]
                   (let [d-exc (distal-exc id 0.0)]
                     (assoc! m id (+ p-exc (* distal-weight d-exc)))))
                 (transient {})
                 basic-exc))))))</pre></td></tr><tr><td class="docs"><p>Returns a set of column ids to become active after lateral inhibition.</p>
</td><td class="codes"><pre class="brush: clojure">(defn select-active-columns
  [col-exc topo activation-level inh-radius spec]
  (let [level activation-level
        n-on (max 1 (round (* level (p/size topo))))]
    (set
     (if (:global-inhibition? spec)
       (inh/inhibit-globally col-exc n-on)
       (inh/inhibit-locally col-exc topo inh-radius
                            (:inhibition-base-distance spec)
                            n-on)))))</pre></td></tr><tr><td class="docs"><p>Returns <code>[winner-cell-id active-cell-ids]</code>.
  The winner cell is one with greatest excitation, with ties broken
  randomly. If no cells exceed the threshold, then all become
  active (''bursting''). Otherwise, only cells above the threshold
  become active; but if the winner exceeds all others by at least
  <code>dominance-margin</code> then it is the only active cell.</p>
</td><td class="codes"><pre class="brush: clojure">(defn column-active-cells
  [col cell-exc prior-winner depth threshold dominance-margin rng reset?]
  (let [cell-ids (for [ci (range depth)] [col ci])]
    (loop [ids cell-ids
           best-ids ()
           best-exc 0.0
           good-ids () ;; over threshold
           second-exc (double threshold)]
      (if-let [id (first ids)]
        (let [exc (double (cell-exc id 0))
              equal-best? (== exc best-exc)
              new-best? (&gt; exc best-exc)
              good? (&gt;= exc threshold)]
          (recur (next ids)
                 (cond equal-best? (conj best-ids id)
                       new-best? (list id)
                       :else best-ids)
                 (if new-best? exc best-exc)
                 (if good? (conj good-ids id) good-ids)
                 (if new-best?
                   best-exc
                   (if (&lt; second-exc exc best-exc)
                     exc
                     second-exc))))
        ;; finished
        (let [winner (cond
                       (empty? best-ids)
                       (first cell-ids)
                       (== (count best-ids) 1)
                       (first best-ids)
                       (and prior-winner (some #(= % prior-winner) best-ids))
                       prior-winner
                       reset?
                       (first cell-ids)
                       :else
                       (util/rand-nth rng best-ids))
              actives (cond
                        ;; stimulus threshold not reached
                        (&lt; best-exc threshold)
                        cell-ids
                        ;; best cells exceed all others by dominance-margin
                        (&gt;= (- best-exc second-exc) dominance-margin)
                        best-ids
                        ;; otherwise, all cells over threshold become active
                        :else
                        good-ids)]
          [winner actives])))))</pre></td></tr><tr><td class="docs"><p>Determines active cells in the given columns and whether they are bursting.
   Returns keys
  * <code>:active-cells</code> - the set of active cell ids.
  * <code>:stable-active-cells</code> - the set of non-bursting active cells.
  * <code>:burst-cols</code> - the set of bursting column ids.
  * <code>:col-winners</code> - the map of column id to winner cell id.</p>
</td><td class="codes"><pre class="brush: clojure">(defn select-active-cells
  [a-cols cell-exc bursting? prior-col-winners reset?
   depth threshold dominance-margin rng]
  (loop [cols (seq a-cols)
         ac (transient #{}) ;; active cells
         sac (transient #{}) ;; stable active cells
         b-cols (transient #{}) ;; bursting columns
         col-winners (transient {})
         rng rng]
    (if-let [col (first cols)]
      (let [[rng rng*] (random/split rng)
            ;; carry forward learning cells for higher level sequences
            prior-winner (get prior-col-winners col)
            [win-cell col-ac] (column-active-cells col cell-exc prior-winner
                                                   depth threshold dominance-margin
                                                   rng* reset?)
            b-col? (bursting? col win-cell col-ac)
            next-ac (reduce conj! ac col-ac)
            next-sac (if b-col?
                       sac
                       (reduce conj! sac col-ac))]
        (recur (next cols)
               next-ac
               next-sac
               (if b-col? (conj! b-cols col) b-cols)
               (assoc! col-winners col win-cell)
               rng))
      ;; finished
      {:active-cells (persistent! ac)
       :stable-active-cells (persistent! sac)
       :burst-cols (persistent! b-cols)
       :col-winners (persistent! col-winners)})))</pre></td></tr><tr><td class="docs"><p>Calculates cell excitation values to be used to select cells within
  columns <code>a-cols</code>; they are compared only within each column, not
  across columns. Where no segments exist, the value is
  zero. Otherwise three cases are possible:</p>

<ul>
<li><p>For predicted cells, the distal excitation (number of active
synapses on the most active segment) is returned.</p></li>
<li><p>A positive value is given for cells with partially-matching
segments. This applies if any segments exist with at least
<code>:seg-learn-threshold</code> active synapses -- even if the synapses are
not yet connected (below the permanence threshold).  The value is
chosen to be lower than any connected active segment: half the
<code>:seg-learn-threshold</code>.</p></li>
<li><p>A negative value is given for cells with only inactive distal
segments. We need this to encourage context-specific choice of cells
in a column: avoid cells that are missing their learned context
signal (segment). (As a biological justification, perhaps more
segments create a larger cell surface area to lose potential?)</p>

<p>The value is negatively proportional to the number of segments:
again the unit amount is half the <code>:seg-learn-threshold</code>.</p>

<p>Returns a map of cell ids to these relative excitation values.</p></li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(defn within-column-cell-exc
  [a-cols prior-col-winners distal-sg apical-sg distal-bits apical-bits
   distal-apical-exc distal-min-act apical-min-act depth]
  (let [adj-base-amount (quot distal-min-act 2)]
    (-&gt;&gt; (for [col a-cols
               :let [prior-wc (get prior-col-winners col)]
               ci (range depth)
               :let [cell-id [col ci]
                     d-cell-segs (-&gt;&gt; (p/cell-segments distal-sg cell-id)
                                      (filter seq))
                     a-cell-segs (-&gt;&gt; (p/cell-segments apical-sg cell-id)
                                      (filter seq))
                     n-segs (+ (count d-cell-segs) (count a-cell-segs))]
               :when (pos? n-segs)]
           (let [d-exc (distal-apical-exc cell-id)]
             (cond
               ;; predicted cell, use distal excitation
               d-exc
               [cell-id d-exc]
               ;; continuing winner cell
               (= prior-wc cell-id)
               [cell-id adj-base-amount]
               ;; some segment matches the input even if synapses disconnected
               (or
                (first (best-matching-segment d-cell-segs distal-bits distal-min-act 0.0))
                (first (best-matching-segment a-cell-segs apical-bits apical-min-act 0.0)))
               [cell-id adj-base-amount]
               ;; there are segments but none match the input; apply penalty
               :else
               [cell-id (* -1 adj-base-amount n-segs)])))
         (into {}))))</pre></td></tr><tr><td class="docs"><h2>Learning</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Returns a segment index on the cell at which to grow a new segment,
  together with any existing synapses at that index. It may refer to
  the end of the existing vector to append to it, or it may refer to
  an existing segment that is to be culled before the new one
  grows. If the maximum number of segments has been reached, an
  existing one is chosen to be replaced based on having the fewest
  connected synapses, or fewest synapses to break ties.</p>
</td><td class="codes"><pre class="brush: clojure">(defn new-segment-id
  [segs pcon max-segs max-syns]
  (let [segs (take-while seq segs)]
    (if (&gt;= (count segs) max-segs)
      ;; select the one with fewest connected, or fewest synapses, or first
      (let [si (apply min-key (fn [si]
                                (let [syns (nth segs si)
                                      n-conn (count-filter #(&gt;= % pcon) (vals syns))]
                                  (+ (* n-conn max-syns)
                                     (count syns)
                                     (/ si (count segs)))))
                      (range (count segs)))]
        [si (nth segs si)])
      ;; have not reached limit; append
      [(count segs) nil])))</pre></td></tr><tr><td class="docs"><p>Returns a collection of up to n ids chosen from the learnable cell
  bits <code>lci-vec</code>. May be less than <code>n</code> if the random samples have
  duplicates or some already exist on the segment, or if there are
  fewer than <code>n</code> learnable cells.</p>
</td><td class="codes"><pre class="brush: clojure">(defn segment-new-synapse-source-ids
  [seg lci-vec n rng]
  (when (seq lci-vec)
    (-&gt;&gt; lci-vec
         (util/sample rng n)
         (distinct)
         (remove seg))))</pre></td></tr><tr><td class="docs"><p>Given that an additional <code>grow-n</code> synapses will be added, checks if
  the segment will exceed the maximum allowed number of synapses, and
  if so, returns a list of synapse source ids to remove. These are the
  ones with lowest permanence.</p>
</td><td class="codes"><pre class="brush: clojure">(defn segment-excess-synapse-source-ids
  [syns grow-n max-syns]
  (let [total (+ (count syns) grow-n)
        excess (- total max-syns)]
    (if (pos? excess)
      (-&gt;&gt; (sort-by val syns)
           (take excess)
           (map first))
      nil)))</pre></td></tr><tr><td class="docs"><p>To punish segments which predicted activation on cells which did
  not become active. Ignores any which are still predictive.  Returns
  a sequence of SegUpdate records.</p>
</td><td class="codes"><pre class="brush: clojure">(defn punish-failures
  [distal-sg prior-pc pc ac prior-aci pcon stimulus-th]
  (let [bad-cells (set/difference prior-pc
                                  pc
                                  ac)]
    (for [cell-id bad-cells
          :let [cell-segs (p/cell-segments distal-sg cell-id)]
          si (cell-active-segments cell-segs prior-aci stimulus-th pcon)
          :let [seg-path (conj cell-id si)]]
      (syn/seg-update seg-path :punish nil nil))))</pre></td></tr><tr><td class="docs"><p>Takes the learning cells <code>lc</code> and maps each to a SegUpdate record,
  which includes the segment path to learn on, together with lists of
  any synapse sources to add or remove. The segment index is chosen as
  the best matching one, but if none match sufficiently then a new
  segment will be grown, perhaps replacing an existing one. <code>aci</code> is
  the set of active source indices, used to find a matching segment,
  while <code>lci</code> is the set of learnable source indices, used to grow new
  synapses. If <code>poor-match?</code> returns true for a cell id then
  unconnected synapses are used to find a matching segment. Otherwise
  only connected synapses are used.</p>

<p>  Note that ''cell-ids'' here may also refer to columns in a proximal
  synapse graph, where the convention is [col 0]. Everything else is
  the same since proximal synapses graphs can also have multiple
  segments [col 0 seg-idx].</p>
</td><td class="codes"><pre class="brush: clojure">(defn segment-learning-map
  [rng lc well-matching-paths sg aci lci {pcon :perm-connected
                                          min-act :learn-threshold
                                          new-syns :new-synapse-count
                                          max-syns :max-synapse-count
                                          max-segs :max-segments}]
  (let [lci-vec (vec lci)] ;; for faster sampling
    (loop [cells (seq lc)
           m (transient {})
           rng rng]
      (if-let [cell-id (first cells)]
        (if-let [seg-path (get well-matching-paths cell-id)]
          ;; choose the well matching segment
          (recur (next cells)
                 (assoc! m cell-id (syn/seg-update seg-path :learn nil nil))
                 rng)
          ;; otherwise - not well matching - check disconnected synapses
          (let [cell-segs (p/cell-segments sg cell-id)
                [match-si exc seg] (best-matching-segment cell-segs aci
                                                          min-act 0.0)
                new-segment? (not match-si)
                [seg-idx die-syns] (if match-si
                                     [match-si nil]
                                     (new-segment-id cell-segs pcon max-segs
                                                     max-syns))
                grow-n (- new-syns exc)
                [rng* rng] (if (pos? grow-n) (random/split rng) [rng rng])
                grow-source-ids (segment-new-synapse-source-ids seg lci-vec grow-n rng*)
                die-source-ids (if new-segment?
                                 (keys die-syns) ;; remove any existing (replaced)
                                 (segment-excess-synapse-source-ids seg grow-n
                                                                    max-syns))
                seg-path (conj cell-id seg-idx)]
            (recur (next cells)
                   ;; if not enough learnable sources to grow a new segment, skip it
                   (if (and new-segment?
                            (&lt; (count grow-source-ids) min-act))
                     m ;; skip
                     (assoc! m cell-id (syn/seg-update seg-path :learn grow-source-ids
                                                       die-source-ids)))
                   rng)))
        ;; finished
        (persistent! m)))))</pre></td></tr><tr><td class="docs"><h2>Orchestration</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn update-inhibition-radius
  [layer]
  (assoc layer :inh-radius
         (inh/inhibition-radius (:proximal-sg layer) (:topology layer)
                                (:input-topology layer))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn decay-tp
  [tp-exc fall]
  (persistent!
   (reduce-kv (fn [m id exc]
                ;; constant fall amount
                (let [e (- exc fall)]
                  (if (pos? e)
                    (assoc! m id e)
                    m)))
              (transient {})
              tp-exc)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord LayerActiveState
    [in-ff-bits in-stable-ff-bits
     out-ff-bits out-stable-ff-bits
     col-overlaps matching-ff-seg-paths well-matching-ff-seg-paths
     temporal-pooling-exc
     active-cols burst-cols active-cells col-winners timestep])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord LayerDistalState
    [on-bits on-lc-bits cell-exc pred-cells
     matching-seg-paths well-matching-seg-paths
     prior-active-cells timestep])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def empty-active-state
  (map-&gt;LayerActiveState
   {:col-winners {}
    :active-cells #{}
    :active-cols #{}
    :temporal-pooling-exc {}
    :well-matching-ff-seg-paths {}}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def empty-distal-state
  (map-&gt;LayerDistalState
   {:on-bits #{}
    :cell-exc {}
    :pred-cells #{}
    :well-matching-seg-paths {}}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn compute-distal-state
  [sg aci lci dspec t]
  (let [seg-exc (p/excitations sg aci (:stimulus-threshold dspec))
        [cell-exc seg-paths good-paths] (best-segment-excitations-and-paths
                                         seg-exc (:new-synapse-count dspec))
        pc (set (keys cell-exc))]
    (map-&gt;LayerDistalState
     {:on-bits (set aci)
      :on-lc-bits (set lci)
      :cell-exc cell-exc
      :matching-seg-paths seg-paths
      :well-matching-seg-paths good-paths
      :pred-cells pc
      :timestep t})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn distal-learn
  [sg distal-state prior-distal-state lc dspec rng]
  (let [learning (segment-learning-map rng lc
                                       (:well-matching-seg-paths distal-state)
                                       sg (:on-bits distal-state)
                                       (:on-lc-bits distal-state)
                                       dspec)
        punishments (if (:punish? dspec)
                      (punish-failures sg
                                       (:pred-cells prior-distal-state)
                                       (:pred-cells distal-state)
                                       (:prior-active-cells distal-state)
                                       (:on-bits prior-distal-state)
                                       (:perm-connected dspec)
                                       (:stimulus-threshold dspec))
                      nil)
        new-sg (cond-&gt; sg
                 (seq learning)
                 (p/bulk-learn (vals learning) (:on-lc-bits distal-state)
                               (:perm-inc dspec) (:perm-dec dspec)
                               (:perm-init dspec))
                 punishments
                 (p/bulk-learn punishments (:on-bits prior-distal-state)
                               (:perm-inc dspec) (:perm-punish dspec)
                               (:perm-init dspec)))]
    [new-sg
     learning
     punishments]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord LayerOfCells
    [spec rng topology input-topology inh-radius boosts active-duty-cycles
     proximal-sg distal-sg apical-sg state distal-state prior-distal-state
     apical-state prior-apical-state]
  p/PLayerOfCells
  (layer-activate
    [this ff-bits stable-ff-bits]
    (let [pspec (:proximal spec)
          ;; proximal excitation in number of active synapses, keyed by [col 0 seg-idx]
          col-seg-overlaps (p/excitations proximal-sg ff-bits
                                          (:stimulus-threshold pspec))
          ;; these all keyed by [col 0]
          [raw-col-exc ff-seg-paths ff-good-paths]
          (best-segment-excitations-and-paths col-seg-overlaps
                                              (:new-synapse-count pspec))
          ;; temporal pooling, depending on stability of input bits.
          ;; also check for clear matches, these override pooling
          higher-level? (&gt; (:max-segments pspec) 1)
          engaged? (or (not higher-level?)
                       (&gt; (count stable-ff-bits)
                          (* (count ff-bits) (:stable-inbit-frac-threshold spec))))
          newly-engaged? (or (not higher-level?)
                             (and engaged? (not (:engaged? state))))
          tp-exc (cond-&gt; (if newly-engaged?
                           {}
                           (:temporal-pooling-exc state))
                   true ;(not engaged?)
                   (decay-tp (:temporal-pooling-fall spec)))
          col-exc (cond-&gt; raw-col-exc
                         (not engaged?)
                         (select-keys (keys ff-good-paths))
                         true
                         (columns/apply-overlap-boosting boosts))
          ;; unlike other segments, allow apical excitation to add to distal
          d-a-cell-exc (if (:use-feedback? spec)
                         (merge-with + (:cell-exc distal-state)
                                     (:cell-exc apical-state))
                         (:cell-exc distal-state))
          ;; combine excitation values for selecting columns
          abs-cell-exc (total-excitations col-exc tp-exc d-a-cell-exc
                                          (:distal-vs-proximal-weight spec)
                                          (:spontaneous-activation? spec)
                                          (:depth spec))
          ;; union temporal pooling: accrete more columns as pooling continues
          activation-level (let [base-level (:activation-level spec)
                                 prev-level (/ (count (:active-cols state))
                                               (p/size-of this))]
                             (if (or newly-engaged? (not engaged?))
                               base-level
                               (min (:activation-level-max spec)
                                    (+ prev-level (* 0.5 base-level)))))
          a-cols (select-active-columns (best-by-column abs-cell-exc)
                                        topology activation-level
                                        inh-radius spec)
          ;; keep winners stable only at higher levels (first level needs to see repeats)
          prior-col-winners (if higher-level? (:col-winners state))
          ;; calculate relative excitations for cells within each active column:
          ;; * include distal excitation on predicted cells.
          ;; * matching segments below connected threshold get a bonus.
          ;; * cells with inactive segments get a penalty.
          rel-cell-exc (-&gt;&gt; (within-column-cell-exc a-cols
                                                    prior-col-winners
                                                    distal-sg apical-sg
                                                    (:on-bits distal-state)
                                                    (:on-bits apical-state)
                                                    d-a-cell-exc
                                                    (:learn-threshold (:distal spec))
                                                    (:learn-threshold (:apical spec))
                                                    (:depth spec))
                            (merge-with + tp-exc))
          ;; find active and winner cells in the columns
          pc (set/union (:pred-cells distal-state) (:pred-cells apical-state))
          depth (:depth spec)
          [rng* rng] (random/split rng)
          {ac :active-cells
           col-winners :col-winners
           burst-cols :burst-cols
           stable-ac :stable-active-cells}
          (select-active-cells a-cols rel-cell-exc
                               ;; definition of bursting for a column
                               (fn [col win-cell col-ac]
                                 (if (and (not newly-engaged?)
                                          (= win-cell (get prior-col-winners col)))
                                   ;; for continuing temporal pooling
                                   (== depth (count col-ac))
                                   ;; otherwise: for discrete transitions
                                   (not (or (pc win-cell) (tp-exc win-cell)))))
                               prior-col-winners
                               (empty? (:on-bits distal-state)) ;; reset?
                               depth (:stimulus-threshold (:distal spec))
                               (:dominance-margin spec) rng*)
          ;; learning cells are the winning cells, but excluding any
          ;; continuing winners when temporal pooling
          old-winners (vals (:col-winners state))
          new-winners (vals col-winners)
          learning (if newly-engaged? ;; always true at first level
                     new-winners
                     (remove (set old-winners) new-winners))
          ;; update continuing TP activation
          next-tp-exc (if higher-level?
                        (let [new-ac (if newly-engaged?
                                       ac
                                       (set/difference ac (:active-cells state)))]
                          (into (select-keys tp-exc ac) ;; only keep TP for active cells
                               (map vector new-ac
                                    (repeat (:temporal-pooling-max-exc spec)))))
                        {})]
      (assoc this
             :rng rng
             :state (map-&gt;LayerActiveState
                     {:in-ff-bits ff-bits
                      :in-stable-ff-bits stable-ff-bits
                      :out-ff-bits (set (cells-&gt;bits depth ac))
                      :out-stable-ff-bits (set (cells-&gt;bits depth stable-ac))
                      :out-wc-bits (set (cells-&gt;bits depth (vals col-winners)))
                      :engaged? engaged?
                      :newly-engaged? newly-engaged?
                      :col-overlaps raw-col-exc
                      :matching-ff-seg-paths ff-seg-paths
                      :well-matching-ff-seg-paths ff-good-paths
                      :temporal-pooling-exc next-tp-exc
                      :active-cells ac
                      :active-cols a-cols
                      :burst-cols burst-cols
                      :col-winners col-winners
                      :learning-cells learning
                      :timestep (inc (:timestep state))
                      }))))
  (layer-learn
    [this]
    (let [lc (:learning-cells state)
          ;; distal
          [rng* rng] (random/split rng)
          [dsg
           distal-learning
           distal-punishments] (distal-learn distal-sg distal-state
                                             prior-distal-state lc (:distal spec) rng*)
          ;; apical
          [rng* rng] (random/split rng)
          [asg
           apical-learning
           apical-punishments] (if (:use-feedback? spec)
                                 (distal-learn apical-sg apical-state
                                               prior-apical-state lc (:apical spec) rng*)
                                 [apical-sg nil nil])
          ;; proximal
          pspec (:proximal spec)
          higher-level? (&gt; (:max-segments pspec) 1)
          a-cols (:active-cols state)
          [rng* rng] (random/split rng)
          prox-learning (when (:engaged? state)
                          (segment-learning-map rng* (map vector a-cols (repeat 0))
                                                (:well-matching-ff-seg-paths state)
                                                proximal-sg
                                                (:in-ff-bits state)
                                                (if higher-level?
                                                  (:in-stable-ff-bits state)
                                                  (:in-ff-bits state))
                                                pspec))
          psg (cond-&gt; proximal-sg
                prox-learning
                (p/bulk-learn (vals prox-learning) (:in-ff-bits state)
                              (:perm-inc pspec) (:perm-dec pspec)
                              (:perm-init pspec))
                ;; positive learning rate is higher for stable (predicted) inputs
                (and prox-learning
                     (seq (:in-stable-ff-bits state))
                     (&gt; (:perm-stable-inc pspec) (:perm-inc pspec)))
                (p/bulk-learn (map #(syn/seg-update (:target-id %) :reinforce nil nil)
                                   (vals prox-learning))
                              (:in-stable-ff-bits state)
                              (- (:perm-stable-inc pspec) (:perm-inc pspec))
                              (:perm-dec pspec)
                              (:perm-init pspec)))
          timestep (:timestep state)]
      (cond-&gt;
          (assoc this
                 :rng rng
                 :state (assoc state
                               :distal-learning distal-learning
                               :distal-punishments distal-punishments
                               :apical-learning apical-learning
                               :apical-punishments apical-punishments
                               :proximal-learning prox-learning)
                 :distal-sg dsg
                 :apical-sg asg
                 :proximal-sg psg)
        true (update-in [:active-duty-cycles] columns/update-duty-cycles
                        (:active-cols state) (:duty-cycle-period spec))
        (zero? (mod timestep (:boost-active-every spec))) (columns/boost-active)
        (zero? (mod timestep (:inh-radius-every spec))) (update-inhibition-radius))))
  (layer-depolarise
    [this distal-ff-bits apical-fb-bits apical-fb-wc-bits]
    (let [depth (:depth spec)
          widths (distal-sources-widths spec)
          distal-aci (util/align-indices widths
                                  [(if (:lateral-synapses? spec)
                                     (:out-ff-bits state)
                                     [])
                                   distal-ff-bits])
          wc (vals (:col-winners state))
          distal-lci (util/align-indices widths
                                  [(if (:lateral-synapses? spec)
                                     (cells-&gt;bits depth wc)
                                     [])
                                   distal-ff-bits])
          apical-aci (if (:use-feedback? spec) apical-fb-bits [])
          apical-lci (if (:use-feedback? spec) apical-fb-wc-bits [])]
      (assoc this
        :prior-distal-state distal-state
        :prior-apical-state apical-state
        :distal-state (-&gt;
                       (compute-distal-state distal-sg distal-aci distal-lci
                                             (:distal spec) (:timestep state))
                       (assoc :prior-active-cells (:active-cells state)))
        :apical-state (-&gt;
                       (compute-distal-state apical-sg apical-aci apical-lci
                                             (:apical spec) (:timestep state))
                       (assoc :prior-active-cells (:active-cells state))))))
  (layer-depth [_]
    (:depth spec))
  (bursting-columns [_]
    (:burst-cols state))
  (active-columns [_]
    (:active-cols state))
  (active-cells [_]
    (:active-cells state))
  (winner-cells [_]
    (set (vals (:col-winners state))))
  (temporal-pooling-cells [_]
    (when (:engaged? state)
      (keys (:temporal-pooling-exc state))))
  (predictive-cells [_]
    (when (== (:timestep state)
              (:timestep distal-state))
      (set/union (:pred-cells distal-state)
                 (:pred-cells apical-state))))
  (prior-predictive-cells [_]
    (let [t-1 (dec (:timestep state))]
      (cond
        ;; after depolarise phase has run
        (== t-1 (:timestep prior-distal-state))
        (set/union (:pred-cells prior-distal-state)
                   (:pred-cells prior-apical-state))
        ;; before depolarise phase has run
        (== t-1 (:timestep distal-state))
        (set/union (:pred-cells distal-state)
                   (:pred-cells apical-state)))))
  p/PInterruptable
  (break [this mode]
    (case mode
      :tm (assoc this :distal-state
                 (assoc empty-distal-state :timestep (:timestep state)))
      :fb (assoc this :apical-state
                 (assoc empty-distal-state :timestep (:timestep state)))
      :tp (update-in this [:state :temporal-pooling-exc] empty)))
  p/PTopological
  (topology [this]
    (:topology this))
  p/PFeedForward
  (ff-topology [this]
    (topology/make-topology (conj (p/dims-of this)
                                  (p/layer-depth this))))
  (bits-value [_]
    (:out-ff-bits state))
  (stable-bits-value [_]
    (:out-stable-ff-bits state))
  (source-of-bit
    [_ i]
    (id-&gt;cell (:depth spec) i))
  p/PFeedBack
  (wc-bits-value [_]
    (:out-wc-bits state))
  p/PTemporal
  (timestep [_]
    (:timestep state))
  p/PParameterised
  (params [_]
    spec))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn layer-of-cells
  [spec]
  (let [spec (util/deep-merge parameter-defaults spec)
        input-topo (topology/make-topology (:input-dimensions spec))
        col-topo (topology/make-topology (:column-dimensions spec))
        n-cols (p/size col-topo)
        depth (:depth spec)
        n-distal (+ (if (:lateral-synapses? spec)
                      (* n-cols depth) 0)
                    (reduce * (:distal-motor-dimensions spec)))
        n-apical (reduce * (:distal-topdown-dimensions spec))
        [rng rng*] (-&gt; (random/make-random (:random-seed spec))
                       (random/split))
        col-prox-syns (columns/uniform-ff-synapses col-topo input-topo
                                                   spec rng*)
        proximal-sg (syn/col-segs-synapse-graph col-prox-syns n-cols
                                                (:max-segments (:proximal spec))
                                                (p/size input-topo)
                                                (:perm-connected (:proximal spec))
                                                false)
        distal-sg (syn/cell-segs-synapse-graph n-cols depth
                                               (:max-segments (:distal spec))
                                               n-distal
                                               (:perm-connected (:distal spec))
                                               true)
        apical-sg (syn/cell-segs-synapse-graph n-cols depth
                                               (:max-segments (:apical spec))
                                               n-apical
                                               (:perm-connected (:apical spec))
                                               true)
        state (assoc empty-active-state :timestep 0)
        distal-state (assoc empty-distal-state :timestep 0)]
    (-&gt;
     (map-&gt;LayerOfCells
      {:spec spec
       :rng rng
       :topology col-topo
       :input-topology input-topo
       :inh-radius 1
       :proximal-sg proximal-sg
       :distal-sg distal-sg
       :apical-sg apical-sg
       :state state
       :distal-state distal-state
       :prior-distal-state distal-state
       :boosts (vec (repeat n-cols 1.0))
       :active-duty-cycles (vec (repeat n-cols 0.0))
       })
     (update-inhibition-radius))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#org.nfrac.comportex.columns" name="org.nfrac.comportex.columns"><h1 class="project-name">org.nfrac.comportex.columns</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Handling of column-level proximal synapses - initialisation and boosting.</p>
</td><td class="codes"><pre class="brush: clojure">(ns org.nfrac.comportex.columns
  (:require [org.nfrac.comportex.protocols :as p]
            [org.nfrac.comportex.synapses :as syn]
            [org.nfrac.comportex.inhibition :as inh]
            [org.nfrac.comportex.topology :as topology]
            [org.nfrac.comportex.util :as util
             :refer [abs round mean count-filter remap]]
            [clojure.test.check.random :as random]))</pre></td></tr><tr><td class="docs"><p>Generates feed-forward synapses connecting columns to the input bit
   array.</p>

<p>   Connections are made locally by scaling the input space to the
   column space. Potential synapses are chosen within a radius in
   input space of <code>ff-potential-radius</code> fraction of the longest single
   dimension, and of those, <code>ff-init-frac</code> are chosen from a
   uniform random distribution.</p>

<p>   Initial permanence values are uniformly distributed between
   <code>ff-perm-init-lo</code> and <code>ff-perm-init-hi</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn uniform-ff-synapses
  [topo itopo spec rng]
  (let [p-hi (:ff-perm-init-hi spec)
        p-lo (:ff-perm-init-lo spec)
        global? (&gt;= (:ff-potential-radius spec) 1.0)
        ;; radius in input space, fraction of longest dimension
        radius (long (* (:ff-potential-radius spec)
                        (apply max (p/dimensions itopo))))
        frac (:ff-init-frac spec)
        input-size (p/size itopo)
        n-cols (p/size topo)
        one-d? (or (== 1 (count (p/dimensions topo)))
                   (== 1 (count (p/dimensions itopo))))
        [cw ch] (p/dimensions topo)
        [iw ih] (p/dimensions itopo)]
    (if global?
      (let [n-syns (round (* frac input-size))]
        (-&gt;&gt; (random/split-n rng n-cols)
             (mapv (fn [col-rng]
                     (into {}
                           (map (fn [rng]
                                  (let [[rng1 rng2] (random/split rng)]
                                    [(util/rand-int rng1 input-size)
                                     (util/rand rng2 p-lo p-hi)])))
                           (random/split-n col-rng n-syns))))))
      (-&gt;&gt; (random/split-n rng n-cols)
           (mapv (fn [col col-rng]
                   (let [focus-i (if one-d?
                                   (round (* input-size (/ col n-cols)))
                                   (let [[cx cy] (p/coordinates-of-index topo col)]
                                     (p/index-of-coordinates itopo [(round (* iw (/ cx cw)))
                                                                    (round (* ih (/ cy ch)))])))
                         all-ids (vec (p/neighbours-indices itopo focus-i radius))
                         n (round (* frac (count all-ids)))
                         [rng1 rng2] (random/split col-rng)
                         ids (cond
                               (&lt; frac 0.4) ;; for performance:
                               (util/sample rng1 n all-ids)
                               (&lt; frac 1.0)
                               (util/reservoir-sample rng1 n all-ids)
                               :else
                               all-ids)]
                     (into {}
                           (map (fn [id rng]
                                  [id (util/rand rng p-lo p-hi)])
                                ids
                                (random/split-n rng2 (count ids))))))
                 (range))))))</pre></td></tr><tr><td class="docs"><h2>Overlaps</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Given a map <code>exc</code> of the column overlap counts, multiplies the
  excitation value by the corresponding column boosting factor.</p>
</td><td class="codes"><pre class="brush: clojure">(defn apply-overlap-boosting
  [exc boosts]
  (-&gt;&gt; exc
       (reduce-kv (fn [m id x]
                    (let [[col _] id
                          b (get boosts col)]
                      (assoc! m id (* x b))))
                  (transient {}))
       (persistent!)))</pre></td></tr><tr><td class="docs"><h2>Learning</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ff-new-synapse-ids
  [rng ff-bits curr-ids-set col itopo focus-coord radius n-grow]
  (loop [ids ()
         on-bits (util/shuffle rng ff-bits)]
    (if (or (empty? on-bits)
            (&gt;= (count ids) n-grow))
      ids
      (let [id (first ff-bits)]
        (if (curr-ids-set id)
          ;; already have this synapse
          (recur ids (next on-bits))
          ;; check distance
          (let [coord (p/coordinates-of-index itopo id)
                dist (p/coord-distance itopo coord focus-coord)]
            (if (&lt; dist radius)
              ;; ok, choose this for a new synapse
              ;; TODO - ff-potential-frac
              (recur (conj ids id) (next on-bits))
              ;; out of radius
              (recur ids (next on-bits)))))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn grow-new-synapses
  [rng ff-sg col ff-bits itopo radius n-cols n-grow pinit]
  (let [input-size (p/size itopo)
        focus-i (round (* input-size (/ col n-cols)))
        focus-coord (p/coordinates-of-index itopo focus-i)
        new-ids (ff-new-synapse-ids rng ff-bits
                                    (p/in-synapses ff-sg col)
                                    col itopo
                                    focus-coord
                                    radius n-grow)]
    [col new-ids]))</pre></td></tr><tr><td class="docs"><h2>Boosting</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn boost-active-global
  [ads spec]
  (let [a-th (:boost-active-duty-ratio spec)
        maxb (:max-boost spec)
        max-ad (apply max 0 ads)
        crit-ad (double (* a-th max-ad))]
    (mapv (fn [ad]
            (-&gt; (- maxb (* (- maxb 1)
                           (/ ad crit-ad)))
                (max 1.0)))
          ads)))</pre></td></tr><tr><td class="docs"><p>Recalculates boost factors for each column based on its frequency
   of activation (active duty cycle) compared to the maximum from its
   neighbours.</p>
</td><td class="codes"><pre class="brush: clojure">(defn boost-active
  [lyr]
  (let [global? (&gt;= (:ff-potential-radius (:spec lyr)) 1)]
    ;; TODO for local case, partition the column space based on radius...
    (if-not (pos? (:boost-active-duty-ratio (:spec lyr)))
      lyr
      (assoc lyr :boosts
             (boost-active-global (:active-duty-cycles lyr) (:spec lyr))))))</pre></td></tr><tr><td class="docs"><p>Records a set of events with indices <code>is</code> in the vector <code>v</code>
   according to duty cycle period <code>period</code>. As in NuPIC, the formula
   is</p>

<pre>
y[t] = (period-1) * y[t-1]  +  1
       --------------------------
         period
</pre>
</td><td class="codes"><pre class="brush: clojure">(defn update-duty-cycles
  [v is period]
  (let [d (/ 1.0 period)
        decay (* d (dec period))]
    (-&gt; (mapv #(* % decay) v)
        (util/update-each is #(+ % d)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#org.nfrac.comportex.core" name="org.nfrac.comportex.core"><h1 class="project-name">org.nfrac.comportex.core</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>A <em>region</em> is the main composable unit in this library. It
   represents a bank of neurons arranged in columns, responding to an
   array of feed-forward input bits, as well as distal connections to
   itself and possibly other regions.</p>
</td><td class="codes"><pre class="brush: clojure">(ns org.nfrac.comportex.core
  (:require [org.nfrac.comportex.protocols :as p]
            [org.nfrac.comportex.topology :as topology]
            [org.nfrac.comportex.cells :as cells]
            [org.nfrac.comportex.util :as util]
            [org.nfrac.comportex.util.algo-graph :as graph]
            [clojure.set :as set]))</pre></td></tr><tr><td class="docs"><p>A sequence of keywords looking up layers in the region. The first
  is the input layer, the last is the (feed-forward) output layer.</p>
</td><td class="codes"><pre class="brush: clojure">(defn layers
  [rgn]
  (concat (when (:layer-4 rgn) [:layer-4])
          (when (:layer-3 rgn) [:layer-3])))</pre></td></tr><tr><td class="docs"><h1>Sensory = L3</h1>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare sensory-region)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord SensoryRegion
    [layer-3]
  p/PRegion
  (region-activate
    [this ff-bits stable-ff-bits]
    (assoc this
      :layer-3 (p/layer-activate layer-3 ff-bits stable-ff-bits)))
  (region-learn
    [this]
    (if (:freeze? (p/params this))
      this
      (assoc this
        :layer-3 (p/layer-learn layer-3))))
  (region-depolarise
    [this distal-ff-bits apical-fb-bits apical-fb-wc-bits]
    (assoc this
        :layer-3 (p/layer-depolarise layer-3 distal-ff-bits apical-fb-bits apical-fb-wc-bits)))
  p/PTopological
  (topology [_]
    (p/topology layer-3))
  p/PFeedForward
  (ff-topology [_]
    (p/ff-topology layer-3))
  (bits-value [_]
    (p/bits-value layer-3))
  (stable-bits-value [_]
    (p/stable-bits-value layer-3))
  (source-of-bit [_ i]
    (p/source-of-bit layer-3 i))
  p/PFeedBack
  (wc-bits-value [_]
    (p/wc-bits-value layer-3))
  p/PFeedForwardMotor
  (ff-motor-topology [_]
    topology/empty-topology)
  (motor-bits-value
    [_]
    (sequence nil))
  p/PTemporal
  (timestep [_]
    (p/timestep layer-3))
  p/PParameterised
  (params [_]
    (p/params layer-3))
  p/PInterruptable
  (break [this mode]
    (assoc this
           :layer-3 (p/break layer-3 mode)))
  p/PRestartable
  (restart [this]
    (sensory-region (p/params this))))</pre></td></tr><tr><td class="docs"><p>Constructs a cortical region with one layer.</p>

<p>  <code>spec</code> is the parameter specification map. See documentation on
  <code>cells/parameter-defaults</code> for possible keys. Any keys given here
  will override those default values.</p>
</td><td class="codes"><pre class="brush: clojure">(defn sensory-region
  [spec]
  (let [unk (set/difference (set (keys spec))
                            (set (keys cells/parameter-defaults)))]
    (when (seq unk)
      (println &quot;Warning: unknown keys in spec:&quot; unk)))
  (map-&gt;SensoryRegion
   {:layer-3 (cells/layer-of-cells spec)}))</pre></td></tr><tr><td class="docs"><h1>Sensorimotor = L3 + L4</h1>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare sensorimotor-region)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord SensoriMotorRegion
    [layer-4 layer-3]
  p/PRegion
  (region-activate
    [this ff-bits stable-ff-bits]
    (let [l4 (p/layer-activate layer-4 ff-bits stable-ff-bits)
          l3 (p/layer-activate layer-3
                               (p/bits-value l4)
                               (p/stable-bits-value l4))]
      (assoc this
       :layer-4 l4
       :layer-3 l3)))
  (region-learn
    [this]
    (if (:freeze? (p/params this))
      this
      (assoc this
        :layer-4 (p/layer-learn layer-4)
        :layer-3 (p/layer-learn layer-3))))
  (region-depolarise
    [this distal-ff-bits apical-fb-bits apical-fb-wc-bits]
    ;; TODO feedback from L3 to L4?
    (let [l4 (p/layer-depolarise layer-4 distal-ff-bits #{} #{})
          l3 (p/layer-depolarise layer-3 #{} apical-fb-bits apical-fb-wc-bits)]
     (assoc this
       :layer-4 l4
       :layer-3 l3)))
  p/PTopological
  (topology [_]
    (p/topology layer-3))
  p/PFeedForward
  (ff-topology [_]
    (p/ff-topology layer-3))
  (bits-value [_]
    (p/bits-value layer-3))
  (stable-bits-value [_]
    (p/stable-bits-value layer-3))
  (source-of-bit [_ i]
    (p/source-of-bit layer-3 i))
  p/PFeedBack
  (wc-bits-value [_]
    (p/wc-bits-value layer-3))
  p/PFeedForwardMotor
  (ff-motor-topology [_]
    ;; TODO
    topology/empty-topology)
  (motor-bits-value
    [_]
    (sequence nil))
  p/PTemporal
  (timestep [_]
    (p/timestep layer-4))
  p/PParameterised
  (params [_]
    (p/params layer-4))
  p/PInterruptable
  (break [this mode]
    (assoc this
           :layer-4 (p/break layer-4 mode)
           :layer-3 (p/break layer-3 mode)))
  p/PRestartable
  (restart [this]
    (sensorimotor-region (p/params this))))</pre></td></tr><tr><td class="docs"><p>Constructs a cortical region with two layers. <code>spec</code> can contain
  nested maps under :layer-3 and :layer-4 that are merged in for
  specific layers.</p>

<p>  This sets <code>:lateral-synapses? false</code> in Layer 4, and true in Layer
  3.</p>
</td><td class="codes"><pre class="brush: clojure">(defn sensorimotor-region
  [spec]
  (let [unk (set/difference (set (keys spec))
                            (set (keys cells/parameter-defaults))
                            #{:layer-4 :layer-3})]
    (when (seq unk)
      (println &quot;Warning: unknown keys in spec:&quot; unk)))
  (let [l4-spec (-&gt; (assoc spec
                      :lateral-synapses? false)
                    (util/deep-merge (:layer-4 spec))
                    (dissoc :layer-3 :layer-4))
        l4 (cells/layer-of-cells l4-spec)
        l3-spec (-&gt; (assoc spec
                      :input-dimensions (p/dimensions (p/ff-topology l4))
                      :distal-motor-dimensions [0]
                      :lateral-synapses? true)
                    (util/deep-merge (:layer-3 spec))
                    (dissoc :layer-3 :layer-4))
        l3 (cells/layer-of-cells l3-spec)]
    (map-&gt;SensoriMotorRegion
    {:layer-3 l3
     :layer-4 l4})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord SenseNode
    [topo bits sensory? motor?]
  p/PTopological
  (topology [_]
    topo)
  p/PFeedForward
  (ff-topology [_]
    (if sensory?
      topo
      topology/empty-topology))
  (bits-value
    [_]
    (if sensory?
      bits
      (sequence nil)))
  (stable-bits-value
    [_]
    (sequence nil))
  (source-of-bit
    [_ i]
    [i])
  p/PFeedForwardMotor
  (ff-motor-topology [_]
    (if motor?
      topo
      topology/empty-topology))
  (motor-bits-value
    [_]
    (if motor?
      bits
      (sequence nil)))
  p/PSense
  (sense-activate [this bits]
    (assoc this :bits bits)))</pre></td></tr><tr><td class="docs"><p>Creates a sense node with given topology, matching the encoder that
  will generate its bits.</p>
</td><td class="codes"><pre class="brush: clojure">(defn sense-node
  [topo sensory? motor?]
  (-&gt;SenseNode topo () sensory? motor?))</pre></td></tr><tr><td class="docs"><h2>Region Networks</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Returns the total bit set from a collection of sources satisfying
   <code>PFeedForward</code> or <code>PFeedForwardMotor</code>. <code>flavour</code> should
   be :standard, :stable or :motor.</p>
</td><td class="codes"><pre class="brush: clojure">(defn combined-bits-value
  [ffs flavour]
  (let [topo-fn (case flavour
                  (:standard
                   :stable
                   :wc) p/ff-topology
                   :motor p/ff-motor-topology)
        bits-fn (case flavour
                  :standard p/bits-value
                  :stable p/stable-bits-value
                  :wc p/wc-bits-value
                  :motor p/motor-bits-value)
        widths (map (comp p/size topo-fn) ffs)]
    (-&gt;&gt; (map bits-fn ffs)
         (util/align-indices widths)
         (into #{}))))</pre></td></tr><tr><td class="docs"><p>Taking the index of an input bit as received by the given region,
  return its source element as [k id] where k is the key of the source
  region or sense, and id is the index adjusted to refer to the output
  of that source.</p>

<p>  If i is an index into the feed-forward field, type is :ff-deps, if i
  is an index into the feed-back field, type is :fb-deps.</p>
</td><td class="codes"><pre class="brush: clojure">(defn source-of-incoming-bit
  ([htm rgn-id i type]
     (source-of-incoming-bit htm rgn-id i type p/ff-topology))
  ([htm rgn-id i type topology-fn]
     (let [senses (:senses htm)
           regions (:regions htm)
           node-ids (get-in htm [type rgn-id])]
       (loop [node-ids node-ids
              offset 0]
         (when-let [node-id (first node-ids)]
           (let [node (or (senses node-id)
                          (regions node-id))
                 width (long (p/size (topology-fn node)))]
             (if (&lt; i (+ offset width))
               [node-id (- i offset)]
               (recur (next node-ids)
                      (+ offset width)))))))))</pre></td></tr><tr><td class="docs"><p>Returns [src-id src-lyr-id j] where src-id may be a region key or
   sense key, src-lyr-id is nil for senses, and j is the index into
   the output of the source.</p>
</td><td class="codes"><pre class="brush: clojure">(defn source-of-distal-bit
  [htm rgn-id lyr-id i]
  (let [rgn (get-in htm [:regions rgn-id])
        lyr (get rgn lyr-id)
        spec (p/params lyr)
        [src-type adj-i] (cells/id-&gt;source spec i)]
    (case src-type
      :this [rgn-id lyr-id i]
      :ff (if (= lyr-id (first (layers rgn)))
            (let [[src-id j] (source-of-incoming-bit htm rgn-id adj-i :ff-deps
                                                     p/ff-motor-topology)
                  src-rgn (get-in htm [:regions src-id])]
              [src-id
               (when src-rgn (last (layers src-rgn))) ;; nil for senses
               j])
            ;; this is not the input layer; source must be within region
            [rgn-id (first (layers rgn)) i]))))</pre></td></tr><tr><td class="docs"><p>Returns [src-id src-lyr-id j] where src-id is a region key, and j
  is the index into the output of the region.</p>
</td><td class="codes"><pre class="brush: clojure">(defn source-of-apical-bit
  [htm rgn-id lyr-id i]
  (let [rgn (get-in htm [:regions rgn-id])
        lyr (get rgn lyr-id)
        spec (p/params lyr)]
    (if (= lyr-id (last (layers rgn)))
      (let [[src-id j] (source-of-incoming-bit htm rgn-id i :fb-deps)
            src-rgn (get-in htm [:regions src-id])]
        [src-id
         (last (layers src-rgn))
         j])
      ;; this is not the top layer; source must be within region
      [rgn-id (last (layers rgn)) i])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn topo-union
  [topos]
  (apply topology/combined-dimensions
         (map p/dimensions topos)))</pre></td></tr><tr><td class="docs"><p>TODO - better way to do this</p>
</td><td class="codes"><pre class="brush: clojure">(defn fb-dim-from-spec
  [spec]
  (let [spec (util/deep-merge cells/parameter-defaults spec)]
    (topology/make-topology (conj (:column-dimensions spec)
                                  (:depth spec)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(do #?(:cljs (def pmap map)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord RegionNetwork
    [ff-deps fb-deps strata sensors senses regions]
  p/PHTM
  (htm-sense
    [this inval mode]
    (let [sm (reduce-kv (fn [m k sense-node]
                          (if (case mode
                                :sensory (:sensory? sense-node)
                                :motor (:motor? sense-node)
                                nil true)
                            (let [[selector encoder] (get sensors k)
                                  in-bits (-&gt;&gt; (p/extract selector inval)
                                               (p/encode encoder))]
                              (assoc m k (p/sense-activate sense-node in-bits)))
                            m))
                        senses
                        senses)]
      (assoc this
             :senses sm
             :input-value inval)))
  (htm-activate
    [this]
    (let [rm (-&gt; (reduce
                  (fn [m stratum]
                    (-&gt;&gt; stratum
                         (pmap (fn [id]
                                 (let [region (regions id)
                                       ff-ids (ff-deps id)
                                       ffs (map m ff-ids)]
                                   (p/region-activate
                                    region
                                    (combined-bits-value ffs :standard)
                                    (combined-bits-value ffs :stable)))))
                         (zipmap stratum)
                         (into m)))
                  senses
                  ;; drop 1st stratum i.e. drop the sensory inputs
                  (rest strata))
                 ;; get rid of the sense nodes which were seeded into the reduce
                 (select-keys (keys regions)))]
      (assoc this :regions rm)))
  (htm-learn
    [this]
    (let [rm (-&gt;&gt; (vals regions)
                  (pmap p/region-learn)
                  (zipmap (keys regions)))]
      (assoc this :regions rm)))
  (htm-depolarise
    [this]
    (let [rm (-&gt;&gt; regions
                  (pmap (fn [[id region]]
                          (let [ff-ids (ff-deps id)
                                fb-ids (fb-deps id)
                                ffs (map #(or (senses %) (regions %))
                                         ff-ids)
                                fbs (map regions fb-ids)]
                            (p/region-depolarise
                             region
                             (combined-bits-value ffs :motor)
                             (combined-bits-value fbs :standard)
                             (combined-bits-value fbs :wc)))))
                  (zipmap (keys regions)))]
      (assoc this :regions rm)))
  p/PTemporal
  (timestep [_]
    (p/timestep (first (vals regions))))
  p/PInterruptable
  (break [this mode]
    (assoc this
           :regions (-&gt;&gt; (vals regions)
                         (map #(p/break % mode))
                         (zipmap (keys regions)))))
  p/PRestartable
  (restart [this]
    (assoc this
      :regions (-&gt;&gt; (vals regions)
                    (pmap p/restart)
                    (zipmap (keys regions))))))</pre></td></tr><tr><td class="docs"><p>A sequence of the keys of all regions in topologically-sorted
  order. If <code>n-levels</code> is provided, only the regions from that many
  hierarchical levels are included. So 1 gives the first tier directly
  receiving sensory inputs.</p>
</td><td class="codes"><pre class="brush: clojure">(defn region-keys
  ([htm]
   (region-keys htm (dec (count (:strata htm)))))
  ([htm n-levels]
   ;; topologically sorted: drop 1st stratum i.e. drop the sensory inputs
   (apply concat (take n-levels (rest (:strata htm))))))</pre></td></tr><tr><td class="docs"><p>A sequence of the keys of all sense nodes.</p>
</td><td class="codes"><pre class="brush: clojure">(defn sense-keys
  [htm]
  (first (:strata htm)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn region-seq
  [htm]
  (map (:regions htm) (region-keys htm)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- in-vals-not-keys
  [deps]
  (let [have-deps (set (keys deps))
        are-deps (set (apply concat (vals deps)))]
    (set/difference are-deps have-deps)))</pre></td></tr><tr><td class="docs"><p>Builds a network of regions and senses from the given dependency
  map. The keywords used in the dependency map are used to look up
  region-building functions, parameter specifications, and sensors in
  the remaining argments.</p>

<p>  Sensors are defined to be the form <code>[selector encoder]</code>, satisfying
  protocols PSelector and PEncoder respectively. Sensors in the
  <code>main-sensors</code> map can make activating (proximal) connections while
  those in the <code>motor-sensors</code> map can make depolarising (distal)
  connections. The same sensor may also be included in both maps.</p>

<p>  For each node, the combined dimensions of its feed-forward sources
  is calculated and used to set the <code>:input-dimensions</code> parameter in
  its <code>spec</code>. Also, the combined dimensions of feed-forward motor
  inputs are used to set the <code>:distal-motor-dimensions</code> parameter, and
  the combined dimensions of its feed-back superior regions is used to
  set the <code>:distal-topdown-dimensions</code> parameter. The updated spec is
  passed to a function (typically <code>sensory-region</code>) to build a
  region. The build function is found by calling <code>region-builders</code>
  with the region id keyword.</p>

<p>  For example to build the network <code>inp -&gt; v1 -&gt; v2</code>:</p>

<p>   `
   (region-network
    {:v1 [:input]
     :v2 [:v1]}
    {:v1 sensory-region
     :v2 sensory-region}
    {:v1 spec
     :v2 spec}
    {:input sensor}
    nil)`</p>
</td><td class="codes"><pre class="brush: clojure">(defn region-network
  [ff-deps region-builders region-specs main-sensors motor-sensors]
  {:pre [;; all regions must have dependencies
         (every? ff-deps (keys region-specs))
         ;; all sense nodes must not have dependencies
         (every? (in-vals-not-keys ff-deps) (keys main-sensors))
         (every? (in-vals-not-keys ff-deps) (keys motor-sensors))
         ;; all ids in dependency map must be defined
         (every? region-specs (keys ff-deps))
         (every? (merge main-sensors motor-sensors) (in-vals-not-keys ff-deps))]}
  (merge-with (fn [main-sensor motor-sensor]
                (assert (= main-sensor motor-sensor)
                        &quot;Equal keys in main-sensors and motor-sensors must be same sensor.&quot;))
              main-sensors motor-sensors)
  (let [all-ids (into (set (keys ff-deps))
                      (in-vals-not-keys ff-deps))
        ff-dag (graph/directed-graph all-ids ff-deps)
        strata (graph/dependency-list ff-dag)
        fb-deps (-&gt;&gt; (graph/reverse-graph ff-dag)
                         :neighbors
                         (util/remap seq))
        ;; sensors may appear with same key in both main- and motor-
        sm (-&gt;&gt; (merge-with merge
                            (util/remap (fn [[_ e]]
                                          {:topo (p/topology e), :sensory? true})
                                        main-sensors)
                            (util/remap (fn [[_ e]]
                                          {:topo (p/topology e), :motor? true})
                                        motor-sensors))
                (util/remap (fn [{:keys [topo sensory? motor?]}]
                              (sense-node topo sensory? motor?))))
        rm (-&gt; (reduce (fn [m id]
                         (let [spec (region-specs id)
                               build-region (region-builders id)
                               ;; feed-forward
                               ff-ids (ff-deps id)
                               ffs (map m ff-ids)
                               ff-dim (topo-union (map p/ff-topology ffs))
                               ffm-dim (topo-union  (map p/ff-motor-topology ffs))
                               ;; top-down feedback (if any)
                               fb-ids (fb-deps id)
                               fb-specs (map region-specs fb-ids)
                               fb-dim (topo-union (map fb-dim-from-spec fb-specs))]
                           (-&gt;&gt; (assoc spec :input-dimensions ff-dim
                                       :distal-motor-dimensions ffm-dim
                                       :distal-topdown-dimensions fb-dim)
                                (build-region)
                                (assoc m id))))
                       sm
                       ;; topological sort. drop 1st stratum i.e. senses
                       (apply concat (rest strata)))
               ;; get rid of the sense nodes which were seeded into the reduce
               (select-keys (keys region-specs)))]
    (map-&gt;RegionNetwork
     {:ff-deps ff-deps
      :fb-deps fb-deps
      :strata strata
      :sensors (merge main-sensors motor-sensors)
      :senses sm
      :regions rm})))</pre></td></tr><tr><td class="docs"><p>Constructs an HTM network consisting of n regions in a linear
  series. The regions are given keys :rgn-0, :rgn-1, etc. Senses feed
  only to the first region. Their sensors are given in a map with
  keyword keys. Sensors are defined to be the form <code>[selector encoder]</code>.</p>

<p>  This is a convenience wrapper around <code>region-network</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn regions-in-series
  ([n build-region specs sensors]
   (regions-in-series
    n build-region specs sensors nil))
  ([n build-region specs main-sensors motor-sensors]
   {:pre [(sequential? specs)
          (= n (count (take n specs)))]}
   (let [rgn-keys (map #(keyword (str &quot;rgn-&quot; %)) (range n))
         sense-keys (keys (merge main-sensors motor-sensors))
         ;; make {:rgn-0 [senses], :rgn-1 [:rgn-0], :rgn-2 [:rgn-1], ...}
         deps (zipmap rgn-keys (list* sense-keys (map vector rgn-keys)))]
     (region-network deps
                     (constantly build-region)
                     (zipmap rgn-keys specs)
                     main-sensors
                     motor-sensors))))</pre></td></tr><tr><td class="docs"><h2>Stats</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Returns a map with the frequencies of columns in states
  <code>:active</code> (bursting), <code>:predicted</code>, <code>:active-predicted</code>. Note that
  these are distinct categories. The names are possibly misleading.
  Argument <code>layer-fn</code> is called on the region to obtain a layer of
  cells; if omitted it defaults to the output layer.</p>
</td><td class="codes"><pre class="brush: clojure">(defn column-state-freqs
  ([rgn]
     (column-state-freqs rgn (last (layers rgn))))
  ([rgn layer-fn]
     (let [lyr (layer-fn rgn)
           a-cols (p/active-columns lyr)
           ppc (p/prior-predictive-cells lyr)
           pp-cols (into #{} (map first ppc))
           hit-cols (set/intersection pp-cols a-cols)
           col-states (merge (zipmap pp-cols (repeat :predicted))
                             (zipmap a-cols (repeat :active))
                             (zipmap hit-cols (repeat :active-predicted)))]
       (-&gt; {:active 0, :predicted 0, :active-predicted 0}
           (merge (frequencies (vals col-states)))
           (assoc :timestep (p/timestep rgn)
                  :size (p/size (p/topology rgn)))))))</pre></td></tr><tr><td class="docs"><h2>Tracing columns back to senses</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Returns a map from sense bit index to the number of connections to
  it from cells in the predictive state.</p>
</td><td class="codes"><pre class="brush: clojure">(defn layer-predicted-bit-votes
  [lyr]
  (let [psg (:proximal-sg lyr)]
    (-&gt;&gt; (p/predictive-cells lyr)
         (map first)
         (reduce (fn [m col]
                   ;; TODO: other proximal segments
                   (let [ids (p/sources-connected-to psg [col 0 0])]
                     (reduce (fn [m id]
                               (assoc! m id (inc (get m id 0))))
                             m ids)))
                 (transient {}))
         (persistent!))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn predicted-bit-votes
  [rgn]
  (let [lyr (get rgn (first (layers rgn)))]
    (layer-predicted-bit-votes lyr)))</pre></td></tr><tr><td class="docs"><p>Returns the first index that corresponds with <code>ff-id</code> within the
  feedforward input to <code>rgn-id</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ff-base
  [htm rgn-id ff-id]
  (let [{:keys [senses regions]} htm]
    (-&gt;&gt; (get-in htm [:ff-deps rgn-id])
         (map (fn [id]
                [id
                 (or (senses id)
                     (regions id))]))
         (take-while (fn [[id _]]
                       (not= id ff-id)))
         (map (fn [[id ff]]
                ff))
         (map p/ff-topology)
         (map p/size)
         (reduce + 0))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn predictions
  [htm sense-id n-predictions]
  (let [sense-width (-&gt; (get-in htm [:senses sense-id])
                        p/ff-topology
                        p/size)
        pr-votes (-&gt;&gt; (get-in htm [:fb-deps sense-id])
                      (mapcat (fn [rgn-id]
                                (let [rgn (get-in htm [:regions rgn-id])
                                      start (ff-base htm rgn-id sense-id)
                                      end (+ start sense-width)]
                                  (-&gt;&gt; (predicted-bit-votes rgn)
                                       (keep (fn [[id votes]]
                                               (when (and (&lt;= start id)
                                                          (&lt; id end))
                                                 [(- id start) votes])))))))
                      (reduce (fn [m [id votes]]
                                (assoc m id
                                       (+ (get m id 0)
                                          votes)))
                              {}))
        [_ encoder] (get-in htm [:sensors sense-id])]
    (p/decode encoder pr-votes n-predictions)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- zap-fewer
  [n xs]
  (if (&lt; (count xs) n) (empty xs) xs))</pre></td></tr><tr><td class="docs"><p>Calculates the various sources contributing to total excitation
  level of each of the <code>cell-ids</code> in the given layer. Returns a map
  keyed by these cell ids. Each cell value is a map with keys</p>

<ul>
<li>:total - number.</li>
<li>:proximal-unstable - a map keyed by source region/sense id.</li>
<li>:proximal-stable - a map keyed by source region/sense id.</li>
<li>:distal - a map keyed by source region/sense id.</li>
<li>:boost - number.</li>
<li>:temporal-pooling - number.</li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(defn cell-excitation-breakdowns
  [htm prior-htm rgn-id lyr-id cell-ids]
  (let [rgn (get-in htm [:regions rgn-id])
        lyr (get-in htm [:regions rgn-id lyr-id])
        prior-lyr (get-in prior-htm [:regions rgn-id lyr-id])
        spec (:spec lyr)
        ff-stim-thresh (:stimulus-threshold (:proximal spec))
        d-stim-thresh (:stimulus-threshold (:distal spec))
        a-stim-thresh (:stimulus-threshold (:apical spec))
        distal-weight (:distal-vs-proximal-weight spec)
        tp-fall (:temporal-pooling-fall spec)
        state (:state lyr)
        prior-state (:state prior-lyr)
        distal-state (:distal-state prior-lyr)
        apical-state (:apical-state prior-lyr)
        ;; inputs to layer
        ff-bits (:in-ff-bits state)
        ff-s-bits (:in-stable-ff-bits state)
        ff-b-bits (set/difference ff-bits ff-s-bits)
        distal-bits (:on-bits distal-state)
        apical-bits (:on-bits apical-state)
        is-input-layer? (= lyr-id (first (layers rgn)))
        ff-bits-srcs (if is-input-layer?
                       (into {}
                             (map (fn [i]
                                    (let [[k _] (source-of-incoming-bit
                                                 htm rgn-id i :ff-bits)]
                                      [i k])))
                             ff-bits)
                       (constantly rgn-id))
        distal-bits-srcs (into {}
                               (map (fn [i]
                                      (let [[k _] (source-of-distal-bit
                                                   htm rgn-id lyr-id i)]
                                        [i k])))
                               distal-bits)
        apical-bits-srcs (into {}
                               (map (fn [i]
                                      (let [[k _] (source-of-apical-bit
                                                   htm rgn-id lyr-id i)]
                                        [i k])))
                               apical-bits)
        ;; synapse graphs - pre-learning state so from prior time step
        psg (:proximal-sg prior-lyr)
        dsg (:distal-sg prior-lyr)
        asg (:apical-sg prior-lyr)
        ;; internal sources
        boosts (:boosts prior-lyr)
        p-tp-exc (:temporal-pooling-exc prior-state)]
    (into {}
          (map (fn [cell-id]
                 (let [[col ci] cell-id
                       ;; breakdown of proximal excitation by source
                       ff-seg-path (get (:matching-ff-seg-paths state) [col 0])
                       ff-conn-sources (when ff-seg-path
                                         (p/sources-connected-to psg ff-seg-path))
                       active-ff-b (-&gt;&gt; (filter ff-b-bits ff-conn-sources)
                                        (zap-fewer ff-stim-thresh))
                       active-ff-s (-&gt;&gt; (filter ff-s-bits ff-conn-sources)
                                        (zap-fewer ff-stim-thresh))
                       ff-b-by-src (frequencies (map ff-bits-srcs active-ff-b))
                       ff-s-by-src (frequencies (map ff-bits-srcs active-ff-s))
                       ;; breakdown of distal excitation by source
                       d-seg-path (get (:matching-seg-paths distal-state) cell-id)
                       d-conn-sources (when d-seg-path
                                        (p/sources-connected-to dsg d-seg-path))
                       active-d (-&gt;&gt; (filter distal-bits d-conn-sources)
                                     (zap-fewer d-stim-thresh))
                       d-by-src (-&gt;&gt; (frequencies (map distal-bits-srcs active-d))
                                     (util/remap #(* % distal-weight)))
                       ;; same for apical
                       a-seg-path (get (:matching-seg-paths apical-state) cell-id)
                       a-conn-sources (when a-seg-path
                                        (p/sources-connected-to asg a-seg-path))
                       active-a (-&gt;&gt; (filter apical-bits a-conn-sources)
                                     (zap-fewer a-stim-thresh))
                       a-by-src (-&gt;&gt; (frequencies (map apical-bits-srcs active-a))
                                     (util/remap #(* % distal-weight)))
                       ;; excitation levels
                       b-overlap (count active-ff-b)
                       s-overlap (count active-ff-s)
                       d-a-exc (-&gt;&gt; (+ (count active-d) (count active-a))
                                    (* distal-weight))
                       ;; effect of boosting
                       overlap (+ b-overlap s-overlap)
                       boost-amt (* overlap (- (get boosts col) 1.0))
                       ;; temporal pooling excitation (see cells/decay-tp)
                       prior-tp (max 0 (- (get p-tp-exc cell-id 0.0)
                                          tp-fall
                                          b-overlap))
                       ;; total excitation
                       total (+ b-overlap s-overlap boost-amt prior-tp d-a-exc)]
                   [cell-id {:total total
                             :proximal-unstable ff-b-by-src
                             :proximal-stable ff-s-by-src
                             :boost boost-amt
                             :temporal-pooling prior-tp
                             :distal (merge d-by-src a-by-src)}])))
          cell-ids)))</pre></td></tr><tr><td class="docs"><p>Takes an excitation breakdown such as returned under one key from
  cell-excitation-breakdowns, and updates each numeric component with
  the function f. Key :total will be updated accordingly. The default
  is to scale the values to a total of 1.0. To aggregate breakdowns,
  use <code>(util/deep-merge-with +)</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn update-excitation-breakdown
  ([breakdown]
   (let [total (:total breakdown)]
     (update-excitation-breakdown breakdown #(/ % total))))
  ([breakdown f]
   (persistent!
    (reduce-kv (fn [m k v]
                 (let [new-v (if (map? v)
                               (util/remap f v)
                               (f v))
                       v-total (if (map? v)
                                 (reduce + (vals new-v))
                                 new-v)]
                   (assoc! m k new-v
                           :total (+ (get m :total) v-total))))
               (transient {:total 0.0})
               (dissoc breakdown :total)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#org.nfrac.comportex.cortical-io" name="org.nfrac.comportex.cortical-io"><h1 class="project-name">org.nfrac.comportex.cortical-io</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns org.nfrac.comportex.cortical-io
  (:require [org.nfrac.comportex.protocols :as p]
            [org.nfrac.comportex.topology :as topology]
            [org.nfrac.comportex.encoders :as enc]
            [org.nfrac.comportex.util :as util]
            [clojure.string :as str]
            #?(:clj [clj-http.client :as http]
               :cljs [cljs-http.client :as http])
            #?(:cljs [cljs.core.async :refer [&lt;!]]))
  #?(:cljs (:require-macros [cljs.core.async.macros :refer [go]])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def base-uri &quot;http://api.cortical.io/rest&quot;)
(def query-params {:retina_name &quot;en_associative&quot;})
(def retina-dim [128 128])
(def retina-size (apply * retina-dim))
(def max-bits 512)
(def min-votes 2)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn request-fingerprint
  [api-key term]
  (http/post (str base-uri &quot;/expressions&quot;)
             {:query-params query-params
              :content-type &quot;application/json&quot;
              :as :json
              #?(:clj :form-params, :cljs :json-params) {:term term}
              :with-credentials? false
              :throw-exceptions false
              :headers {&quot;api-key&quot; api-key}}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn request-similar-terms
  [api-key bits max-n]
  (http/post (str base-uri &quot;/expressions/similar_terms&quot;)
             {:query-params (assoc query-params
                              :get_fingerprint true
                              :max_results max-n)
              :content-type &quot;application/json&quot;
              :as :json
              #?(:clj :form-params, :cljs :json-params) {:positions (sort bits)}
              :with-credentials? false
              :throw-exceptions false
              :headers {&quot;api-key&quot; api-key}}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn random-sdr
  [term]
  (enc/unique-sdr term retina-size (* retina-size 0.02)))</pre></td></tr><tr><td class="docs"><p>Maps a retina fingerprint index to another index which is spatially
   scrambled. Meaning that direct neighbours in the retina are now
   offset from each other by around 17 units. This is a complete
   mapping, i.e. the following holds:</p>

<p>   `
   (= (set (map scramble-bit (range retina-size)))
      (set (range retina-size)))`.</p>
</td><td class="codes"><pre class="brush: clojure">(defn scramble-bit
  [i]
  (mod (* i 17) retina-size))</pre></td></tr><tr><td class="docs"><p>don't ask me how i got this to work</p>
</td><td class="codes"><pre class="brush: clojure">(defn unscramble-bit
  [j]
  (-&gt; (rem j 17)
      (* 13) ;; == (rem retina-size 17)
      (mod 17)
      (* retina-size)
      (+ j)
      (quot 17)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn scramble-bitset
  [bits]
  (map scramble-bit bits))</pre></td></tr><tr><td class="docs"><p>assoc, but not if the key already has a (truthy) value.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ?assoc
  [m k v]
  (if (m k) m (assoc m k v)))</pre></td></tr><tr><td class="docs"><p>Makes a request to cortical.io to look up the fingerprint for the
   term, and stores it in the given cache atom. In Clojure this is a
   synchonous call and returns the fingerprint bit-set. In
   Clojurescript this is an asynchronous call and returns a channel.</p>
</td><td class="codes"><pre class="brush: clojure">(defn cache-fingerprint!
  [api-key cache term]
  (let [term (str/lower-case term)
        handle (fn [result]
                 (if (http/unexceptional-status? (:status result))
                   (set (get-in result [:body :positions]))
                   (do (println &quot;cortical.io lookup of term failed:&quot; term)
                       (println result)
                       (random-sdr term))))]
    #?(:clj   ;; clj - synchronous
       (let [result (request-fingerprint api-key term)]
         (swap! cache ?assoc term (handle result)))
       :cljs  ;; cljs - asynchronous
       (go
        (let [result (&lt;! (request-fingerprint api-key term))]
          (swap! cache ?assoc term (handle result)))))))</pre></td></tr><tr><td class="docs"><p>Looks up a fingerprint for the term, being a set of active indices,
   in the cache. If it is not found (which should not happen, it
   should be preloaded from the web service), the term is assigned a
   new random SDR.</p>
</td><td class="codes"><pre class="brush: clojure">(defn get-fingerprint
  [cache term]
  (let [term (str/lower-case term)]
    (or (get @cache term)
        (get (swap! cache ?assoc term
                    (do (println &quot;no fingerprint in cache for term:&quot; term
                                 &quot;- generating a random one&quot;)
                        (random-sdr term)))
             term))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn elect-bits
  [bit-votes min-votes max-bits]
  (loop [min-votes min-votes]
    (let [bits (keep (fn [[i n]]
                       (when (&gt;= n min-votes) i))
                     bit-votes)]
      (if (&gt; (count bits) max-bits)
        (recur (inc min-votes))
        bits))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn cortical-io-encoder
  [api-key cache &amp; {:keys [decode-locally? spatial-scramble?]}]
  (let [topo (topology/make-topology retina-dim)]
    (reify
      p/PTopological
      (topology [_]
        topo)
      p/PEncoder
      (encode
        [_ term]
        (if (seq term)
          (cond-&gt;
           (get-fingerprint cache term)
           spatial-scramble? (scramble-bitset))
          (sequence nil)))
      (decode
        [this bit-votes n]
        (let [bit-votes (if spatial-scramble?
                          (zipmap (map unscramble-bit (keys bit-votes))
                                  (vals bit-votes))
                          bit-votes)]
          (if decode-locally?
            (-&gt;&gt; (enc/decode-by-brute-force this (keys @cache) bit-votes)
                 (take n))
            ;; otherwise - remote request for similar terms
            (let [bits (elect-bits bit-votes min-votes max-bits)]
              (if (empty? bits)
                []
                (let [total-votes (apply + (vals bit-votes))
                      handle
                      (fn [result]
                        (if (http/unexceptional-status? (:status result))
                          (-&gt;&gt; (:body result)
                               (map (fn [item]
                                      (let [x-bits (set (get-in item [:fingerprint
                                                                      :positions]))]
                                        (println &quot;received prediction results.&quot;)
                                        (println &quot;x-bits =&quot; x-bits)
                                        (println &quot;bits =&quot; bits)
                                        (-&gt; (enc/prediction-stats x-bits bit-votes
                                                                  total-votes)
                                            (assoc :value (get item :term))))))
                               (take n))
                          (println result)))]
                  #?(:clj  ;; clj - synchronous
                     (handle (request-similar-terms api-key bits n))
                     :cljs ;; cljs - asynchronous
                     {:channel
                     (go
                      (handle (&lt;! (request-similar-terms api-key bits n))))}))))))))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#org.nfrac.comportex.encoders" name="org.nfrac.comportex.encoders"><h1 class="project-name">org.nfrac.comportex.encoders</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Methods of encoding data as distributed bit sets, for feeding as
   input to a cortical region.</p>
</td><td class="codes"><pre class="brush: clojure">(ns org.nfrac.comportex.encoders
  (:require [org.nfrac.comportex.protocols :as p]
            [org.nfrac.comportex.topology :as topology]
            [org.nfrac.comportex.util :as util]
            [clojure.test.check.random :as random]))</pre></td></tr><tr><td class="docs"><h1>Selectors</h1>

<p>Implemented as values not functions for serializability.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol p/PSelector
  #?(:clj clojure.lang.Keyword
     :cljs cljs.core.Keyword)
  (extract [this state]
    (get state this))
  #?(:clj clojure.lang.IPersistentVector
     :cljs cljs.core.PersistentVector)
  (extract [this state]
    (get-in state this)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord VecSelector
    [selectors]
  p/PSelector
  (extract [_ state]
    (mapv p/extract selectors (repeat state))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn vec-selector
  [&amp; selectors]
  (-&gt;VecSelector selectors))</pre></td></tr><tr><td class="docs"><h1>Decoding</h1>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn prediction-stats
  [x-bits bit-votes total-votes]
  ;; calculate overlaps of prediction `x` bits with all votes
  (let [o-votes (select-keys bit-votes x-bits)
        total-o-votes (apply + (vals o-votes))
        o-bits (keys o-votes)]
    {:bit-coverage (/ (count o-bits)
                      (max 1 (count x-bits)))
     :bit-precision (/ (count o-bits)
                       (max 1 (count bit-votes)))
     :votes-frac (/ total-o-votes
                    (max 1 total-votes))
     :votes-per-bit (/ total-o-votes
                       (max 1 (count x-bits)))}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn decode-by-brute-force
  [e try-values bit-votes]
  (let [total-votes (apply + (vals bit-votes))]
    (when (pos? total-votes)
      (-&gt;&gt; try-values
           (map (fn [x]
                  (let [x-bits (p/encode e x)]
                    (-&gt; (prediction-stats x-bits bit-votes total-votes)
                        (assoc :value x)))))
           (filter (comp pos? :votes-frac))
           (sort-by (juxt :votes-frac :bit-coverage :bit-precision))
           reverse))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn unaligned-bit-votes
  [widths aligned]
  (let [[is vs] (-&gt;&gt; aligned
                     (into (sorted-map))
                     ((juxt keys vals)))
        partitioned-is (util/unalign-indices widths is)
        partitioned-vs (util/splits-at (map count partitioned-is) vs)]
    (map zipmap partitioned-is partitioned-vs)))</pre></td></tr><tr><td class="docs"><h1>Encoders</h1>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord ConcatEncoder
    [encoders]
  p/PTopological
  (topology [_]
    (let [dim (-&gt;&gt; (map p/dims-of encoders)
                   (apply topology/combined-dimensions))]
      (topology/make-topology dim)))
  p/PEncoder
  (encode
    [_ xs]
    (let [bit-widths (map p/size-of encoders)]
      (-&gt;&gt; xs
           (map p/encode encoders)
           (util/align-indices bit-widths))))
  (decode
    [_ bit-votes n-values]
    (let [bit-widths (map p/size-of encoders)]
      (map #(p/decode % %2 n-values)
           encoders
           (unaligned-bit-votes bit-widths bit-votes)))))</pre></td></tr><tr><td class="docs"><p>Returns an encoder for a sequence of values, where each is encoded
  separately before the results are concatenated into a single
  sense. Each value by index is passed to the corresponding index of
  <code>encoders</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn encat
  [encoders]
  (-&gt;ConcatEncoder encoders))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord SplatEncoder
    [encoder]
  p/PTopological
  (topology [_]
    (p/topology encoder))
  p/PEncoder
  (encode
    [_ xs]
    (-&gt;&gt; xs
         (mapcat (partial p/encode encoder))
         (distinct))))</pre></td></tr><tr><td class="docs"><p>Returns an encoder for a sequence of values. The given encoder will
  be applied to each value, and the resulting encodings
  overlaid (splatted together), taking the union of the sets of bits.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ensplat
  [encoder]
  (-&gt;SplatEncoder encoder))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord LinearEncoder
    [topo n-active lower upper]
  p/PTopological
  (topology [_]
    topo)
  p/PEncoder
  (encode
    [_ x]
    (if x
      (let [n-bits (p/size topo)
            span (double (- upper lower))
            x (-&gt; x (max lower) (min upper))
            z (/ (- x lower) span)
            i (long (* z (- n-bits n-active)))]
        (range i (+ i n-active)))
      (sequence nil)))
  (decode
    [this bit-votes n]
    (let [span (double (- upper lower))
          values (range lower upper (if (&lt; 5 span 250)
                                      1
                                      (/ span 50)))]
      (-&gt;&gt; (decode-by-brute-force this values bit-votes)
           (take n)))))</pre></td></tr><tr><td class="docs"><p>Returns a simple encoder for a single number. It encodes a number
  by its position on a continuous scale within a numeric range.</p>

<ul>
<li><p><code>dimensions</code> is the size of the encoder in bits along one or more
dimensions, a vector e.g. [500].</p></li>
<li><p><code>n-active</code> is the number of bits to be active.</p></li>
<li><p><code>[lower upper]</code> gives the numeric range to cover. The input number
will be clamped to this range.</p></li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(defn linear-encoder
  [dimensions n-active [lower upper]]
  (let [topo (topology/make-topology dimensions)]
    (map-&gt;LinearEncoder {:topo topo
                         :n-active n-active
                         :lower lower
                         :upper upper})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord CategoryEncoder
    [topo value-&gt;index]
  p/PTopological
  (topology [_]
    topo)
  p/PEncoder
  (encode
    [_ x]
    (if-let [idx (value-&gt;index x)]
      (let [n-bits (p/size topo)
            n-active (quot n-bits (count value-&gt;index))
            i (* idx n-active)]
        (range i (+ i n-active)))
      (sequence nil)))
  (decode
    [this bit-votes n]
    (-&gt;&gt; (decode-by-brute-force this (keys value-&gt;index) bit-votes)
         (take n))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn category-encoder
  [dimensions values]
  (let [topo (topology/make-topology dimensions)]
    (map-&gt;CategoryEncoder {:topo topo
                           :value-&gt;index (zipmap values (range))})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn unique-sdr
  [x n-bits n-active]
  (let [rngs (-&gt; (random/make-random (hash x))
                 (random/split-n (long (* n-active ;; allow for collisions:
                                          1.25))))]
    (into (list)
          (comp (map #(util/rand-int % n-bits))
                (distinct)
                (take n-active))
          rngs)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord UniqueEncoder
    [topo n-active cache]
  p/PTopological
  (topology [_]
    topo)
  p/PEncoder
  (encode
    [_ x]
    (if (nil? x)
      (sequence nil)
      (or (get @cache x)
          (let [sdr (unique-sdr x (p/size topo) n-active)]
            (get (swap! cache assoc x sdr)
                 x)))))
  (decode
    [this bit-votes n]
    (-&gt;&gt; (decode-by-brute-force this (keys @cache) bit-votes)
         (take n))))</pre></td></tr><tr><td class="docs"><p>This encoder generates a unique bit set for each distinct value,
  based on its hash. <code>dimensions</code> is given as a vector.</p>
</td><td class="codes"><pre class="brush: clojure">(defn unique-encoder
  [dimensions n-active]
  (let [topo (topology/make-topology dimensions)]
    (map-&gt;UniqueEncoder {:topo topo
                         :n-active n-active
                         :cache (atom {})})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord Linear2DEncoder
    [topo n-active x-max y-max]
  p/PTopological
  (topology [_]
    topo)
  p/PEncoder
  (encode
    [_ [x y]]
    (if x
      (let [[w h] (p/dimensions topo)
            x (-&gt; x (max 0) (min x-max))
            y (-&gt; y (max 0) (min y-max))
            xz (/ x x-max)
            yz (/ y y-max)
            xi (long (* xz w))
            yi (long (* yz h))
            coord [xi yi]
            idx (p/index-of-coordinates topo coord)]
        (-&gt;&gt; (range 10)
             (mapcat (fn [radius]
                       (p/neighbours-indices topo idx radius (dec radius))))
             (take n-active)))
      (sequence nil)))
  (decode
    [this bit-votes n]
    (let [values (for [x (range x-max)
                       y (range y-max)]
                   [x y])]
      (-&gt;&gt; (decode-by-brute-force this values bit-votes)
           (take n)))))</pre></td></tr><tr><td class="docs"><p>Returns a simple encoder for a tuple of two numbers representing a
  position in rectangular bounds. The encoder maps input spatial
  positions to boxes of active bits in corresponding spatial positions
  of the encoded sense. So input positions close in both coordinates
  will have overlapping bit sets.</p>

<ul>
<li><p><code>dimensions</code> - of the encoded bits, given as a vector [nx ny].</p></li>
<li><p><code>n-active</code> is the number of bits to be active.</p></li>
<li><p><code>[x-max y-max]</code> gives the numeric range of input space to
cover. The numbers will be clamped to this range, and below by
zero.</p></li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(defn linear-2d-encoder
  [dimensions n-active [x-max y-max]]
  (let [topo (topology/make-topology dimensions)]
    (map-&gt;Linear2DEncoder {:topo topo
                           :n-active n-active
                           :x-max x-max
                           :y-max y-max})))</pre></td></tr><tr><td class="docs"><p>we only support up to 3D. beyond that, perf will be bad anyway.</p>
</td><td class="codes"><pre class="brush: clojure">(defn coordinate-neighbours
  [coord radii]
  (case (count coord)
    1 (let [[cx] coord
            [rx] radii]
        (for [x (range (- cx rx) (+ cx rx 1))]
          [x]))
    2 (let [[cx cy] coord
            [rx ry] radii]
        (for [x (range (- cx rx) (+ cx rx 1))
              y (range (- cy ry) (+ cy ry 1))]
          [x y]))
    3 (let [[cx cy cz] coord
            [rx ry rz] radii]
        (for [x (range (- cx rx) (+ cx rx 1))
              y (range (- cy ry) (+ cy ry 1))
              z (range (- cz rz) (+ cz rz 1))]
          [x y z]))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn coordinate-order
  [coord]
  ;; NOTE it is not enough to take (hash coord) as the seed here,
  ;; (because of hash defn for vectors in cljs?) this leads to the first
  ;; element of the coordinate vector dominating, so e.g. big shifts
  ;; in y coordinate have little effect on encoded bits.
  (-&gt; (random/make-random (hash (str coord)))
      (random/rand-double)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn coordinate-bit
  [size coord]
  ;; take second-split random value to distinguish from coordinate-order
  ;; (otherwise highest orders always have highest bits!)
  (-&gt; (random/make-random (hash (str coord)))
      (random/split)
      (second) ;; impl detail? this is independent from the pre-split rng
      (util/rand-int size)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord CoordinateEncoder
    [topo n-active scale-factors radii]
  p/PTopological
  (topology [_]
    topo)
  p/PEncoder
  (encode
    [_ coord]
    (when (first coord)
      (let [int-coord (map (comp util/round *) coord scale-factors)
            neighs (coordinate-neighbours int-coord radii)]
        (-&gt;&gt; (zipmap neighs (map coordinate-order neighs))
             (util/top-n-keys-by-value n-active)
             (map (partial coordinate-bit (p/size topo)))
             (distinct))))))</pre></td></tr><tr><td class="docs"><p>Coordinate encoder for integer coordinates, unbounded, with one,
  two or three dimensions. Expects a coordinate, i.e. a sequence of
  numbers with 1, 2 or 3 elements. These raw values will be multiplied
  by corresponding <code>scale-factors</code> to obtain integer grid
  coordinates. Each dimension has an associated radius within which
  there is some similarity in encoded SDRs.</p>
</td><td class="codes"><pre class="brush: clojure">(defn coordinate-encoder
  [dimensions n-active scale-factors radii]
  (let [topo (topology/make-topology dimensions)]
    (map-&gt;CoordinateEncoder {:topo topo
                             :n-active n-active
                             :scale-factors scale-factors
                             :radii radii})))</pre></td></tr><tr><td class="docs"><h1>Sensors</h1>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn sensor-cat
  [&amp; sensors]
  (let [selectors (map first sensors)
        encoders (map second sensors)]
    [(apply vec-selector selectors)
     (encat encoders)]))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#org.nfrac.comportex.inhibition" name="org.nfrac.comportex.inhibition"><h1 class="project-name">org.nfrac.comportex.inhibition</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns org.nfrac.comportex.inhibition
  (:require [org.nfrac.comportex.protocols :as p]
            [org.nfrac.comportex.util :as util
             :refer [abs round mean remap]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn numeric-span
  [xs]
  (- (apply max xs) (apply min xs)))</pre></td></tr><tr><td class="docs"><p>Returns the span over the input bit array to which this column has
   connected synapses. Takes the maximum span in any one dimension.</p>
</td><td class="codes"><pre class="brush: clojure">(defn column-receptive-field-size
  [sg itopo col]
  (let [ids (p/sources-connected-to sg [col 0 0]) ;; first segment only - good enough?
        coords (map (partial p/coordinates-of-index itopo) ids)]
    (if (seq coords)
      (if (number? (first coords))
        (numeric-span coords)
        (let [m (count (p/dimensions itopo))]
          (-&gt;&gt; (for [j (range m)]
                 (numeric-span (map #(nth % j) coords)))
               (apply max))))
      0)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn avg-receptive-field-size
  [sg topo itopo]
  (-&gt; (map (partial column-receptive-field-size sg itopo)
           (range (p/size topo)))
      (mean)))</pre></td></tr><tr><td class="docs"><p>The radius in column space defining neighbouring columns, based on
   the average receptive field size. Specifically, neighbouring
   columns are defined by sharing at least 50% of their receptive
   fields, on average.</p>

<ul>
<li><p><code>sg</code> is the synapse graph linking the inputs to targets.</p></li>
<li><p><code>topo</code> is the topology of the targets (e.g. columns).</p></li>
<li><p><code>itopo</code> is the topology of the inputs.</p></li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(defn inhibition-radius
  [sg topo itopo]
  (let [shared-frac 0.5
        max-dim (apply max (p/dimensions topo))
        max-idim (apply max (p/dimensions itopo))
        arfs (avg-receptive-field-size sg topo itopo)
        ;; columns in this range will have some overlap of inputs
        cols-diameter (* max-dim (/ arfs max-idim))
        cols-radius (quot cols-diameter 2)]
    ;; to share a given fraction of receptive fields
    (-&gt; (* cols-radius (- 1.0 shared-frac))
        (round)
        (max 1))))</pre></td></tr><tr><td class="docs"><p>Returns the set of column ids which should become active given the
   map of column excitations <code>exc</code>, and the target activation rate
   <code>level</code>. Global inhibition is applied, i.e. the top N columns by
   excitation are selected.</p>
</td><td class="codes"><pre class="brush: clojure">(defn inhibit-globally
  [exc n-on]
  (util/top-n-keys-by-value n-on exc))</pre></td></tr><tr><td class="docs"><p>Threshold excitation level at which a cell with excitation <code>x</code>
   inhibits a neighbour cell at a distance <code>dist</code> columns away.</p>
</td><td class="codes"><pre class="brush: clojure">(defn inhibits-exc
  ^double [^double x ^double dist ^double max-dist ^double base-dist]
  (let [z (- 1.0 (/ (max 0.0 (- dist base-dist))
                    (- max-dist base-dist)))]
    (* x z)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn map-&gt;vec
  [n m]
  (mapv m (range n)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn vec-&gt;map
  [v]
  (persistent!
   (reduce-kv (fn [m i x]
                (if x
                  (assoc! m i x)
                  m))
              (transient {}) v)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- mask-out-inhibited-by-col
  [emask col x topo inh-radius inh-base-dist]
  (let [coord (p/coordinates-of-index topo col)
        x (double x)
        inh-radius (double inh-radius)
        inh-base-dist (double inh-base-dist)]
    (loop [nbs (p/neighbours topo coord (int inh-radius) 0)
           emask emask]
      (if-let [nb-coord (first nbs)]
        (let [nb-col (p/index-of-coordinates topo nb-coord)]
          (if-let [nb-x (emask nb-col)]
            (let [dist (double (p/coord-distance topo coord nb-coord))]
              (if (&lt;= nb-x (inhibits-exc x dist inh-radius inh-base-dist))
                (recur (next nbs)
                       (assoc! emask nb-col nil))
                (recur (next nbs) emask)))
            ;; neighbour has no overlap or was eliminated
            (recur (next nbs) emask)))
        ;; finished with neighbours
        emask))))</pre></td></tr><tr><td class="docs"><p>Returns the set of column ids which should become active given the
   map of column excitations <code>exc</code> and the column topology. Applies
   local inhibition to remove any columns dominated by their
   neighbours.</p>
</td><td class="codes"><pre class="brush: clojure">(defn inhibit-locally
  [exc topo inh-radius inh-base-dist n-on]
  (loop [sel-cols ()
         more-cols (keys (sort-by val &gt; exc))
         emask (transient (map-&gt;vec (p/size topo) exc))]
    (if (&lt; (count sel-cols) n-on)
      (if-let [col (first more-cols)]
        (if-let [x (emask col)]
          (recur (conj sel-cols col)
                 (next more-cols)
                 (mask-out-inhibited-by-col emask col x topo inh-radius
                                            inh-base-dist))
          ;; already eliminated, skip
          (recur sel-cols (next more-cols) emask))
        ;; finished
        sel-cols)
      ;; reached target level of activation
      sel-cols)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#org.nfrac.comportex.protocols" name="org.nfrac.comportex.protocols"><h1 class="project-name">org.nfrac.comportex.protocols</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns org.nfrac.comportex.protocols)</pre></td></tr><tr><td class="docs"><p>A network of regions and senses, forming Hierarchical Temporal Memory.</p>
</td><td class="codes"><pre class="brush: clojure">(defprotocol PHTM
  (htm-sense [this inval mode]
    &quot;Takes an input value. Updates the HTM's senses by applying
    corresponding sensors to the input value. `mode` may be
    :sensory or :motor to update only such senses, or nil to update
    all. Also updates :input-value. Returns updated HTM.&quot;)
  (htm-activate [this]
    &quot;Propagates feed-forward input through the network to activate
    columns and cells. Assumes senses have already been encoded, with
    `htm-sense`. Increments the time step. Returns updated HTM.&quot;)
  (htm-learn [this]
    &quot;Applies learning rules to synapses. Assumes `this` has been through
    the `htm-activate` phase already. Returns updated HTM.&quot;)
  (htm-depolarise [this]
    &quot;Propagates lateral and feed-back activity to put cells into a
    depolarised (predictive) state. Assumes `this` has been through
    the `htm-activate` phase already. Returns updated HTM.&quot;))</pre></td></tr><tr><td class="docs"><p>Advances a HTM by a full time step with the given input value. Just
  (-> htm (htm-sense inval nil) htm-activate htm-learn htm-depolarise)</p>
</td><td class="codes"><pre class="brush: clojure">(defn htm-step
  [htm inval]
  (-&gt; htm
      (htm-sense inval nil)
      (htm-activate)
      (htm-learn)
      (htm-depolarise)))</pre></td></tr><tr><td class="docs"><p>Cortical regions need to extend this together with PTopological,
   PFeedForward, PTemporal, PParameterised.</p>
</td><td class="codes"><pre class="brush: clojure">(defprotocol PRegion
  (region-activate [this ff-bits stable-ff-bits])
  (region-learn [this])
  (region-depolarise [this distal-ff-bits apical-fb-bits apical-fb-wc-bits]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn region-step
  ([this ff-bits]
     (region-step this ff-bits #{} #{} #{} #{}))
  ([this ff-bits stable-ff-bits distal-ff-bits apical-fb-bits apical-fb-wc-bits]
     (-&gt; this
         (region-activate ff-bits stable-ff-bits)
         (region-learn)
         (region-depolarise distal-ff-bits apical-fb-bits apical-fb-wc-bits))))</pre></td></tr><tr><td class="docs"><p>A feed-forward input source with a bit set representation. Could be
   sensory input or a region (where cells are bits).</p>
</td><td class="codes"><pre class="brush: clojure">(defprotocol PFeedForward
  (ff-topology [this])
  (bits-value [this]
    &quot;The set of indices of all active bits/cells.&quot;)
  (stable-bits-value [this]
    &quot;The set of indices of active cells where those cells were
    predicted (so, excluding cells from bursting columns).&quot;)
  (source-of-bit [this i]
    &quot;Given the index of an output bit from this source, return the
    corresponding local cell id as [col ci] where col is the column
    index. If the source is a sense, returns [i].&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol PFeedBack
  (wc-bits-value [this]
    &quot;The set of indices of all winner cells.&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol PFeedForwardMotor
  (ff-motor-topology [this])
  (motor-bits-value [this]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol PLayerOfCells
  (layer-activate [this ff-bits stable-ff-bits])
  (layer-learn [this])
  (layer-depolarise [this distal-ff-bits apical-fb-bits apical-fb-wc-bits])
  (layer-depth [this]
    &quot;Number of cells per column.&quot;)
  (bursting-columns [this]
    &quot;The set of bursting column ids.&quot;)
  (active-columns [this]
    &quot;The set of active column ids.&quot;)
  (active-cells [this]
    &quot;The set of active cell ids.&quot;)
  (winner-cells [this]
    &quot;The set of winning cell ids, one in each active column. These are
    only _learning_ cells when they turn on, but are always
    _learnable_.&quot;)
  (temporal-pooling-cells [this]
    &quot;The collection of temporal pooling cells, i.e. those having some
    non-zero level of continuing temporal pooling excitation.&quot;)
  (predictive-cells [this]
    &quot;The set of predictive cell ids derived from the current active
    cells. If the depolarise phase has not been applied yet, returns
    nil.&quot;)
  (prior-predictive-cells [this]
    &quot;The set of predictive cell ids from the previous timestep,
    i.e. their prediction can be compared to the current active
    cells.&quot;))</pre></td></tr><tr><td class="docs"><p>The synaptic connections from a set of sources to a set of targets.
   Synapses have an associated permanence value between 0 and 1; above
   some permanence level they are defined to be connected.</p>
</td><td class="codes"><pre class="brush: clojure">(defprotocol PSynapseGraph
  (in-synapses [this target-id]
    &quot;All synapses to the target. A map from source ids to permanences.&quot;)
  (sources-connected-to [this target-id]
    &quot;The collection of source ids actually connected to target id.&quot;)
  (targets-connected-from [this source-id]
    &quot;The collection of target ids actually connected from source id.&quot;)
  (excitations [this active-sources stimulus-threshold]
    &quot;Computes a map of target ids to their degree of excitation -- the
    number of sources in `active-sources` they are connected to -- excluding
    any below `stimulus-threshold`.&quot;)
  (bulk-learn [this seg-updates active-sources pinc pdec pinit]
    &quot;Applies learning updates to a batch of targets. `seg-updates` is
    a sequence of SegUpdate records, one for each target dendrite
    segment.&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol PSegments
  (cell-segments [this cell-id]
    &quot;A vector of segments on the cell, each being a synapse map.&quot;))</pre></td></tr><tr><td class="docs"><p>Sense nodes need to extend this together with PFeedForward.</p>
</td><td class="codes"><pre class="brush: clojure">(defprotocol PSense
  (sense-activate [this bits]))</pre></td></tr><tr><td class="docs"><p>Pulls out a value according to some pattern, like a path or lens.
  Should be serializable. A Sensor is defined as [Selector Encoder].</p>
</td><td class="codes"><pre class="brush: clojure">(defprotocol PSelector
  (extract [this state]
    &quot;Extracts a value from `state` according to some configured pattern. A
    simple example is a lookup by keyword in a map.&quot;))</pre></td></tr><tr><td class="docs"><p>Encoders need to extend this together with PTopological.</p>
</td><td class="codes"><pre class="brush: clojure">(defprotocol PEncoder
  (encode [this x]
    &quot;Encodes `x` as a collection of distinct integers which are the on-bits.&quot;)
  (decode [this bit-votes n]
    &quot;Finds `n` domain values matching the given bit set in a sequence
     of maps with keys `:value`, `:votes-frac`, `:votes-per-bit`,
     `:bit-coverage`, `:bit-precision`, ordered by votes fraction
     decreasing. The argument `bit-votes` is a map from encoded bit
     index to a number of votes, typically the number of synapse
     connections from predictive cells.&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol PRestartable
  (restart [this]
    &quot;Returns this model (or model component) reverted to its initial
    state prior to any learning.&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol PInterruptable
  (break [this mode]
    &quot;Returns this model (or model component) without its current
    sequence state, forcing the following input to be treated as a new
    sequence. If mode is :tm, cancels any distal predictions and
    prevents learning lateral/distal connections. If mode is :fb,
    cancels any feedback predictions and prevents learning connections
    on apical dendrites. If mode is :tp, cancels any temporal pooling
    potential.&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol PTemporal
  (timestep [this]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol PParameterised
  (params [this]
    &quot;A parameter set as map with keyword keys.&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol PTopological
  (topology [this]))</pre></td></tr><tr><td class="docs"><p>Operating on a regular grid of certain dimensions, where each
   coordinate is an n-tuple vector---or integer for 1D---and also has
   a unique integer index.</p>
</td><td class="codes"><pre class="brush: clojure">(defprotocol PTopology
  (dimensions [this])
  (coordinates-of-index [this idx])
  (index-of-coordinates [this coord])
  (neighbours* [this coord outer-r inner-r])
  (coord-distance [this coord-a coord-b]))</pre></td></tr><tr><td class="docs"><p>The total number of elements indexed in the topology.</p>
</td><td class="codes"><pre class="brush: clojure">(defn size
  [topo]
  (reduce * (dimensions topo)))</pre></td></tr><tr><td class="docs"><p>The dimensions of a PTopological as an n-tuple vector.</p>
</td><td class="codes"><pre class="brush: clojure">(defn dims-of
  [x]
  (dimensions (topology x)))</pre></td></tr><tr><td class="docs"><p>The total number of elements in a PTopological.</p>
</td><td class="codes"><pre class="brush: clojure">(defn size-of
  [x]
  (size (topology x)))</pre></td></tr><tr><td class="docs"><p>Returns the coordinates away from <code>coord</code> at distances
  <code>inner-r</code> (exclusive) out to <code>outer-r</code> (inclusive) .</p>
</td><td class="codes"><pre class="brush: clojure">(defn neighbours
  ([topo coord radius]
     (neighbours* topo coord radius 0))
  ([topo coord outer-r inner-r]
     (neighbours* topo coord outer-r inner-r)))</pre></td></tr><tr><td class="docs"><p>Same as <code>neighbours</code> but taking and returning indices instead of
   coordinates.</p>
</td><td class="codes"><pre class="brush: clojure">(defn neighbours-indices
  ([topo idx radius]
     (neighbours-indices topo idx radius 0))
  ([topo idx outer-r inner-r]
     (-&gt;&gt; (neighbours* topo (coordinates-of-index topo idx)
                       outer-r inner-r)
          (map (partial index-of-coordinates topo)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#org.nfrac.comportex.repl" name="org.nfrac.comportex.repl"><h1 class="project-name">org.nfrac.comportex.repl</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Optional REPL tweaks</p>
</td><td class="codes"><pre class="brush: clojure">(ns org.nfrac.comportex.repl
  #?(:clj (:require [clojure.pprint :as pprint]
                    [org.nfrac.comportex.cells]
                    [org.nfrac.comportex.synapses])
     :cljs (:require [org.nfrac.comportex.cells
                      :refer [LayerOfCells LayerActiveState LayerDistalState]]
                     [org.nfrac.comportex.synapses :refer [SynapseGraph]]))
  #?(:clj (:import [org.nfrac.comportex.cells
                    LayerOfCells LayerActiveState LayerDistalState]
                   [org.nfrac.comportex.synapses SynapseGraph])))</pre></td></tr><tr><td class="docs"><h2>Truncate large data structures</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Transform the first argument of calls to <code>multifn</code> before calling the method
  currently associated with dispatch-value. This transform happens after
  dispatch.</p>
</td><td class="codes"><pre class="brush: clojure">(defn patchmethod1
  [multifn dispatch-val f]
  (let [dispatch-fn (get-method multifn dispatch-val)]
    (defmethod multifn dispatch-val
      [arg1 &amp; more]
      (apply dispatch-fn (f arg1) more))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *truncated-print-length* 3)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def print-methods #?(:clj [print-method
                            pprint/simple-dispatch]
                      :cljs []))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def should-truncate {LayerOfCells
                      [:boosts :active-duty-cycles]
                      SynapseGraph
                      [:syns-by-target :targets-by-source]
                      LayerActiveState
                      [:col-overlaps :matching-ff-seg-paths
                       :in-ff-bits :in-stable-ff-bits
                       :out-ff-bits :out-stable-ff-bits
                       :active-cells]
                      LayerDistalState
                      [:on-bits :on-lc-bits :cell-exc :pred-cells
                       :matching-seg-paths]})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord TruncateOnPrint [v])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn truncate-large-data-structures []
  ;; The TruncateOnPrint is invisible. Its contents are visible, but truncated.
  (doseq [m print-methods]
    (defmethod m TruncateOnPrint
      [this &amp; args]
      (binding [*print-length* (if (and *print-length*
                                        *truncated-print-length*)
                                 (min *print-length*
                                      *truncated-print-length*)
                                 (or *print-length*
                                     *truncated-print-length*))]
        (apply m (:v this) args))))
  ;; Before printing records, wrap the specified fields in a TruncateOnPrint.
  (doseq [m print-methods
          [recordclass noisykeys] should-truncate]
    (patchmethod1 m recordclass
                  (fn [this]
                    (reduce #(update-in % [%2] -&gt;TruncateOnPrint)
                            this noisykeys)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#org.nfrac.comportex.synapses" name="org.nfrac.comportex.synapses"><h1 class="project-name">org.nfrac.comportex.synapses</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns org.nfrac.comportex.synapses
  (:require [org.nfrac.comportex.protocols :as p]
            [org.nfrac.comportex.util :as util :refer [getx]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord SegUpdate [target-id operation grow-sources die-sources])</pre></td></tr><tr><td class="docs"><p>Creates a record defining changes to make to a synaptic
  segment. Operation can be one of <code>:learn</code> (increment active sources,
  decrement inactive), <code>:punish</code> (decrement active sources) or
  <code>:reinforce</code> (increment active sources). Without the operation
  argument, only the growth and death of synapses will be applied.</p>
</td><td class="codes"><pre class="brush: clojure">(defn seg-update
  ([target-id grow-sources die-sources]
   (SegUpdate. target-id nil grow-sources die-sources))
  ([target-id operation grow-sources die-sources]
   {:pre [(contains? #{:learn :punish :reinforce} operation)]}
   (SegUpdate. target-id operation grow-sources die-sources)))</pre></td></tr><tr><td class="docs"><p>Returns lists of synapse source ids as `[up promote down demote
   cull]` according to whether they should be increased or decreased
   and whether they are crossing the connected permanence threshold.</p>
</td><td class="codes"><pre class="brush: clojure">(defn segment-alterations
  [syns adjustable? reinforce? pcon pinc pdec cull-zeros?]
  (let [pcon (double pcon)
        pcon+pdec (double (+ pcon pdec))
        pcon-pinc (double (- pcon pinc))]
    (loop [syns (seq syns)
           up ()
           promote ()
           down ()
           demote ()
           cull ()]
      (if syns
        ;; process one synapse
        (let [[id p] (first syns)
              p (double p)]
          (if-not (adjustable? id)
            (recur (next syns) up promote down demote cull)
            (if (reinforce? id)
              ;; positive reinforce
              (recur (next syns)
                     (if (&lt; p 1.0) (conj up id) up)
                     (if (and (&lt; p pcon)
                              (&gt;= p pcon-pinc))
                       (conj promote id) promote)
                     down
                     demote
                     cull)
              ;; negative reinforce
              (recur (next syns)
                     up
                     promote
                     (if (&gt; p 0.0) (conj down id) down)
                     (if (and (&gt;= p pcon)
                              (&lt; p pcon+pdec))
                       (conj demote id) demote)
                     (if (and (&lt;= p 0.0) cull-zeros?)
                       (conj cull id) cull)))))
        ;; finished loop
        [up promote down demote cull]))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- never [_] false)
(defn- always [_] true)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord SynapseGraph
    [syns-by-target targets-by-source pcon cull-zeros?]
  p/PSynapseGraph
  (in-synapses
    [this target-id]
    (get syns-by-target target-id))
  (sources-connected-to
    [this target-id]
    (-&gt;&gt; (get syns-by-target target-id)
         (keep (fn [[k p]] (when (&gt;= p pcon) k)))))
  (targets-connected-from
    [this source-id]
    (get targets-by-source source-id))
  (excitations
    [this active-sources stimulus-threshold]
    (-&gt;&gt; active-sources
         (reduce (fn [m source-i]
                   (reduce (fn [m id]
                             (assoc! m id (inc (get m id 0))))
                           m
                           (p/targets-connected-from this source-i)))
                 (transient {}))
         (persistent!)
         (reduce-kv (fn [m id exc]
                   (if (&gt;= exc stimulus-threshold)
                     (assoc! m id exc)
                     m))
                 (transient {}))
         (persistent!)))
  (bulk-learn
    [this seg-updates active-sources pinc pdec pinit]
    (loop [seg-updates (seq seg-updates)
           syns-by-target (transient syns-by-target)
           targets-by-source (transient targets-by-source)]
      (if-let [seg-up (first seg-updates)]
        (let [{:keys [target-id operation grow-sources die-sources]} seg-up
              syns* (getx syns-by-target target-id)
              syns (if (seq die-sources)
                     (apply dissoc syns* die-sources)
                     syns*)
              [up promote down demote cull]
              (case operation
                :learn (segment-alterations syns always active-sources
                                            pcon pinc pdec cull-zeros?)
                :punish (segment-alterations syns active-sources never
                                             pcon pinc pdec cull-zeros?)
                :reinforce (segment-alterations syns active-sources always
                                                pcon pinc pdec cull-zeros?)
                ;; otherwise - just grow and die
                [() () () () ()])
              new-syns (-&gt; (if (seq cull)
                             (apply dissoc! (transient syns) cull)
                             (transient syns))
                           (util/update-each! up #(min (+ % pinc) 1.0))
                           (util/update-each! down #(max (- % pdec) 0.0))
                           (conj! (zipmap grow-sources (repeat pinit)))
                           (persistent!))
              connect-ids (if (&gt;= pinit pcon) (concat promote grow-sources) promote)
              disconnect-ids (concat demote die-sources)]
          (recur (next seg-updates)
                 (assoc! syns-by-target target-id new-syns)
                 (-&gt; targets-by-source
                     (util/update-each! connect-ids #(conj % target-id))
                     (util/update-each! disconnect-ids #(disj % target-id)))))
        ;; finished loop
        (assoc this
               :syns-by-target (persistent! syns-by-target)
               :targets-by-source (persistent! targets-by-source))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn empty-synapse-graph
  [n-targets n-sources pcon cull-zeros?]
  (map-&gt;SynapseGraph
   {:syns-by-target (vec (repeat n-targets {}))
    :targets-by-source (vec (repeat n-sources #{}))
    :pcon pcon
    :cull-zeros? cull-zeros?}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn synapse-graph
  [syns-by-target n-sources pcon cull-zeros?]
  (let [targets-by-source
        (persistent!
         (reduce-kv (fn [v target-id syns]
                      (let [connect-ids (keep (fn [[i p]]
                                                (when (&gt;= p pcon) i)) syns)]
                        (util/update-each! v connect-ids #(conj % target-id))))
                    (transient (vec (repeat n-sources #{})))
                    syns-by-target))]
    (map-&gt;SynapseGraph
     {:syns-by-target syns-by-target
      :targets-by-source targets-by-source
      :pcon pcon
      :cull-zeros? cull-zeros?})))</pre></td></tr><tr><td class="docs"><h2>Dendrite segments</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn seg-uidx
  [depth max-segs [col ci si]]
  (+ (* col depth max-segs)
     (* ci max-segs)
     si))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn seg-path
  [depth max-segs uidx]
  (let [col (quot uidx (* depth max-segs))
        col-rem (rem uidx (* depth max-segs))]
    [col
     (quot col-rem max-segs)
     (rem col-rem max-segs)]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord CellSegmentsSynapseGraph
    [int-sg n-cols depth max-segs]
  p/PSynapseGraph
  (in-synapses
    [_ target-id]
    (p/in-synapses int-sg (seg-uidx depth max-segs target-id)))
  (sources-connected-to
    [_ target-id]
    (assert target-id)
    (p/sources-connected-to int-sg (seg-uidx depth max-segs target-id)))
  (targets-connected-from
    [_ source-id]
    (-&gt;&gt; (p/targets-connected-from int-sg source-id)
         (map (partial seg-path depth max-segs))))
  (excitations
    [_ active-sources stimulus-threshold]
    (let [exc-m (p/excitations int-sg active-sources stimulus-threshold)]
      (zipmap (map (fn [i] (seg-path depth max-segs i))
                   (keys exc-m))
              (vals exc-m))))
  (bulk-learn
    [this seg-updates active-sources pinc pdec pinit]
    (update-in this [:int-sg] p/bulk-learn
               (map (fn [seg-up]
                      (assoc seg-up :target-id
                             (seg-uidx depth max-segs (:target-id seg-up))))
                    seg-updates)
               active-sources pinc pdec pinit))
  p/PSegments
  (cell-segments
    [this cell-id]
    (let [cell-id (vec cell-id)]
      (mapv #(p/in-synapses this (conj cell-id %))
            (range max-segs)))))</pre></td></tr><tr><td class="docs"><p>A synapse graph where the targets refer to distal dendrite
  segments on cells, which themselves are arranged in columns.
  Accordingly <code>target-id</code> is passed and returned not as an integer
  but as a 3-tuple <code>[col ci si]</code>, column id, cell id, segment id.
  Sources often refer to cells but are passed and returned as
  <strong>integers</strong>, so any conversion to/from cell ids should happen
  externally.</p>
</td><td class="codes"><pre class="brush: clojure">(defn cell-segs-synapse-graph
  [n-cols depth max-segs n-sources pcon cull-zeros?]
  (let [n-targets (* n-cols depth max-segs)
        int-sg (empty-synapse-graph n-targets n-sources pcon cull-zeros?)]
    (map-&gt;CellSegmentsSynapseGraph
     {:int-sg int-sg
      :depth depth
      :max-segs max-segs})))</pre></td></tr><tr><td class="docs"><p>A synapse graph where the targets refer to proximal dendrite
  segments on columns.  Accordingly <code>target-id</code> is passed and returned
  not as an integer but as a 3-tuple <code>[col 0 si]</code>, column id, (cell = 0),
  segment id.  Sources often refer to cells but are passed and
  returned as <strong>integers</strong>, so any conversion to/from cell ids should
  happen externally.  Initial synapses are given for each segment.</p>
</td><td class="codes"><pre class="brush: clojure">(defn col-segs-synapse-graph
  [syns-by-col n-cols max-segs n-sources pcon cull-zeros?]
  (let [n-targets (* n-cols max-segs)
        int-syns-by-target (persistent!
                            (reduce (fn [v [col syns]]
                                      (let [path [col 0 0]
                                            i (seg-uidx 1 max-segs path)]
                                        (assoc! v i syns)))
                                    (transient (vec (repeat n-targets {})))
                                    (map-indexed vector syns-by-col)))
        int-sg (synapse-graph int-syns-by-target n-sources pcon cull-zeros?)]
    (map-&gt;CellSegmentsSynapseGraph
     {:int-sg int-sg
      :depth 1
      :max-segs max-segs})))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#org.nfrac.comportex.topology" name="org.nfrac.comportex.topology"><h1 class="project-name">org.nfrac.comportex.topology</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns org.nfrac.comportex.topology
  (:require [org.nfrac.comportex.protocols :as p]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- abs
  [x]
  (if (neg? x) (- x) x))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord OneDTopology
    [size]
  p/PTopology
  (dimensions [_]
    [size])
  (coordinates-of-index [_ idx]
    idx)
  (index-of-coordinates [_ coord]
    coord)
  (neighbours*
    [this coord outer-r inner-r]
    (concat (range (min (+ coord inner-r 1) size)
                   (min (+ coord outer-r 1) size))
            (range (max (- coord outer-r) 0)
                   (max (- coord inner-r) 0))))
  (coord-distance
    [_ coord-a coord-b]
    (abs (- coord-b coord-a))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn one-d-topology
  [size]
  (-&gt;OneDTopology size))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord TwoDTopology
    [width height]
  ;; Represents coordinates [x y], with y changing faster over indices.
  ;; Uses Manhattan distance for neighbours and distance.
  p/PTopology
  (dimensions [_]
    [width height])
  (coordinates-of-index
    [_ idx]
    [(quot idx height) (rem idx height)])
  (index-of-coordinates
    [_ coord]
    (let [[cx cy] coord]
      (+ (* cx height) cy)))
  (neighbours*
    [this coord outer-r inner-r]
    (let [[cx cy] coord]
      ;; Manhattan distance
      (for [x (range (max (- cx outer-r) 0)
                     (min (+ cx outer-r 1) width))
            y (range (max (- cy outer-r) 0)
                     (min (+ cy outer-r 1) height))
            :when (or (&gt; (abs (- x cx)) inner-r)
                      (&gt; (abs (- y cy)) inner-r))]
        [x y])))
  (coord-distance
    [_ coord-a coord-b]
    (let [[xa ya] coord-a
          [xb yb] coord-b]
      ;; Manhattan distance
      (+ (abs (- xb xa))
         (abs (- yb ya))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn two-d-topology
  [width height]
  (-&gt;TwoDTopology width height))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord ThreeDTopology
    [width height depth]
  ;; Represents coordinates [x y z], with z changing fastest over indices.
  ;; Uses Manhattan distance for neighbours and distance.
  p/PTopology
  (dimensions [_]
    [width height depth])
  (coordinates-of-index
    [_ idx]
    (let [x (quot idx (* height depth))
          x-rem (rem idx (* height depth))]
      [x (quot x-rem depth) (rem x-rem depth)]))
  (index-of-coordinates
    [_ coord]
    (let [[cx cy cz] coord]
      (+ (* cx height depth) (* cy height) cz)))
  (neighbours*
    [this coord outer-r inner-r]
    (let [[cx cy cz] coord]
      ;; Manhattan distance
      (for [x (range (max (- cx outer-r) 0)
                     (min (+ cx outer-r 1) width))
            y (range (max (- cy outer-r) 0)
                     (min (+ cy outer-r 1) height))
            z (range (max (- cz outer-r) 0)
                     (min (+ cz outer-r 1) depth))
            :when (or (&gt; (abs (- x cx)) inner-r)
                      (&gt; (abs (- y cy)) inner-r)
                      (&gt; (abs (- y cz)) inner-r))]
        [x y z])))
  (coord-distance
    [_ coord-a coord-b]
    (let [[xa ya za] coord-a
          [xb yb zb] coord-b]
      ;; Manhattan distance
      (+ (abs (- xb xa))
         (abs (- yb ya))
         (abs (- zb za))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn three-d-topology
  [w h d]
  (-&gt;ThreeDTopology w h d))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn make-topology
  [dims]
  (let [[w h d q] dims]
    (case (count dims)
      0 (one-d-topology 0)
      1 (one-d-topology w)
      2 (two-d-topology w h)
      3 (three-d-topology w h d)
      4 (three-d-topology w h (* d q)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def empty-topology
  (make-topology [0]))</pre></td></tr><tr><td class="docs"><p>Project n dimensions to n-1 dimensions by eliminating the last dimension.</p>

<p>  This removes potentially-valuable structure.
  Example: in dimensions [8 7 6], the points [0 0 0] [0 1 0] are adjacent.
  After squashing to [8 42], these points [0 0] [0 6] are much further apart.</p>
</td><td class="codes"><pre class="brush: clojure">(defn squash-last-dimension
  [dims]
  (-&gt; dims
      (update-in [(- (count dims) 2)]
                 * (last dims))
      butlast
      vec))</pre></td></tr><tr><td class="docs"><p>Project n dimensions to n+1 dimensions by dividing the first dimension
  into cross sections.</p>

<p>  This artificially adds structure. It can also disrupt existing structure.
  Example: In dimensions [64] the points [7] and [8] are adjacent.
  After splitting to [8 8], these points [0 7] [1 0] are further apart.</p>
</td><td class="codes"><pre class="brush: clojure">(defn split-first-dimension
  [dims xsection-length]
  (when-let [[x &amp; rest] dims]
    (when (zero? (rem x xsection-length))
      (into [(quot x xsection-length)]
            (assoc dims 0 xsection-length)))))</pre></td></tr><tr><td class="docs"><p>We will pour the concatenated indices (and offsets) into this
combined topology. Note that region output is its cells, so will
add another dimension to column topology. e.g. 2D columns [x y]
becomes [x y z], where z = cell depth.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Align n topologies along the x axis into a single topology.
  If the topologies don't stack neatly, force compatibility via two
  strategies:</p>

<ol>
<li><p>Add dimensions to the lower-dimensional topology by splitting its first
dimension into cross sections. This is analogous to summing numbers encoded
in a mixed radix. If the sum of <code>higher</code> and <code>lower</code> can be expressed by only
changing the first digit of <code>higher</code>, then the two can be stacked in
<code>higher</code>'s radix (i.e. dimensions).</p>

<p>Default behavior: don't redistribute / mangle <code>lower</code>'s lower dimensions
(i.e. [y, z, ...]). To force mangling, provide a 1-dimensional <code>lower</code>.</p></li>
<li><p>Remove dimensions from the higher-dimension topology by squashing its
last two dimensions into one.</p>

<p>It's best to hand-pick compatible topologies if topology matters.</p></li>
</ol>
</td><td class="codes"><pre class="brush: clojure">(defn combined-dimensions
  ([]
     [0])
  ([&amp; all-dims]
     (reduce (fn [dims1 dims2]
               (let [[lower higher] (-&gt;&gt; [dims1 dims2]
                                         (map #(if (empty? %) [0] %))
                                         (sort-by count))
                     disparity (- (count higher) (count lower))
                     ;; match all dimensions except x
                     [to-match must-already-match] (-&gt;&gt; (rest higher)
                                                        (split-at disparity))]
                 (if-let [compatible (when (= (vec (rest lower))
                                              (vec must-already-match))
                                       (reduce split-first-dimension lower
                                               (reverse to-match)))]
                   ;; now that everything except x matches, sum the xs
                   (update-in higher [0] + (first compatible))
                   (recur (squash-last-dimension higher) lower))))
             all-dims)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#org.nfrac.comportex.util" name="org.nfrac.comportex.util"><h1 class="project-name">org.nfrac.comportex.util</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns org.nfrac.comportex.util
  (:require [clojure.test.check.random :as random])
  (:refer-clojure :exclude [rand rand-int rand-nth shuffle]))</pre></td></tr><tr><td class="docs"><p>copied from
https://github.com/Datomic/simulant/blob/d681b2375c3e0ea13a0df3caffeb7b3d8a20c6a3/src/simulant/util.clj#L24-L37</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Like two-argument get, but throws an exception if the key is
   not found.</p>
</td><td class="codes"><pre class="brush: clojure">(defn getx
  [m k]
  (let [e (get m k ::sentinel)]
    (if-not (= e ::sentinel)
      e
      (throw (ex-info &quot;Missing required key&quot; {:map m :key k})))))</pre></td></tr><tr><td class="docs"><p>Like two-argument get-in, but throws an exception if the key is
   not found.</p>
</td><td class="codes"><pre class="brush: clojure">(defn getx-in
  [m ks]
  (reduce getx m ks))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn abs
  [x]
  (if (neg? x) (- x) x))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn round
  ([x]
     (Math/round (double x)))
  ([x n]
     (let [z (Math/pow 10.0 n)]
       (-&gt; x
           (* z)
           (round)
           (/ z)
           (double)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn mean
  [xs]
  (/ (apply + xs) (double (count xs))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn rand
  [rng lower upper]
  {:pre [(&lt; lower upper)]}
  (-&gt; (random/rand-double rng)
      (* (- upper lower))
      (+ lower)))</pre></td></tr><tr><td class="docs"><p>Uniform integer between lower (inclusive) and upper (exclusive).</p>
</td><td class="codes"><pre class="brush: clojure">(defn rand-int
  ([rng upper]
   (-&gt; (random/rand-double rng)
       (* upper)
       (Math/floor)
       (long)))
  ([rng lower upper]
   (-&gt; (random/rand-double rng)
       (* (- upper lower))
       (+ lower)
       (Math/floor)
       (long))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn rand-nth
  [rng xs]
  (nth xs (rand-int rng (count xs))))</pre></td></tr><tr><td class="docs"><p>copied from
https://github.com/clojure/data.generators/blob/bf2eb5288fb59045041aec01628a7f53104d84ca/src/main/clojure/clojure/data/generators.clj
adapted to splittable RNG</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>http://en.wikipedia.org/wiki/Fisher–Yates<em>shuffle#The</em>modern_algorithm</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:private fisher-yates
  [rng coll]
  (let [as (object-array coll)]
    (loop [i (dec (count as))
           r rng]
      (if (&lt;= 1 i)
        (let [[r1 r2] (random/split r)
              j (rand-int r1 (inc i))
              t (aget as i)]
          (aset as i (aget as j))
          (aset as j t)
          (recur (dec i) r2))
        (into (empty coll) (seq as))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn shuffle
  [rng coll]
  (fisher-yates rng coll))</pre></td></tr><tr><td class="docs"><p>copied from
https://github.com/clojure/data.generators/blob/bf2eb5288fb59045041aec01628a7f53104d84ca/src/main/clojure/clojure/data/generators.clj
adapted to splittable RNG</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Reservoir sample ct items from coll.</p>
</td><td class="codes"><pre class="brush: clojure">(defn reservoir-sample
  [rng ct coll]
  (loop [result (transient (vec (take ct coll)))
         n ct
         coll (drop ct coll)
         r rng]
    (if (seq coll)
      (let [[r1 r2] (random/split r)
            pos (rand-int r1 n)]
        (recur (if (&lt; pos ct)
                 (assoc! result pos (first coll))
                 result)
               (inc n)
               (rest coll)
               r2))
      (persistent! result))))</pre></td></tr><tr><td class="docs"><p>Sample ct items with replacement (i.e. possibly with duplicates) from coll.</p>
</td><td class="codes"><pre class="brush: clojure">(defn sample
  [rng ct coll]
  (when (pos? ct)
    (-&gt;&gt; (random/split-n rng ct)
         (mapv #(rand-nth % coll)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn quantile
  [xs p]
  (nth (sort xs) (long (* p (dec (count xs))))))</pre></td></tr><tr><td class="docs"><p>Returns a function transforming uniform randoms in [0 1] to variates on a
   Triangular distribution. http://en.wikipedia.org/wiki/Triangular_distribution</p>

<ul>
<li><p>a - lower bound</p></li>
<li><p>b - upper bound</p></li>
<li><p>c - peak of probability density (within bounds)</p></li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(defn triangular
  [a b c]
  (let [Fc (/ (- c a)
              (- b a))]
    (fn [u]
      (if (&lt; u Fc)
        (+ a (Math/sqrt (* u (- b a) (- c a))))
        (- b (Math/sqrt (* (- 1 u) (- b a) (- b c))))))))</pre></td></tr><tr><td class="docs"><p>Same as <code>(count (filter pred coll))</code>, but faster.</p>
</td><td class="codes"><pre class="brush: clojure">(defn count-filter
  [pred coll]
  (reduce (fn [sum x]
            (if (pred x) (inc sum) sum))
          0 coll))</pre></td></tr><tr><td class="docs"><p>Like the built-in group-by, but taking key-value pairs and building
   maps instead of vectors for the groups. It is tuned for performance
   with many values per key. <code>f</code> is a function taking 2 arguments, the
   key and value.</p>
</td><td class="codes"><pre class="brush: clojure">(defn group-by-maps
  ([f kvs]
     (group-by-maps f kvs {}))
  ([f kvs init-m]
     (-&gt;&gt; kvs
          ;; create a transient map of transient maps
          (reduce (fn [m [k v]]
                    (let [g (f k v)
                          items (get m g (transient init-m))]
                      (assoc! m g (assoc! items k v))))
                  (transient {}))
          ;; make the outer map persistent (can't seq it)
          (persistent!)
          ;; make the inner maps persistent within a transient outer map
          (reduce (fn [m [g items]]
                    (assoc! m g (persistent! items)))
                  (transient {}))
          ;; make the outer map persistent
          (persistent!))))</pre></td></tr><tr><td class="docs"><p>Transforms a transient map or vector <code>m</code> applying function <code>f</code> to
  the values under keys <code>ks</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn update-each!
  [m ks f]
  (if (empty? ks)
    m
    (reduce (fn [m k]
              (assoc! m k (f (get m k))))
            m
            ks)))</pre></td></tr><tr><td class="docs"><p>Transforms a map or vector <code>m</code> applying function <code>f</code> to the values
  under keys <code>ks</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn update-each
  [m ks f]
  (if (empty? ks)
    m
    (persistent!
     (update-each! (transient m) ks f))))</pre></td></tr><tr><td class="docs"><p>Like merge-with, but merges maps recursively, applying the given fn
  only when there's a non-map at a particular level.</p>
</td><td class="codes"><pre class="brush: clojure">(defn deep-merge-with
  [f &amp; maps]
  (apply
   (fn m [&amp; maps]
     (if (every? map? maps)
       (apply merge-with m maps)
       (apply f maps)))
   maps))</pre></td></tr><tr><td class="docs"><p>Like merge, but merges maps recursively.</p>
</td><td class="codes"><pre class="brush: clojure">(defn deep-merge
  [&amp; maps]
  (if (every? map? maps)
    (apply merge-with deep-merge maps)
    (last maps)))</pre></td></tr><tr><td class="docs"><p>Transforms a map <code>m</code> applying function <code>f</code> to each value.</p>
</td><td class="codes"><pre class="brush: clojure">(defn remap
  [f m]
  (into (or (empty m) {})
        (map (fn [[k v]] [k (f v)]))
        m))</pre></td></tr><tr><td class="docs"><p>Like <code>(reverse (take n (keys (sort-by val &gt; m))))</code> but faster.</p>
</td><td class="codes"><pre class="brush: clojure">(defn top-n-keys-by-value
  [n m]
  (cond
   (&lt;= n 0) []
   (== n 1) [(key (apply max-key val (seq m)))]
   :else
   (loop [ms (seq m)
          am (sorted-map-by #(compare [(m %1) %1] [(m %2) %2]))
          curr-min -1.0]
     (if (empty? ms)
       (keys am)
       (let [[k v] (first ms)]
         (cond
          ;; just initialising the set
          (empty? am)
          (recur (next ms)
                 (assoc am k v)
                 (double v))
          ;; filling up the set
          (&lt; (count am) n)
          (recur (next ms)
                 (assoc am k v)
                 (double (min curr-min v)))
          ;; include this one, dominates previous min
          (&gt; v curr-min)
          (let [new-am (-&gt; (dissoc am (first (keys am)))
                           (assoc k v))]
            (recur (next ms)
                   new-am
                   (double (first (vals new-am)))))
          ;; exclude this one
          :else
          (recur (next ms) am curr-min)))))))</pre></td></tr><tr><td class="docs"><p>Returns a collection of
  <code>[(take w0 coll) (take w1 (drop w0 coll)) ...</code>
  and ending with a sequence containing the remainder.</p>
</td><td class="codes"><pre class="brush: clojure">(defn splits-at
  [ws coll]
  (reduce (fn [subcolls w]
            (concat (drop-last subcolls)
                    (split-at w (last subcolls))))
          [coll] ws))</pre></td></tr><tr><td class="docs"><p>Returns a collection of
  <code>[(take-while pred0 coll) (take-while pred1 (drop-while pred0 coll)) ...</code>
  and ending with a sequence containing the remainder.</p>
</td><td class="codes"><pre class="brush: clojure">(defn splits-with
  [preds coll]
  (reduce (fn [subcolls pred]
            (concat (drop-last subcolls)
                    (split-with pred (last subcolls))))
          [coll] preds))</pre></td></tr><tr><td class="docs"><p>Using the provided widths and a coll of colls of indices, lazily adjust
  each index so that each coll of indices starts where the previous coll ended.
  Lazily concat all results.</p>
</td><td class="codes"><pre class="brush: clojure">(defn align-indices
  ([widths]
     ;; reserving arity -- this could become a transducer
     :not-implemented)
  ([widths collcoll]
     (let [[leftmost &amp; others] collcoll
           offs (reductions + widths)]
       (concat leftmost
               (mapcat #(map (partial + %) %2) offs others)))))</pre></td></tr><tr><td class="docs"><p>Partition a sorted seq of indices into <code>(count widths)</code> seqs of unshifted
  indices. Determine boundaries via <code>widths</code>. <code>aligned-is</code> must be sorted.</p>
</td><td class="codes"><pre class="brush: clojure">(defn unalign-indices
  [widths aligned-is]
  (let [offs (-&gt;&gt; widths (reductions + 0) (drop 1))
        [leftmost &amp; others] (-&gt;&gt; aligned-is
                                 (splits-with (map (partial partial &gt;) offs)))
        shifted (apply vector leftmost
                       (map (fn [section offset]
                              (map #(- % offset) section))
                            others offs))]
    (assert (empty? (last shifted))
            &quot;No indices should be beyond the final offset.&quot;)
    (drop-last shifted)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def empty-queue
  #?(:cljs cljs.core.PersistentQueue.EMPTY
     :clj clojure.lang.PersistentQueue/EMPTY))</pre></td></tr><tr><td class="docs"><p>Returns a function that adds a metadata key <code>meta-key</code> to its
   argument, being a #queue of the last <code>keep-n</code> values extracted
   using <code>value-fn</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn keep-history-middleware
  [keep-n value-fn meta-key]
  (let [hist (atom empty-queue)]
    (fn [x]
      (vary-meta x assoc meta-key
                 (swap! hist (fn [h]
                               (let [h2 (conj h (value-fn x))]
                                 (if (&gt;= (count h) keep-n) (pop h2) h2))))))))</pre></td></tr><tr><td class="docs"><p>Returns a function that adds a metadata key <code>meta-key</code> to its
   argument, being a map of the frequencies of values extracted
   using <code>value-fn</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn frequencies-middleware
  [value-fn meta-key]
  (let [freqs (atom {})]
    (fn [x]
      (-&gt;&gt; (fn [m]
             (update-in m [(value-fn x)] (fnil inc 0)))
           (swap! freqs)
           (vary-meta x assoc meta-key)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#org.nfrac.comportex.demos.coordinates-2d" name="org.nfrac.comportex.demos.coordinates-2d"><h1 class="project-name">org.nfrac.comportex.demos.coordinates-2d</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns org.nfrac.comportex.demos.coordinates-2d
  (:require [org.nfrac.comportex.core :as core]
            [org.nfrac.comportex.protocols :as p]
            [org.nfrac.comportex.encoders :as enc]
            [org.nfrac.comportex.util :as util :refer [abs round]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def input-dim [30 30])
(def n-on-bits 30)
(def max-pos 45)
(def max-vel 5)
(def radius 15)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def spec
  {:column-dimensions [20 50]
   :depth 8})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def higher-level-spec
  {:column-dimensions [20 20]
   :proximal {:max-segments 5}})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def initial-input-val
  {:x -10 :y -20 :vx 1 :vy 1 :ax 1 :ay 1})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn clamp-vec
  [[vx vy] max-mag]
  (let [mag (Math/sqrt (+ (* vx vx) (* vy vy)))
        scale (/ max-mag mag)]
    (if (&gt; mag max-mag)
      [(* vx scale) (* vy scale)]
      [vx vy])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn wrap
  [x lim]
  (-&gt; x
      (+ lim)
      (mod (* 2 lim))
      (- lim)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn input-transform
  [{:keys [x y vx vy ax ay]}]
  (let [[vx2 vy2] (clamp-vec [(+ vx ax) (+ vy ay)] max-vel)
        x2 (+ x vx)
        y2 (+ y vy)]
    {:x (round (wrap x2 max-pos))
     :y (round (wrap y2 max-pos))
     :vx vx2
     :vy vy2
     ;; if crossing the x axis, reverse ax
     :ax (if (not= (pos? y) (pos? y2))
           (* ax -1)
           ax)
     ;; if crossing the y axis, reverse ay
     :ay (if (not= (pos? x) (pos? x2))
           (* ay -1)
           ay)}))</pre></td></tr><tr><td class="docs"><p>Returns an infinite lazy seq of sensory input values.</p>
</td><td class="codes"><pre class="brush: clojure">(defn input-seq
  []
  (iterate input-transform initial-input-val))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def sensor
  [(enc/vec-selector :x :y)
   (enc/coordinate-encoder input-dim n-on-bits [1 1] [radius radius])])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn n-region-model
  ([n]
   (n-region-model n spec))
  ([n spec]
   (core/regions-in-series n core/sensory-region
                           (list* spec (repeat higher-level-spec))
                           {:input sensor})))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#org.nfrac.comportex.demos.directional-steps-1d" name="org.nfrac.comportex.demos.directional-steps-1d"><h1 class="project-name">org.nfrac.comportex.demos.directional-steps-1d</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns org.nfrac.comportex.demos.directional-steps-1d
  (:require [org.nfrac.comportex.core :as core]
            [org.nfrac.comportex.encoders :as enc]
            [org.nfrac.comportex.util :as util]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def bit-width 300)
(def cat-bit-width 60)
(def numb-bit-width (- bit-width cat-bit-width))
(def numb-max 7)
(def numb-domain [0 numb-max])
(def n-on-bits 30)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def spec
  {:column-dimensions [800]
   :ff-potential-radius 0.2
   :ff-init-frac 0.3
   :global-inhibition? false
   :activation-level 0.04
   :boost-active-every 10000
   :depth 4
   })</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def higher-level-spec
  (util/deep-merge
   spec
   {:column-dimensions [500]
    :proximal {:max-segments 5}}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def initial-input-val [:up 0])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn input-transform
  [[dir i]]
  (let [new-i (-&gt; (case dir
                    :up (inc i)
                    :down (dec i))
                  (min numb-max)
                  (max 0))
        new-dir (rand-nth [:up :down])] ;; mutation! impurity!
    [new-dir new-i]))</pre></td></tr><tr><td class="docs"><p>Returns an infinite lazy seq of sensory input values.</p>
</td><td class="codes"><pre class="brush: clojure">(defn input-seq
  []
  (iterate input-transform initial-input-val))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def sensor
  (enc/sensor-cat
   [[0] (enc/category-encoder [cat-bit-width] [:down :up])]
   [[1] (enc/linear-encoder [numb-bit-width] n-on-bits numb-domain)]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn n-region-model
  ([n]
   (n-region-model n spec))
  ([n spec]
   (core/regions-in-series n core/sensory-region
                           (list* spec (repeat higher-level-spec))
                           {:input sensor})))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#org.nfrac.comportex.demos.identity" name="org.nfrac.comportex.demos.identity"><h1 class="project-name">org.nfrac.comportex.demos.identity</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns org.nfrac.comportex.demos.identity
  (:require [org.nfrac.comportex.core :as core]
            [org.nfrac.comportex.protocols :as p]
            [org.nfrac.comportex.encoders :as enc]
            [org.nfrac.comportex.util :as util]
            [clojure.string :as str]
            #?(:clj [clojure.core.async :refer [put! &gt;! &lt;! go]]
                    :cljs [cljs.core.async :refer [put! &gt;! &lt;!]]))
  #?(:cljs (:require-macros [cljs.core.async.macros :refer [go]])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def bit-width 600)
(def n-on-bits 30)
(def motor-bit-width 10)
(def motor-n-on-bits 5)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def test-text
  &quot;
Look at this apple.
This apple is round.
This apple is red.
It is round and red.
Look at that apple.
That apple is round.
That apple is green.
It is also round but it is green not red.
This is a apple.
This is a apple and it is red.
This is a red apple.
That is a apple and it is green.
That is a green apple.
This apple is good to eat.
That apple is also good to eat.
A green apple is good to eat.
A red apple is good to eat.
But a brown apple is bad.
A brown apple is not good to eat.
This apple is not brown.
This apple is not bad.
That apple is also not brown.
That apple is also not bad.
A apple is a fruit.
A orange is a fruit.
A banana is also a fruit.
A apple is round.
A orange is round.
But a banana is not round.
This is a fruit.
This fruit is good to eat.
&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def test-text-2
  &quot;
Look at this dog.
This dog has a tail.
This dog is small.
This dog is not big.
This dog is white.
Look at that dog.
That dog has a tail.
That dog is big.
That dog is not small.
That dog is brown.
This is a dog.
This is a small dog.
That is a dog.
That is a big dog.
That is a round dog.
This dog is good to play with.
A small dog is good to play with.
A dog is a animal.
A person is a animal.
A apple is not a animal.
A fruit is not a animal.
A dog has a tail.
A person has not a tail.
This is a animal.
This animal is small.
This animal has a tail.
This is a small animal.
Look at this person.
This person is Jane.
Jane is a person.
Jane is good to play with.
Jane is not a dog.
Jane is a big person.
&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn parse-sentences
  [text*]
  (let [text (str/lower-case (str/trim text*))]
    (-&gt;&gt; (str/split text #&quot;[^\w]*\.+[^\w]*&quot;)
         (mapv #(str/split % #&quot;[^\w']+&quot;)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def spec
  {:column-dimensions [1000]
   :depth 8
   :distal-perm-init 0.21
   :use-feedback? true
   })</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def higher-level-spec-diff
  {:column-dimensions [1000]
   :depth 8
   :ff-max-segments 5})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn initial-inval
  [sentences]
  {:sentences sentences
   :position [0 0] ;; [sentence word]
   :value (get-in sentences [0 0])
   :action {:next-word-saccade -1
            :next-sentence-saccade -1}
   })</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn next-position
  [[senti wordi] action]
  (cond
    (pos? (:next-sentence-saccade action))
    [(inc senti) 0]
    (neg? (:next-sentence-saccade action))
    [0 0]
    (pos? (:next-word-saccade action))
    [senti (inc wordi)]
    (neg? (:next-word-saccade action))
    [senti 0]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn apply-action
  [inval]
  (let [new-posn (next-position (:position inval) (:action inval))
        new-value (get-in (:sentences inval) new-posn)]
    (assoc inval
           :position new-posn
           :value new-value)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def word-sensor
  [:value
   (enc/unique-encoder [bit-width] n-on-bits)])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def word-motor-sensor
  [[:action :next-word-saccade]
   (enc/category-encoder [motor-bit-width] [1 -1])])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def sentence-motor-sensor
  [[:action :next-sentence-saccade]
   (enc/category-encoder [motor-bit-width] [1 -1])])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn two-region-model
  ([]
   (two-region-model spec))
  ([spec]
   (core/region-network {:rgn-0 [:input :word-motor]
                         :rgn-1 [:rgn-0 :sentence-motor]}
                        (constantly core/sensory-region)
                        {:rgn-0 spec
                         :rgn-1 (merge spec higher-level-spec-diff)}
                        {:input word-sensor}
                        {:word-motor word-motor-sensor
                         :sentence-motor sentence-motor-sensor})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn htm-step-with-action-selection
  [world-c control-c]
  (comment
    ;; TODO: on next release of core.async, replace this go block with
    (let [inval (if-let [xf (poll! control-c)]
                  (xf inval)
                  inval)
          ]))
  (go
    (loop []
      (if-let [xf (&lt;! control-c)]
        (let [inval (&lt;! world-c)]
          (&gt;! world-c (xf inval))
          (recur)))))
  (fn [htm inval]
    (let [;; do first part of step, but not depolarise yet (depends on action)
          htm-a (-&gt; htm
                    (p/htm-sense inval :sensory)
                    (p/htm-activate)
                    (p/htm-learn))
          [senti wordi] (:position inval)
          ;; work out what the next action (saccade) should be
          sentences (:sentences inval)
          sentence (get sentences senti)
          word (get sentence wordi)
          end-of-sentence? (= wordi (dec (count sentence)))
          end-of-passage? (= senti (dec (count sentences)))
          r0-lyr (get-in htm-a [:regions :rgn-0 :layer-3])
          r1-lyr (get-in htm-a [:regions :rgn-1 :layer-3])
          r0-burst-frac (/ (count (p/bursting-columns r0-lyr))
                           (count (p/active-columns r0-lyr)))
          ;r1-burst-frac (/ (count (p/bursting-columns r1-lyr))
          ;                 (count (p/active-columns r1-lyr)))
          sent-burst? (cond-&gt; (:sentence-bursting? (:action inval))
                        ;; ignore burst on first word of sentence
                        (pos? wordi) (or (&gt;= r0-burst-frac 0.50)))
          action* (cond
                    ;; not yet at end of sentence
                    (not end-of-sentence?)
                    {:next-word-saccade 1}
                    ;; end of sentence.
                    ;; sentence not yet learned, repeat sentence
                    sent-burst?
                    {:sentence-bursting? false}
                    ;; go to next sentence (not yet at end of passage
                    ;; same letter-motor signal as when repeating a word
                    (not end-of-passage?)
                    {:next-sentence-saccade 1
                     :sentence-bursting? false}
                    ;; reached end of passage
                    :else
                    {:next-sentence-saccade -1
                     :sentence-bursting? false})
          ;; next-word-saccade represents starting a sentence (-1) or continuing (1)
          ;; that is all that rgn-0 knows.
          action (merge {:next-word-saccade -1
                         :next-sentence-saccade 0
                         :sentence-bursting? sent-burst?}
                        action*)
          inval-with-action (assoc inval :action action
                                   :prev-action (:action inval))]
      ;; calculate the next position
      (let [new-inval (apply-action inval-with-action)]
        (put! world-c new-inval))
      ;; depolarise (predict) based on action, and update :input-value
      (cond-&gt; htm-a
        true
        (p/htm-sense inval-with-action :motor)
        true
        (p/htm-depolarise)
        ;; reset first region's sequence when going on to new sentence
        (and end-of-sentence? (not sent-burst?))
        (update-in [:regions :rgn-0] p/break :tm)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#org.nfrac.comportex.demos.isolated-1d" name="org.nfrac.comportex.demos.isolated-1d"><h1 class="project-name">org.nfrac.comportex.demos.isolated-1d</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns org.nfrac.comportex.demos.isolated-1d
  (:require [org.nfrac.comportex.core :as core]
            [org.nfrac.comportex.encoders :as enc]
            [org.nfrac.comportex.util :as util]
            [clojure.test.check.random :as random]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def bit-width 300)
(def n-on-bits 20)</pre></td></tr><tr><td class="docs"><p>for block encoder</p>
</td><td class="codes"><pre class="brush: clojure">(def numb-max 15)
(def numb-domain [0 numb-max])</pre></td></tr><tr><td class="docs"><p>for coordinate encoder</p>
</td><td class="codes"><pre class="brush: clojure">(def radius n-on-bits) ;; select 50%</pre></td></tr><tr><td class="docs"><p>select 50%
number of coordinates between integers:</p>
</td><td class="codes"><pre class="brush: clojure">(def resolution (* 2 radius
                   0.8)) ;; 0.2 overlap between successive integers</pre></td></tr><tr><td class="docs"><p>0.2 overlap between successive integers</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def spec
  {:column-dimensions [1000]
   :ff-init-frac 0.2
   :ff-potential-radius 1.0
   :proximal {:perm-inc 0.10
              :perm-dec 0.01}
   :duty-cycle-period 100000
   })</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def higher-level-spec
  (util/deep-merge
   spec
   {:column-dimensions [400]
    :proximal {:max-segments 5}}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def patterns
  {:run-0-5 [0 1 2 3 4 5]
   :rev-5-1 [5 4 3 2 1]
   :run-6-10 [6 7 8 9 10]
   :jump-6-12 [6 7 8 11 12]
   :twos [0 2 4 6 8 10 12 14]
   :saw-10-15 [10 12 11 13 12 14 13 15]})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def pattern-order (keys patterns))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def gap-length 5)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn initial-world
  []
  (let [id (first pattern-order)
        values (patterns id)]
    (-&gt; {:id id
         :values values
         :index 0}
        (vary-meta assoc ::rng (random/make-random 42)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn world-transform
  [{:keys [id values index] :as input}]
  (if (&lt; index (dec (count values)))
    ;; continuing sequence
    (update-in input [:index] inc)
    ;; reached the end of a sequence
    (if id
      ;; start gap
      (assoc input
             :id nil
             :values (repeat gap-length nil)
             :index 0)
      ;; start another pattern
      (let [[rng rng*] (-&gt; (::rng (meta input))
                           (random/split))
            id (util/rand-nth rng* pattern-order)]
        (-&gt; {:id id
             :values (patterns id)
             :index 0}
            (vary-meta assoc ::rng rng))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn attach-current-value
  [m]
  (assoc m :value (get (:values m) (:index m))))</pre></td></tr><tr><td class="docs"><p>Returns an infinite lazy seq of sensory input values.</p>
</td><td class="codes"><pre class="brush: clojure">(defn input-seq
  []
  (-&gt;&gt; (iterate world-transform (initial-world))
       (map attach-current-value)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def block-sensor
  [:value
   (enc/linear-encoder [bit-width] n-on-bits numb-domain)])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def coord-sensor
  [(enc/vec-selector :value)
   (enc/coordinate-encoder [bit-width] n-on-bits [resolution] [radius])])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn n-region-model
  ([n]
   (n-region-model n spec))
  ([n spec]
   (core/regions-in-series n core/sensory-region
                           (list* spec (repeat higher-level-spec))
                           {:input block-sensor})))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#org.nfrac.comportex.demos.letters" name="org.nfrac.comportex.demos.letters"><h1 class="project-name">org.nfrac.comportex.demos.letters</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns org.nfrac.comportex.demos.letters
  (:require [org.nfrac.comportex.core :as core]
            [org.nfrac.comportex.encoders :as enc]
            [org.nfrac.comportex.util :as util]
            [clojure.string :as str]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def bit-width 500)
(def n-on-bits 25)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def spec
  {:column-dimensions [1000]
   :depth 8
   :distal {:perm-init 0.21}
   :distal-vs-proximal-weight 0.2
   })</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def higher-level-spec
  (util/deep-merge
   spec
   {:column-dimensions [800]
    :proximal {:max-segments 5}}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn clean-text
  [text]
  (-&gt; (str/lower-case text)
      (str/replace #&quot;\s+&quot; &quot; &quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def random-sensor
  [:value
   (enc/unique-encoder [bit-width] n-on-bits)])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn n-region-model
  ([n]
   (n-region-model n spec))
  ([n spec]
   (core/regions-in-series n core/sensory-region
                           (list* spec (repeat higher-level-spec))
                           {:input random-sensor})))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#org.nfrac.comportex.demos.mixed-gaps-1d" name="org.nfrac.comportex.demos.mixed-gaps-1d"><h1 class="project-name">org.nfrac.comportex.demos.mixed-gaps-1d</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns org.nfrac.comportex.demos.mixed-gaps-1d
  (:require [org.nfrac.comportex.core :as core]
            [org.nfrac.comportex.encoders :as enc]
            [org.nfrac.comportex.util :as util]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def bit-width 400)
(def n-on-bits 25)</pre></td></tr><tr><td class="docs"><p>for block encoder</p>
</td><td class="codes"><pre class="brush: clojure">(def numb-max 15)
(def numb-domain [0 numb-max])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def spec
  {:column-dimensions [1000]
   :ff-init-frac 0.2
   :ff-potential-radius 1.0
   :proximal {:perm-inc 0.10
              :perm-dec 0.01}
   :duty-cycle-period 100000
   })</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def higher-level-spec
  (util/deep-merge
   spec
   {:column-dimensions [400]
    :proximal {:max-segments 5}}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def patterns
  {:run-0-5 [0 1 2 3 4 5]
   :rev-5-1 [5 4 3 2 1]
   :run-6-10 [6 7 8 9 10]
   :jump-6-12 [6 7 8 11 12]
   :twos [0 2 4 6 8 10 12 14]
   :saw-10-15 [10 12 11 13 12 14 13 15]})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def pattern-order (keys patterns))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def gap-range
  (-&gt;&gt; (vals patterns) (map count) (reduce +) (long) (* 2)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn initial-world
  []
  (assoc {} (first pattern-order) 0))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn world-transform
  [input]
  (reduce (fn [m [id values]]
            (if-let [index (m id)]
              ;; pattern is currently active
              (if (&lt; index (dec (count (patterns id))))
                ;; continue
                (update-in m [id] inc)
                ;; finished
                (dissoc m id))
              ;; pattern is not currently active
              (if (zero? (rand-int gap-range)) ;; mutation! impurity!
                ;; start
                (assoc m id 0)
                m)))
          input
          patterns))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn current-values
  [world]
  (map (fn [[id index]]
         (get-in patterns [id index]))
       world))</pre></td></tr><tr><td class="docs"><p>Returns an infinite lazy seq of sensory input values.</p>
</td><td class="codes"><pre class="brush: clojure">(defn input-seq
  []
  (-&gt;&gt; (iterate world-transform (initial-world))
       (map #(assoc % :values (current-values %)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def block-sensor
  [:values
   (enc/ensplat
    (enc/linear-encoder [bit-width] n-on-bits numb-domain))])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn n-region-model
  ([n]
   (n-region-model n spec))
  ([n spec]
   (core/regions-in-series n core/sensory-region
                           (list* spec (repeat higher-level-spec))
                           {:input block-sensor})))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#org.nfrac.comportex.demos.q-learning-1d" name="org.nfrac.comportex.demos.q-learning-1d"><h1 class="project-name">org.nfrac.comportex.demos.q-learning-1d</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns org.nfrac.comportex.demos.q-learning-1d
  (:require [org.nfrac.comportex.core :as core]
            [org.nfrac.comportex.protocols :as p]
            [org.nfrac.comportex.cells :as cells]
            [org.nfrac.comportex.synapses :as syn]
            [org.nfrac.comportex.encoders :as enc]
            [org.nfrac.comportex.util :as util :refer [round abs]]
            #?(:clj [clojure.core.async :refer [put!]]
               :cljs [cljs.core.async :refer [put!]])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def input-dim [400])
(def n-on-bits 40)
(def coord-radius 60) ;; so 60+1+60 = 121 candidates (and we choose 40)</pre></td></tr><tr><td class="docs"><p>so 60+1+60 = 121 candidates (and we choose 40)</p>
</td><td class="codes"><pre class="brush: clojure">(def surface-coord-scale 60) ;; so neighbouring positions (x +/- 1) share ~50% bits</pre></td></tr><tr><td class="docs"><p>so neighbouring positions (x +/- 1) share ~50% bits</p>
</td><td class="codes"><pre class="brush: clojure">(def surface [0 0.5 1 1.5 2 1.5 1 0.5
              0 1 2 3 4 5 4 3 2
              1 1 1 1 1 1
              1 2 3 4 5 6 7 8 6 4 2
              ])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def initial-inval
  {:x 5
   :y (surface 5)
   :dy 0
   :action {:dx 0}})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def spec
  {:column-dimensions [1000]
   :depth 4
   :distal {:punish? true}
   :duty-cycle-period 300
   :boost-active-duty-ratio 0.01
   :ff-potential-radius 0.15
   :ff-init-frac 0.5})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def action-spec
  {:column-dimensions [30]
   :activation-level 0.20
   :ff-potential-radius 1.0
   :ff-init-frac 0.5
   :proximal {:perm-inc 0.05
              :perm-dec 0.05
              :perm-connected 0.10}
   :ff-perm-init-lo 0.35
   :ff-perm-init-hi 0.45
   ;; chosen for exploration - fresh connections fully boosted &gt; 1.0:
   :max-boost 3.0
   :global-inhibition? true
   :boost-active-every 1
   :duty-cycle-period 150
   :boost-active-duty-ratio 0.05
   :depth 1
   :q-alpha 0.2
   :q-discount 0.8
   ;; do not want temporal pooling here - actions are not static
   :temporal-pooling-max-exc 0.0
   ;; disable learning; custom learning function below
   :freeze? true})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def direction-&gt;action
  {:left {:dx -1}
   :right {:dx 1}})</pre></td></tr><tr><td class="docs"><p>lookup on columns of :action region</p>
</td><td class="codes"><pre class="brush: clojure">(def column-&gt;signal
  (zipmap (range)
          (for [direction [:left :right]
                influence (repeat 15 1.0)]
            [direction influence])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn select-action
  [htm]
  (let [alyr (get-in htm [:regions :action :layer-3])
        acols (p/active-columns alyr)
        signals (map column-&gt;signal acols)]
    (-&gt;&gt; signals
         (reduce (fn [m [motion influence]]
                   (assoc! m motion (+ (get m motion 0) influence)))
                 (transient {}))
         (persistent!)
         (shuffle)
         (apply max-key val)
         (key)
         (direction-&gt;action))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn apply-action
  [inval]
  (let [x (:x inval)
        dx (:dx (:action inval))
        next-x (-&gt; (+ x dx)
                   (min (dec (count surface)))
                   (max 0))
        next-y (surface next-x)
        dy (- next-y (:y inval))]
    (assoc inval
           :x next-x
           :y next-y
           :dy dy)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn active-synapses
  [sg target-id ff-bits]
  (filter (fn [[in-id p]]
            (ff-bits in-id))
          (p/in-synapses sg target-id)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn active-synapse-perms
  [sg target-id ff-bits]
  (keep (fn [[in-id p]]
          (when (ff-bits in-id) p))
        (p/in-synapses sg target-id)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn mean [xs] (/ (apply + xs) (count xs)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn q-learn
  [htm prev-htm reward]
  (update-in htm [:regions :action :layer-3]
             (fn [lyr]
               (let [prev-lyr (get-in prev-htm [:regions :action :layer-3])
                     {:keys [ff-perm-init-lo q-alpha q-discount]} (p/params lyr)
                     ff-bits (or (:in-ff-bits (:state lyr)) #{})
                     acols (:active-cols (:state lyr))
                     prev-ff-bits (or (:in-ff-bits (:state prev-lyr)) #{})
                     prev-acols (:active-cols (:state prev-lyr))
                     psg (:proximal-sg lyr)
                     ;; Q = estimate of optimal future value = average active perm.
                     aperms (mapcat (fn [col]
                                      (active-synapse-perms psg [col 0 0] ff-bits))
                                    acols)
                     Q-est (if (seq aperms)
                             (- (mean aperms) ff-perm-init-lo) ;; TODO include boost
                             0)
                     Q-old (:Q-val (:Q-info lyr) 0)
                     learn-value (+ reward (* q-discount Q-est))
                     adjust (* q-alpha (- learn-value Q-old))
                     op (if (pos? adjust) :reinforce :punish)
                     seg-updates (map (fn [col]
                                        (syn/seg-update [col 0 0] op nil nil))
                                      prev-acols)]
                 (-&gt;
                  (p/layer-learn lyr)
                  (assoc :proximal-sg
                         (p/bulk-learn psg seg-updates prev-ff-bits
                                       (abs adjust) (abs adjust) 0.0))
                  (assoc :Q-info {:Q-val Q-est
                                  :Q-old Q-old
                                  :reward reward
                                  :lrn learn-value
                                  :adj adjust
                                  :perms (count aperms)}))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn make-model
  []
  (let [sensor [(enc/vec-selector :x)
                (enc/coordinate-encoder input-dim n-on-bits [surface-coord-scale]
                                        [coord-radius])]
        msensor [[:action :dx]
                 (enc/linear-encoder [100] 30 [-1 1])]]
    (core/region-network {:rgn-1 [:input :motor]
                          :action [:rgn-1]}
                         (constantly core/sensory-region)
                         {:rgn-1 (assoc spec :lateral-synapses? false)
                          :action action-spec}
                         {:input sensor}
                         {:input sensor
                          :motor msensor})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn htm-step-with-action-selection
  [world-c]
  (fn [htm inval]
    (let [;; do first part of step, but not depolarise yet (depends on action)
          htm-a (-&gt; htm
                    (p/htm-sense inval :sensory)
                    (p/htm-activate)
                    (p/htm-learn))
          ;; scale reward to be comparable to [0-1] permanences
          reward (* 0.5 (:dy inval))
          ;; do the Q learning update on action layer
          upd-htm (q-learn htm-a htm reward)
          ;; maintain map of state+action -&gt; approx Q values, for diagnostics
          info (get-in upd-htm [:regions :action :layer-3 :Q-info])
          newQ (-&gt; (+ (:Q-old info 0) (:adj info 0))
                   (max -1.0)
                   (min 1.0))
          Q-map (assoc (:Q-map inval)
                       (select-keys inval [:x :action])
                       newQ)
          action (select-action upd-htm)
          inval-with-action (assoc inval
                                   :action action
                                   :prev-action (:action inval)
                                   :Q-map Q-map)]
      ;; calculate the next position
      (let [new-inval (apply-action inval-with-action)]
        (put! world-c new-inval))
      (-&gt; upd-htm
          (p/htm-sense inval-with-action :motor)
          (p/htm-depolarise)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment
  (require '[clojure.core.async :as async :refer [&gt;!! &lt;!!]])
  (def world-c (async/chan))
  (def model (atom (make-model)))
  (def step (htm-step-with-action-selection world-c))
  (def inval initial-inval)
  (swap! model step inval)
  (def inval (&lt;!! world-c))
  inval
  (get-in @model [:regions :action :layer-3 :Q-info])
  (get-in @model [:regions :action :layer-3 :state :active-cols]))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#org.nfrac.comportex.demos.q-learning-2d" name="org.nfrac.comportex.demos.q-learning-2d"><h1 class="project-name">org.nfrac.comportex.demos.q-learning-2d</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns org.nfrac.comportex.demos.q-learning-2d
  (:require [org.nfrac.comportex.core :as core]
            [org.nfrac.comportex.protocols :as p]
            [org.nfrac.comportex.cells :as cells]
            [org.nfrac.comportex.encoders :as enc]
            [org.nfrac.comportex.util :as util :refer [round abs]]
            [org.nfrac.comportex.demos.q-learning-1d :refer [q-learn]]
            #?(:clj [clojure.core.async :refer [put!]]
               :cljs [cljs.core.async :refer [put!]])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def input-dim [10 40])
(def grid-w 7)
(def grid-h 7)
(def n-on-bits 40)
(def coord-radius 5) ;; so 11x11 grid = 121 candidates (and we choose 40)</pre></td></tr><tr><td class="docs"><p>so 11x11 grid = 121 candidates (and we choose 40)</p>
</td><td class="codes"><pre class="brush: clojure">(def surface-coord-scale 5) ;; so neighbouring positions (x or y +/- 1) share ~50% bits</pre></td></tr><tr><td class="docs"><p>so neighbouring positions (x or y +/- 1) share ~50% bits</p>
</td><td class="codes"><pre class="brush: clojure">(def empty-reward -3)
(def hazard-reward -200)
(def finish-reward 200)
(def surface
  (-&gt;&gt;
   (for [x (range grid-w)]
     (for [y (range grid-h)]
       (case [x y]
         [(dec grid-w) (dec grid-h)] finish-reward
         [(- (quot grid-w 2) 2) (quot grid-h 2)] hazard-reward
         [(quot grid-w 2) (quot grid-h 2)] hazard-reward
         [(quot grid-w 2) (- (quot grid-h 2) 1)] hazard-reward
         [(dec grid-w) 0] hazard-reward
         empty-reward)))
   (mapv vec)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def initial-inval
  {:x 0
   :y 0
   :z 0
   :action {:dx 0
            :dy 0}})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def spec
  {:column-dimensions [30 30]
   :depth 4
   :distal-punish? true
   :duty-cycle-period 300
   :boost-active-duty-ratio 0.01
   :ff-potential-radius 0.15
   :ff-init-frac 0.5})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def action-spec
  {:column-dimensions [4 10]
   :activation-level 0.20
   :ff-potential-radius 1
   :ff-init-frac 0.5
   :proximal {:perm-inc 0.05
              :perm-dec 0.05
              :perm-connected 0.10}
   :ff-perm-init-lo 0.35
   :ff-perm-init-hi 0.45
   ;; chosen for exploration - fresh connections fully boosted &gt; 1.0:
   :max-boost 3.0
   :global-inhibition? true
   :boost-active-every 1
   :duty-cycle-period 250
   :boost-active-duty-ratio 0.05
   :depth 1
   :q-alpha 0.75
   :q-discount 0.9
   ;; do not want temporal pooling here - actions are not static
   :temporal-pooling-max-exc 0.0
   ;; disable learning
   :freeze? true})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def direction-&gt;action
  {:up {:dx 0 :dy -1}
   :down {:dx 0 :dy 1}
   :left {:dx -1 :dy 0}
   :right {:dx 1 :dy 0}})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn possible-directions
  [[x y]]
  (cond-&gt; #{:up :down :left :right}
          (zero? x) (disj :left)
          (zero? y) (disj :up)
          (= x (dec grid-w)) (disj :right)
          (= y (dec grid-h)) (disj :down)))</pre></td></tr><tr><td class="docs"><p>lookup on columns of :action region</p>
</td><td class="codes"><pre class="brush: clojure">(def column-&gt;signal
  (zipmap (range)
          (for [motion [:up :down :left :right]
                influence (repeat 10 1.0)]
            [motion influence])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn select-action
  [htm curr-pos]
  (let [alyr (get-in htm [:regions :action :layer-3])
        acols (p/active-columns alyr)
        signals (map column-&gt;signal acols)
        poss (possible-directions curr-pos)]
    (-&gt;&gt; signals
         (reduce (fn [m [motion influence]]
                   (assoc! m motion (+ (get m motion 0) influence)))
                 (transient {}))
         (persistent!)
         (filter (comp poss key))
         (apply max-key val)
         (key)
         (direction-&gt;action))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn apply-action
  [inval]
  (let [x (:x inval)
        y (:y inval)
        dx (:dx (:action inval))
        dy (:dy (:action inval))
        next-x (-&gt; (+ x dx)
                   (min (dec grid-w))
                   (max 0))
        next-y (-&gt; (+ y dy)
                   (min (dec grid-h))
                   (max 0))
        next-z (get-in surface [next-x next-y])]
    (assoc inval
           :x next-x
           :y next-y
           :z next-z)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn make-model
  []
  (let [sensor [(enc/vec-selector :x :y)
                (enc/coordinate-encoder input-dim n-on-bits
                                        [surface-coord-scale surface-coord-scale]
                                        [coord-radius coord-radius])]
        dx-sensor [[:action :dx] (enc/linear-encoder [100] 30 [-1 1])]
        dy-sensor [[:action :dy] (enc/linear-encoder [100] 30 [-1 1])]
        msensor (enc/sensor-cat dx-sensor dy-sensor)]
    (core/region-network {:rgn-1 [:input :motor]
                          :action [:rgn-1]}
                         (constantly core/sensory-region)
                         {:rgn-1 (assoc spec :lateral-synapses? false)
                          :action action-spec}
                         {:input sensor}
                         {:input sensor
                          :motor msensor})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn htm-step-with-action-selection
  [world-c]
  (fn [htm inval]
    (let [;; do first part of step, but not depolarise yet (depends on action)
          htm-a (-&gt; htm
                    (p/htm-sense inval :sensory)
                    (p/htm-activate)
                    (p/htm-learn))
          ;; scale reward to be comparable to [0-1] permanences
          reward (* 0.01 (:z inval))
          terminal-state? (&gt;= (abs (:z inval)) 100)
          ;; do the Q learning update on action layer (except initially)
          upd-htm (if (:prev-action inval)
                    (q-learn htm-a htm reward)
                    (assoc-in htm-a [:regions :action :layer-3 :Q-info] {}))
          ;; maintain map of state+action -&gt; approx Q values, for diagnostics
          info (get-in upd-htm [:regions :action :layer-3 :Q-info])
          newQ (-&gt; (+ (:Q-old info 0) (:adj info 0))
                   (max -1.0)
                   (min 1.0))
          Q-map (assoc (:Q-map inval)
                       (select-keys inval [:x :y :action])
                       newQ)
          action (select-action upd-htm [(:x inval) (:y inval)])
          inval-with-action (assoc inval
                                   :action action
                                   :prev-action (:action inval)
                                   :Q-map Q-map)]
      ;; calculate the next position
      (let [new-inval (if terminal-state?
                        ;; restart
                        (assoc initial-inval :Q-map Q-map)
                        ;; continuing
                        (apply-action inval-with-action))]
        (put! world-c new-inval))
      (cond-&gt; upd-htm
          true
          (p/htm-sense inval-with-action :motor)
          true
          (p/htm-depolarise)
          terminal-state?
          (p/break :tm)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment
  (require '[clojure.core.async :as async :refer [&gt;!! &lt;!!]])
  (def world-c (async/chan))
  (def model (atom (make-model)))
  (def step (htm-step-with-action-selection world-c))
  (def inval initial-inval)
  (swap! model step inval)
  (def inval (&lt;!! world-c))
  inval
  (get-in @model [:regions :action :layer-3 :Q-info])
  (get-in @model [:regions :action :layer-3 :state :active-cols]))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#org.nfrac.comportex.demos.repeat" name="org.nfrac.comportex.demos.repeat"><h1 class="project-name">org.nfrac.comportex.demos.repeat</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns org.nfrac.comportex.demos.repeat
  (:require [org.nfrac.comportex.core :as core]
            [org.nfrac.comportex.encoders :as enc]
            [org.nfrac.comportex.util :as util]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def stimuli (mapv (comp keyword str) &quot;abcd&quot;))
(def stimuli2 (mapv (comp keyword str) &quot;efghijklmnopqrstuvwxyz&quot;))
(def signals [:start :again :pause :stop])
(def tokens (vec (concat signals stimuli stimuli2)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def n-on-bits 20)
(def bit-width (* n-on-bits (count tokens)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def spec
  {:column-dimensions [1000]
   :depth 5
   :distal {:punish? false}})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def higher-level-spec
  (util/deep-merge
   spec
   {:column-dimensions [400]
    :proximal {:max-segments 5}}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn presentation
  [n stimulus-seq]
  (concat [:start]
          (apply concat
                 (interpose [:again] (repeat n stimulus-seq)))
          [:stop]
          [nil]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def block-sensor
  [:value (enc/category-encoder [bit-width] tokens)])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn repeatcat
  [n xs]
  (apply concat (repeat n xs)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn input-seq
  [stimuli reps]
  (-&gt;&gt; (concat (mapcat #(repeatcat reps (presentation 1 [%])) stimuli)
               (mapcat #(repeatcat reps (presentation 2 [%])) stimuli)
               (mapcat #(repeatcat reps (presentation 2 %)) (partition 2 2 stimuli)))
       (map (partial hash-map :value))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn n-region-model
  ([n]
   (n-region-model n spec))
  ([n spec]
   (core/regions-in-series n core/sensory-region
                           (list* spec (repeat higher-level-spec))
                           {:input block-sensor})))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#org.nfrac.comportex.demos.second-level-motor" name="org.nfrac.comportex.demos.second-level-motor"><h1 class="project-name">org.nfrac.comportex.demos.second-level-motor</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns org.nfrac.comportex.demos.second-level-motor
  (:require [org.nfrac.comportex.core :as core]
            [org.nfrac.comportex.protocols :as p]
            [org.nfrac.comportex.encoders :as enc]
            [org.nfrac.comportex.util :as util]
            [clojure.string :as str]
            #?(:clj [clojure.core.async :refer [put! &gt;! &lt;! go]]
               :cljs [cljs.core.async :refer [put! &gt;! &lt;!]]))
  #?(:cljs (:require-macros [cljs.core.async.macros :refer [go]])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def bit-width 600)
(def n-on-bits 30)
(def motor-bit-width 10)
(def motor-n-on-bits 5)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def test-text
  &quot;one two three four.
the three little pigs.
6874230
1874235.
6342785
1342780.
09785341
29785346.
04358796
24358791.&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn parse-sentences
  [text*]
  (let [text (str/lower-case (str/trim text*))]
    (-&gt;&gt; (str/split text #&quot;[^\w]*\.+[^\w]*&quot;)
         (mapv #(str/split % #&quot;[^\w']+&quot;))
         (mapv #(mapv vec %)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def spec
  {:column-dimensions [1000]
   :depth 8
   :proximal {:perm-stable-inc 0.15
              :perm-inc 0.04
              :perm-dec 0.01}
   :lateral-synapses? true
   :distal-vs-proximal-weight 0.0
   :use-feedback? false
   })</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def higher-level-spec
  (util/deep-merge
   spec
   {:column-dimensions [800]
    :proximal {:max-segments 5
               :new-synapse-count 12
               :learn-threshold 6}}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn initial-inval
  [sentences]
  {:sentences sentences
   :position [0 0 0] ;; [sentence word letter]
   :value (get-in sentences [0 0 0])
   :action {:next-letter-saccade -1
            :next-word-saccade -1
            :next-sentence-saccade -1}
   })</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn next-position
  [[i j k] action]
  (cond
    (pos? (:next-sentence-saccade action))
    [(inc i) 0 0]
    (neg? (:next-sentence-saccade action))
    [0 0 0]
    (pos? (:next-word-saccade action))
    [i (inc j) 0]
    (neg? (:next-word-saccade action))
    [i 0 0]
    (pos? (:next-letter-saccade action))
    [i j (inc k)]
    (neg? (:next-letter-saccade action))
    [i j 0]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn apply-action
  [inval]
  (let [new-posn (next-position (:position inval) (:action inval))
        new-value (get-in (:sentences inval) new-posn)]
    (assoc inval
           :position new-posn
           :value new-value)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def letter-sensor
  [:value
   (enc/unique-encoder [bit-width] n-on-bits)])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def letter-motor-sensor
  [[:action :next-letter-saccade]
   (enc/category-encoder [motor-bit-width] [1 -1])])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def word-motor-sensor
  [[:action :next-word-saccade]
   (enc/category-encoder [motor-bit-width] [1 -1])])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn two-region-model
  ([]
   (two-region-model spec))
  ([spec]
   (core/region-network {:rgn-0 [:input :letter-motor]
                         :rgn-1 [:rgn-0 :word-motor]}
                        (constantly core/sensory-region)
                        {:rgn-0 spec
                         :rgn-1 higher-level-spec}
                        {:input letter-sensor}
                        {:letter-motor letter-motor-sensor
                         :word-motor word-motor-sensor})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn htm-step-with-action-selection
  [world-c control-c]
  (comment
    ;; TODO: on next release of core.async, replace this go block with
    (let [inval (if-let [xf (poll! control-c)]
                  (xf inval)
                  inval)
          ]))
  (go
    (loop []
      (if-let [xf (&lt;! control-c)]
        (let [inval (&lt;! world-c)]
          (&gt;! world-c (xf inval))
          (recur)))))
  (fn [htm inval]
    (let [;; do first part of step, but not depolarise yet (depends on action)
          htm-a (-&gt; htm
                    (p/htm-sense inval :sensory)
                    (p/htm-activate)
                    (p/htm-learn))
          [i j k] (:position inval)
          ;; work out what the next action (saccade) should be
          sentences (:sentences inval)
          sentence (get sentences i)
          word (get sentence j)
          end-of-word? (= k (dec (count word)))
          end-of-sentence? (= j (dec (count sentence)))
          end-of-passage? (= i (dec (count sentences)))
          r0-lyr (get-in htm-a [:regions :rgn-0 :layer-3])
          r1-lyr (get-in htm-a [:regions :rgn-1 :layer-3])
          r0-burst-frac (/ (* (p/layer-depth r0-lyr) ;; number of cells
                              (count (p/bursting-columns r0-lyr)))
                           (max 1 (count (p/active-cells r0-lyr))))
          word-burst? false #_(cond-&gt; (:word-bursting? (:action inval))
                        ;; ignore burst on first letter of word
                        (pos? k) (or (&gt;= r0-burst-frac 0.50)))
          sent-burst? (cond-&gt; (:sentence-bursting? (:action inval))
                        ;; ignore burst on first letter of word
                        (pos? k) (or (&gt;= r0-burst-frac 0.50)))
          action* (cond
                    ;; not yet at end of word
                    (not end-of-word?)
                    {:next-letter-saccade 1}
                    ;; end of word.
                    ;; word not yet learned, repeat word
                    word-burst?
                    {:word-bursting? false}
                    ;; go to next word (not yet at end of sentence)
                    ;; same letter-motor signal as when repeating a word
                    (not end-of-sentence?)
                    {:next-word-saccade 1
                     :word-bursting? false}
                    ;; end of sentence.
                    ;; sentence not yet learned, repeat sentence
                    sent-burst?
                    {:next-word-saccade -1
                     :word-bursting? false
                     :sentence-bursting? false}
                    ;; not yet at end of passage, go to next sentence
                    (not end-of-passage?)
                    {:next-sentence-saccade 1
                     :next-word-saccade 1
                     :word-bursting? false
                     :sentence-bursting? false}
                    ;; reached end of passage
                    :else
                    {:next-word-saccade -1
                     :word-bursting? false
                     :sentence-bursting? false})
          ;; next-letter-saccade represents starting a word (-1) or continuing (1)
          ;; that is all that rgn-0 knows.
          action (merge {:next-letter-saccade -1
                         :next-word-saccade 0
                         :next-sentence-saccade 0
                         :word-bursting? word-burst?
                         :sentence-bursting? sent-burst?}
                        action*)
          inval-with-action (assoc inval :action action
                                   :prev-action (:action inval))]
      ;; calculate the next position
      (let [new-inval (apply-action inval-with-action)]
        (put! world-c new-inval))
      ;; depolarise (predict) based on action, and update :input-value
      (cond-&gt; htm-a
        true
        (p/htm-sense inval-with-action :motor)
        true
        (p/htm-depolarise)
        ;; reset first region's sequence when going on to new word
        (and end-of-word? (not word-burst?))
        (update-in [:regions :rgn-0] p/break :tm)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment
  (require '[clojure.core.async :refer [chan put! &lt;!!]])
  (def world-c (chan))
  (def control-c (chan))
  (def step (htm-step-with-action-selection world-c control-c))
  (def in (initial-inval (parse-sentences test-text)))
  (def mo (two-region-model))
  (def mo2 (step mo in))
  (def in2 (&lt;!! world-c)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#org.nfrac.comportex.demos.sensorimotor-1d" name="org.nfrac.comportex.demos.sensorimotor-1d"><h1 class="project-name">org.nfrac.comportex.demos.sensorimotor-1d</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns org.nfrac.comportex.demos.sensorimotor-1d
  (:require [org.nfrac.comportex.core :as core]
            [org.nfrac.comportex.encoders :as enc]
            [org.nfrac.comportex.util :as util]
            [clojure.test.check.random :as random]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def bit-width 300)
(def motor-bit-width 100)
(def motor-n-on-bits 25)
(def world-size 10)
(def items [:a :b :c :d :e :f :g :h :i :j])
(def saccades [-1 0 1 2])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def higher-level-spec-diff
  {:column-dimensions [800]
   :proximal {:max-segments 5
              :new-synapse-count 12
              :learn-threshold 6}})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def spec
  {:column-dimensions [800]
   :depth 5
   :proximal {:perm-inc 0.10
              :perm-dec 0.01}
   :distal {:punish? false}
   :layer-3 higher-level-spec-diff})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def higher-level-spec
  (util/deep-merge spec higher-level-spec-diff))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def fields
  (-&gt;&gt;
   (for [k [:abcdefghij
            :baggagejade
            :baggagefeed
            :beachjadehigh
            :deafjigjag
            :hidebadface
            :hidefacebad]]
     [k (mapv (comp keyword str) (name k))])
   (into {})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn initial-world
  [field seed]
  (-&gt; {:field field
       :position (quot (count field) 2)
       :next-saccade 1}
      (vary-meta assoc ::rng (random/make-random seed))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn world-transform
  [m]
  (let [n (count (:field m))
        dx (:next-saccade m)
        x (-&gt; (+ (:position m) dx)
              (mod n))
        [rng rng*] (-&gt; (::rng (meta m))
                       (random/split))
        sacc (util/rand-nth rng* saccades)]
    (-&gt; (assoc m
               :position x
               :last-saccade dx
               :next-saccade sacc)
        (vary-meta assoc ::rng rng))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn attach-current-value
  [m]
  (assoc m :value (get (:field m) (:position m))))</pre></td></tr><tr><td class="docs"><p>Returns an infinite lazy seq of sensory input values.</p>
</td><td class="codes"><pre class="brush: clojure">(defn input-seq
  [world]
  (-&gt;&gt; (iterate world-transform world)
       (map attach-current-value)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def block-sensor
  [:value
   (enc/category-encoder [bit-width] items)])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def block-motor-sensor
  [:next-saccade
   (enc/linear-encoder [motor-bit-width] motor-n-on-bits
                       [(first saccades) (last saccades)])])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn n-region-model
  ([n]
   (n-region-model n spec))
  ([n spec]
   (core/regions-in-series n core/sensorimotor-region
                           (list* spec (repeat higher-level-spec))
                           {:input block-sensor}
                           {:motor block-motor-sensor})))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#org.nfrac.comportex.demos.simple-sentences" name="org.nfrac.comportex.demos.simple-sentences"><h1 class="project-name">org.nfrac.comportex.demos.simple-sentences</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns org.nfrac.comportex.demos.simple-sentences
  (:require [org.nfrac.comportex.core :as core]
            [org.nfrac.comportex.encoders :as enc]
            [org.nfrac.comportex.util :as util]
            [clojure.string :as str]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def bit-width 500)
(def n-on-bits 25)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def spec
  {:column-dimensions [1000]
   :depth 8
   :distal {:perm-init 0.21}
   :distal-vs-proximal-weight 0.2
   })</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def higher-level-spec
  (util/deep-merge
   spec
   {:column-dimensions [800]
    :proximal {:max-segments 5}}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def input-text
  &quot;Jane has eyes.
Jane has a head.
Jane has a mouth.
Jane has a brain.
Jane has a book.
Jane has no friend.
Chifung has eyes.
Chifung has a head.
Chifung has a mouth.
Chifung has a brain.
Chifung has no book.
Chifung has a friend.
Jane is something.
Jane is alive.
Jane is a person.
Jane can talk.
Jane can walk.
Jane can eat.
Chifung is something.
Chifung is alive.
Chifung is a person.
Chifung can talk.
Chifung can walk.
Chifung can eat.
fox has eyes.
fox has a head.
fox has a mouth.
fox has a brain.
fox has a tail.
fox is something.
fox is alive.
fox is no person.
fox can no talk.
fox can walk.
fox can eat.
does Jane have eyes ? yes.
does Jane have a head ? yes.
does Jane have a mouth ? yes.
does Jane have a brain ? yes.
does Jane have a book ? yes.
does Jane have a friend ? no.
does Jane have a tail ? no.
does Chifung have eyes ? yes.
does Chifung have a head ? yes.
does Chifung have a mouth ? yes.
does Chifung have a brain ? yes.
does Chifung have a book ? no.
does Chifung have a friend ? yes.
does Chifung have a tail ? no.
does fox have eyes ? yes.
does fox have a head ? yes.
does fox have a mouth ? yes.
does fox have a brain ? yes.
does fox have a book ? no.
does fox have a friend ? no.
does fox have a tail ? yes.
Jane has no tail.
Chifung has no tail.
&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn split-sentences
  [text*]
  (let [text (str/lower-case (str/trim text*))]
    (-&gt;&gt; (str/split text #&quot;[^\w]*\.+[^\w]*&quot;)
         (mapv #(str/split % #&quot;[^\w']+&quot;))
         (mapv #(vec (concat % [&quot;.&quot;]))))))</pre></td></tr><tr><td class="docs"><p>An input sequence consisting of words from the given text, with
   periods separating sentences also included as distinct words. Each
   sequence element has the form <code>{:word _, :index [i j]}</code>, where i is
   the sentence index and j is the word index into sentence j.</p>
</td><td class="codes"><pre class="brush: clojure">(defn word-item-seq
  [n-repeats text]
  (for [[i sen] (map-indexed vector (split-sentences text))
        rep (range n-repeats)
        [j word] (map-indexed vector sen)]
    {:word word :index [i j]}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def random-sensor
  [:word
   (enc/unique-encoder [bit-width] n-on-bits)])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn n-region-model
  ([n]
   (n-region-model n spec))
  ([n spec]
   (core/regions-in-series n core/sensory-region
                           (list* spec (repeat higher-level-spec))
                           {:input random-sensor})))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#org.nfrac.comportex.util.algo-graph" name="org.nfrac.comportex.util.algo-graph"><h1 class="project-name">org.nfrac.comportex.util.algo-graph</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p> Copyright (c) Jeffrey Straszheim. All rights reserved.  The use and
 distribution terms for this software are covered by the Eclipse Public
 License 1.0 (http://opensource.org/licenses/eclipse-1.0.php) which can
 be found in the file epl-v10.html at the root of this distribution.  By
 using this software in any fashion, you are agreeing to be bound by the
 terms of this license.  You must not remove this notice, or any other,
 from this software.</p>

<p> graph</p>

<p> Basic Graph Theory Algorithms</p>

<p> straszheimjeffrey (gmail)
 Created 23 June 2009</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Basic graph theory algorithms.</p>

<p>Copied from
https://github.com/clojure/algo.graph/blob/03c740c61/src/main/clojure/clojure/algo/graph.clj
because its available snapshot release does not have clojurescript support.</p>

<p>Updated to use records not structs.</p>
</td><td class="codes"><pre class="brush: clojure">(ns
  ^{:author &quot;Jeffrey Straszheim&quot;,
    :doc }
  org.nfrac.comportex.util.algo-graph
  (:require [clojure.set :refer [union]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord DirectedGraph
    [nodes neighbors])</pre></td></tr><tr><td class="docs"><p><code>nodes</code> - The nodes of the graph, a collection.
   <code>neighbors</code> - A function from a node to its neighbor nodes collection.</p>
</td><td class="codes"><pre class="brush: clojure">(defn directed-graph
  [nodes neighbors]
  (-&gt;DirectedGraph nodes neighbors))</pre></td></tr><tr><td class="docs"><p>Get the neighbors of a node.</p>
</td><td class="codes"><pre class="brush: clojure">(defn get-neighbors
  [g n]
  ((:neighbors g) n))</pre></td></tr><tr><td class="docs"><p>Graph Modification</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Given a directed graph, return another directed graph with the
   order of the edges reversed.</p>
</td><td class="codes"><pre class="brush: clojure">(defn reverse-graph
  [g]
  (let [op (fn [rna idx]
             (let [ns (get-neighbors g idx)
                   am (fn [m val]
                        (assoc m val (conj (get m val #{}) idx)))]
               (reduce am rna ns)))
        rn (reduce op {} (:nodes g))]
    (directed-graph (:nodes g) rn)))</pre></td></tr><tr><td class="docs"><p>For each node n, add the edge n->n if not already present.</p>
</td><td class="codes"><pre class="brush: clojure">(defn add-loops
  [g]
  (directed-graph
          (:nodes g)
          (into {} (map (fn [n]
                          [n (conj (set (get-neighbors g n)) n)]) (:nodes g)))))</pre></td></tr><tr><td class="docs"><p>For each node n, remove any edges n->n.</p>
</td><td class="codes"><pre class="brush: clojure">(defn remove-loops
  [g]
  (directed-graph
          (:nodes g)
          (into {} (map (fn [n]
                          [n (disj (set (get-neighbors g n)) n)]) (:nodes g)))))</pre></td></tr><tr><td class="docs"><p>Graph Walk</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Return a lazy sequence of the nodes of a graph starting a node n.  Optionally,
   provide a set of visited notes (v) and a collection of nodes to
   visit (ns).</p>
</td><td class="codes"><pre class="brush: clojure">(defn lazy-walk
  ([g n]
     (lazy-walk g [n] #{}))
  ([g ns v]
     (lazy-seq (let [s (seq (drop-while v ns))
                     n (first s)
                     ns (rest s)]
                 (when s
                   (cons n (lazy-walk g (concat (get-neighbors g n) ns) (conj v n))))))))</pre></td></tr><tr><td class="docs"><p>Returns the transitive closure of a graph.  The neighbors are lazily computed.</p>

<p>   Note: some version of this algorithm return all edges a->a
   regardless of whether such loops exist in the original graph.  This
   version does not.  Loops will be included only if produced by
   cycles in the graph.  If you have code that depends on such
   behavior, call (-> g transitive-closure add-loops)</p>
</td><td class="codes"><pre class="brush: clojure">(defn transitive-closure
  [g]
  (let [nns (fn [n]
              [n (delay (lazy-walk g (get-neighbors g n) #{}))])
        nbs (into {} (map nns (:nodes g)))]
    (directed-graph
            (:nodes g)
            (fn [n] (force (nbs n))))))</pre></td></tr><tr><td class="docs"><p>Strongly Connected Components</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Starting at node n, perform a post-ordered walk.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- post-ordered-visit
  [g n [visited acc :as state]]
  (if (visited n)
    state
    (let [[v2 acc2] (reduce (fn [st nd] (post-ordered-visit g nd st))
                            [(conj visited n) acc]
                            (get-neighbors g n))]
      [v2 (conj acc2 n)])))</pre></td></tr><tr><td class="docs"><p>Return a sequence of indexes of a post-ordered walk of the graph.</p>
</td><td class="codes"><pre class="brush: clojure">(defn post-ordered-nodes
  [g]
  (fnext (reduce #(post-ordered-visit g %2 %1)
                 [#{} []]
                 (:nodes g))))</pre></td></tr><tr><td class="docs"><p>Returns, as a sequence of sets, the strongly connected components
   of g.</p>
</td><td class="codes"><pre class="brush: clojure">(defn scc
  [g]
  (let [po (reverse (post-ordered-nodes g))
        rev (reverse-graph g)
        step (fn [stack visited acc]
               (if (empty? stack)
                 acc
                 (let [[nv comp] (post-ordered-visit rev
                                                     (first stack)
                                                     [visited #{}])
                       ns (remove nv stack)]
                   (recur ns nv (conj acc comp)))))]
    (step po #{} [])))</pre></td></tr><tr><td class="docs"><p>Given a graph, perhaps with cycles, return a reduced graph that is acyclic.
   Each node in the new graph will be a set of nodes from the old.
   These sets are the strongly connected components.  Each edge will
   be the union of the corresponding edges of the prior graph.</p>
</td><td class="codes"><pre class="brush: clojure">(defn component-graph
  ([g]
     (component-graph g (scc g)))
  ([g sccs]
     (let [find-node-set (fn [n]
                           (some #(if (% n) % nil) sccs))
           find-neighbors (fn [ns]
                            (let [nbs1 (map (partial get-neighbors g) ns)
                                  nbs2 (map set nbs1)
                                  nbs3 (apply union nbs2)]
                              (set (map find-node-set nbs3))))
           nm (into {} (map (fn [ns] [ns (find-neighbors ns)]) sccs))]
       (directed-graph (set sccs) nm))))</pre></td></tr><tr><td class="docs"><p>Is the component (recieved from scc) self recursive?</p>
</td><td class="codes"><pre class="brush: clojure">(defn recursive-component?
  [g ns]
  (or (&gt; (count ns) 1)
      (let [n (first ns)]
        (some #(= % n) (get-neighbors g n)))))</pre></td></tr><tr><td class="docs"><p>Returns, as a sequence of sets, the components of a graph that are
   self-recursive.</p>
</td><td class="codes"><pre class="brush: clojure">(defn self-recursive-sets
  [g]
  (filter (partial recursive-component? g) (scc g)))</pre></td></tr><tr><td class="docs"><p>Dependency Lists</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Repeatedly apply fun to data until (equal old-data new-data)
   returns true.  If max iterations occur, it will throw an
   exception.  Set max to nil for unlimited iterations.</p>
</td><td class="codes"><pre class="brush: clojure">(defn fixed-point
  [data fun max equal]
  (let [step (fn step [data idx]
               (when (and idx (= 0 idx))
                 (assert false &quot;Fixed point overflow&quot;))
               (let [new-data (fun data)]
                 (if (equal data new-data)
                   new-data
                   (recur new-data (and idx (dec idx))))))]
    (step data max)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- fold-into-sets
  [priorities]
  (let [max (inc (apply max 0 (vals priorities)))
        step (fn [acc [n dep]]
               (assoc acc dep (conj (acc dep) n)))]
    (reduce step
            (vec (replicate max #{}))
            priorities)))</pre></td></tr><tr><td class="docs"><p>Similar to a topological sort, this returns a vector of sets. The
   set of nodes at index 0 are independent.  The set at index 1 depend
   on index 0; those at 2 depend on 0 and 1, and so on.  Those withing
   a set have no mutual dependencies.  Assume the input graph (which
   much be acyclic) has an edge a->b when a depends on b.</p>
</td><td class="codes"><pre class="brush: clojure">(defn dependency-list
  [g]
  (let [step (fn [d]
               (let [update (fn [n]
                              (inc (apply max -1 (map d (get-neighbors g n)))))]
                 (into {} (map (fn [[k v]] [k (update k)]) d))))
        counts (fixed-point (zipmap (:nodes g) (repeat 0))
                            step
                            (inc (count (:nodes g)))
                            =)]
    (fold-into-sets counts)))</pre></td></tr><tr><td class="docs"><p>Similar to dependency-list (see doc), except two graphs are
   provided.  The first is as dependency-list.  The second (which may
   have cycles) provides a partial-dependency relation.  If node a
   depends on node b (meaning an edge a->b exists) in the second
   graph, node a must be equal or later in the sequence.</p>
</td><td class="codes"><pre class="brush: clojure">(defn stratification-list
  [g1 g2]
  (assert (= (-&gt; g1 :nodes set) (-&gt; g2 :nodes set)))
  (let [step (fn [d]
               (let [update (fn [n]
                              (max (inc (apply max -1
                                               (map d (get-neighbors g1 n))))
                                   (apply max -1 (map d (get-neighbors g2 n)))))]
                 (into {} (map (fn [[k v]] [k (update k)]) d))))
        counts (fixed-point (zipmap (:nodes g1) (repeat 0))
                            step
                            (inc (count (:nodes g1)))
                            =)]
    (fold-into-sets counts)))</pre></td></tr><tr><td class="docs"><p>End of file</p>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr></table><div class="footer">Generated by <a href="https://github.com/gdeer81/marginalia">Marginalia</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a><div id="floating-toc"><ul><li class="floating-toc-li" id="floating-toc_org.nfrac.comportex.cells">org.nfrac.comportex.cells</li><li class="floating-toc-li" id="floating-toc_org.nfrac.comportex.columns">org.nfrac.comportex.columns</li><li class="floating-toc-li" id="floating-toc_org.nfrac.comportex.core">org.nfrac.comportex.core</li><li class="floating-toc-li" id="floating-toc_org.nfrac.comportex.cortical-io">org.nfrac.comportex.cortical-io</li><li class="floating-toc-li" id="floating-toc_org.nfrac.comportex.encoders">org.nfrac.comportex.encoders</li><li class="floating-toc-li" id="floating-toc_org.nfrac.comportex.inhibition">org.nfrac.comportex.inhibition</li><li class="floating-toc-li" id="floating-toc_org.nfrac.comportex.protocols">org.nfrac.comportex.protocols</li><li class="floating-toc-li" id="floating-toc_org.nfrac.comportex.repl">org.nfrac.comportex.repl</li><li class="floating-toc-li" id="floating-toc_org.nfrac.comportex.synapses">org.nfrac.comportex.synapses</li><li class="floating-toc-li" id="floating-toc_org.nfrac.comportex.topology">org.nfrac.comportex.topology</li><li class="floating-toc-li" id="floating-toc_org.nfrac.comportex.util">org.nfrac.comportex.util</li><li class="floating-toc-li" id="floating-toc_org.nfrac.comportex.demos.coordinates-2d">org.nfrac.comportex.demos.coordinates-2d</li><li class="floating-toc-li" id="floating-toc_org.nfrac.comportex.demos.directional-steps-1d">org.nfrac.comportex.demos.directional-steps-1d</li><li class="floating-toc-li" id="floating-toc_org.nfrac.comportex.demos.identity">org.nfrac.comportex.demos.identity</li><li class="floating-toc-li" id="floating-toc_org.nfrac.comportex.demos.isolated-1d">org.nfrac.comportex.demos.isolated-1d</li><li class="floating-toc-li" id="floating-toc_org.nfrac.comportex.demos.letters">org.nfrac.comportex.demos.letters</li><li class="floating-toc-li" id="floating-toc_org.nfrac.comportex.demos.mixed-gaps-1d">org.nfrac.comportex.demos.mixed-gaps-1d</li><li class="floating-toc-li" id="floating-toc_org.nfrac.comportex.demos.q-learning-1d">org.nfrac.comportex.demos.q-learning-1d</li><li class="floating-toc-li" id="floating-toc_org.nfrac.comportex.demos.q-learning-2d">org.nfrac.comportex.demos.q-learning-2d</li><li class="floating-toc-li" id="floating-toc_org.nfrac.comportex.demos.repeat">org.nfrac.comportex.demos.repeat</li><li class="floating-toc-li" id="floating-toc_org.nfrac.comportex.demos.second-level-motor">org.nfrac.comportex.demos.second-level-motor</li><li class="floating-toc-li" id="floating-toc_org.nfrac.comportex.demos.sensorimotor-1d">org.nfrac.comportex.demos.sensorimotor-1d</li><li class="floating-toc-li" id="floating-toc_org.nfrac.comportex.demos.simple-sentences">org.nfrac.comportex.demos.simple-sentences</li><li class="floating-toc-li" id="floating-toc_org.nfrac.comportex.util.algo-graph">org.nfrac.comportex.util.algo-graph</li></ul></div></div><script type="text/javascript">SyntaxHighlighter.defaults['gutter'] = false;
SyntaxHighlighter.all();

// hackity hack
$(window).load(function() {
    var ft = $("#floating-toc");
    var ul = ft.find('ul');
    var lis = ft.find('li');
    var liHeight = $(lis.first()).height();

    ul.css('margin', '0px');
    ft.css('height', liHeight + 'px');

    showNs = function(ns) {
        var index = 0;

        for(i in nsPositions.nss) {
            if(ns == nsPositions.nss[i]) index = i;
        }

        if(index != lastNsIndex) {
            lastNsIndex = index;
            ul.animate({marginTop: (-1 * liHeight * index) + 'px'},
               300);
        }

    }

    var calcNsPositions = function() {
        var hheight = $('.docs-header').first().height();
        var nss = [];
        var anchors = [];
        var positions = [];
        $.each(lis, function(i, el) {
            var ns = $(el).attr('id').split('_')[1];
            nss.push(ns);
            var a = $("a[name='"+ns+"']");
            anchors.push(a);
            positions.push(a.offset().top - hheight);
            // console.log(a.offset().top)
        });

        return {nss: nss, positions: positions};
    }

    var nsPositions = calcNsPositions();
    // console.log(nsPositions)
    var lastNsIndex = -1;
    var $window = $(window);

    var currentSection = function(nsp) {
        var ps = nsp.positions;
        var scroll = $window.scrollTop();
        var nsIndex = -1;

        for(var i = 0, length = ps.length; i < length; i++) {
            if(ps[i] >= scroll) {
                nsIndex = i-1;
                break;
            }
        }

        if(nsIndex == -1) {
             if(scroll >= ps[0]) {
                 nsIndex = ps.length - 1;
             } else {
                 nsIndex = 0;
             }
        }

        return nsp.nss[nsIndex];
    }

    $(window).scroll(function(e) {
        showNs(currentSection(nsPositions));
    });
});
</script></body></html>